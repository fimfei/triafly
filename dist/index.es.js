var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import * as React$1 from "react";
import React__default, { isValidElement, PureComponent, Component, useState, forwardRef, memo, useLayoutEffect, useEffect, createElement, cloneElement, createRef, useRef, useCallback, createContext, useMemo, useContext } from "react";
import * as ReactDOM from "react-dom";
import ReactDOM__default, { unstable_batchedUpdates, createPortal } from "react-dom";
function _arrayLikeToArray$1(r2, a) {
  (null == a || a > r2.length) && (a = r2.length);
  for (var e = 0, n2 = Array(a); e < a; e++)
    n2[e] = r2[e];
  return n2;
}
function _arrayWithHoles(r2) {
  if (Array.isArray(r2))
    return r2;
}
function _arrayWithoutHoles(r2) {
  if (Array.isArray(r2))
    return _arrayLikeToArray$1(r2);
}
function _classCallCheck$a(a, n2) {
  if (!(a instanceof n2))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$1(e, r2) {
  for (var t = 0; t < r2.length; t++) {
    var o = r2[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey$1(o.key), o);
  }
}
function _createClass$9(e, r2, t) {
  return r2 && _defineProperties$1(e.prototype, r2), t && _defineProperties$1(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _createForOfIteratorHelper(r2, e) {
  var t = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (!t) {
    if (Array.isArray(r2) || (t = _unsupportedIterableToArray$1(r2)) || e && r2 && "number" == typeof r2.length) {
      t && (r2 = t);
      var n2 = 0, F = function() {
      };
      return {
        s: F,
        n: function() {
          return n2 >= r2.length ? {
            done: true
          } : {
            done: false,
            value: r2[n2++]
          };
        },
        e: function(r3) {
          throw r3;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return {
    s: function() {
      t = t.call(r2);
    },
    n: function() {
      var r3 = t.next();
      return a = r3.done, r3;
    },
    e: function(r3) {
      u = true, o = r3;
    },
    f: function() {
      try {
        a || null == t.return || t.return();
      } finally {
        if (u)
          throw o;
      }
    }
  };
}
function _defineProperty$7(e, r2, t) {
  return (r2 = _toPropertyKey$1(r2)) in e ? Object.defineProperty(e, r2, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r2] = t, e;
}
function _extends$h() {
  return _extends$h = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r2 in t)
        ({}).hasOwnProperty.call(t, r2) && (n2[r2] = t[r2]);
    }
    return n2;
  }, _extends$h.apply(null, arguments);
}
function _iterableToArray(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"])
    return Array.from(r2);
}
function _iterableToArrayLimit(r2, l2) {
  var t = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t) {
    var e, n2, i, u, a = [], f2 = true, o = false;
    try {
      if (i = (t = t.call(r2)).next, 0 === l2) {
        if (Object(t) !== t)
          return;
        f2 = false;
      } else
        for (; !(f2 = (e = i.call(t)).done) && (a.push(e.value), a.length !== l2); f2 = true)
          ;
    } catch (r3) {
      o = true, n2 = r3;
    } finally {
      try {
        if (!f2 && null != t.return && (u = t.return(), Object(u) !== u))
          return;
      } finally {
        if (o)
          throw n2;
      }
    }
    return a;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _objectDestructuringEmpty(t) {
  if (null == t)
    throw new TypeError("Cannot destructure " + t);
}
function ownKeys$1(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1(Object(t), true).forEach(function(r3) {
      _defineProperty$7(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
function _objectWithoutProperties$3(e, t) {
  if (null == e)
    return {};
  var o, r2, i = _objectWithoutPropertiesLoose$1(e, t);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    for (r2 = 0; r2 < s.length; r2++)
      o = s[r2], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose$1(r2, e) {
  if (null == r2)
    return {};
  var t = {};
  for (var n2 in r2)
    if ({}.hasOwnProperty.call(r2, n2)) {
      if (e.includes(n2))
        continue;
      t[n2] = r2[n2];
    }
  return t;
}
function _slicedToArray(r2, e) {
  return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e) || _unsupportedIterableToArray$1(r2, e) || _nonIterableRest();
}
function _toConsumableArray(r2) {
  return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray$1(r2) || _nonIterableSpread();
}
function _toPrimitive$1(t, r2) {
  if ("object" != typeof t || !t)
    return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r2 || "default");
    if ("object" != typeof i)
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t);
}
function _toPropertyKey$1(t) {
  var i = _toPrimitive$1(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _typeof$1(o) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1(o);
}
function _unsupportedIterableToArray$1(r2, a) {
  if (r2) {
    if ("string" == typeof r2)
      return _arrayLikeToArray$1(r2, a);
    var t = {}.toString.call(r2).slice(8, -1);
    return "Object" === t && r2.constructor && (t = r2.constructor.name), "Map" === t || "Set" === t ? Array.from(r2) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r2, a) : void 0;
  }
}
//! moment.js
//! version : 2.30.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var hookCallback;
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback) {
  hookCallback = callback;
}
function isArray$f(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}
function isObject$b(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}
function hasOwnProp(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k2;
    for (k2 in obj) {
      if (hasOwnProp(obj, k2)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined$2(input) {
  return input === void 0;
}
function isNumber$1(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}
function isDate$2(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}
function map$2(arr, fn) {
  var res = [], i, arrLen = arr.length;
  for (i = 0; i < arrLen; ++i) {
    res.push(fn(arr[i], i));
  }
  return res;
}
function extend$1(a, b) {
  for (var i in b) {
    if (hasOwnProp(b, i)) {
      a[i] = b[i];
    }
  }
  if (hasOwnProp(b, "toString")) {
    a.toString = b.toString;
  }
  if (hasOwnProp(b, "valueOf")) {
    a.valueOf = b.valueOf;
  }
  return a;
}
function createUTC(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m2) {
  if (m2._pf == null) {
    m2._pf = defaultParsingFlags();
  }
  return m2._pf;
}
var some;
if (Array.prototype.some) {
  some = Array.prototype.some;
} else {
  some = function(fun) {
    var t = Object(this), len = t.length >>> 0, i;
    for (i = 0; i < len; i++) {
      if (i in t && fun.call(this, t[i], i, t)) {
        return true;
      }
    }
    return false;
  };
}
function isValid$2(m2) {
  var flags = null, parsedParts = false, isNowValid = m2._d && !isNaN(m2._d.getTime());
  if (isNowValid) {
    flags = getParsingFlags(m2);
    parsedParts = some.call(flags.parsedDateParts, function(i) {
      return i != null;
    });
    isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m2._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
    }
  }
  if (Object.isFrozen == null || !Object.isFrozen(m2)) {
    m2._isValid = isNowValid;
  } else {
    return isNowValid;
  }
  return m2._isValid;
}
function createInvalid(flags) {
  var m2 = createUTC(NaN);
  if (flags != null) {
    extend$1(getParsingFlags(m2), flags);
  } else {
    getParsingFlags(m2).userInvalidated = true;
  }
  return m2;
}
var momentProperties = hooks.momentProperties = [], updateInProgress = false;
function copyConfig(to2, from2) {
  var i, prop, val, momentPropertiesLen = momentProperties.length;
  if (!isUndefined$2(from2._isAMomentObject)) {
    to2._isAMomentObject = from2._isAMomentObject;
  }
  if (!isUndefined$2(from2._i)) {
    to2._i = from2._i;
  }
  if (!isUndefined$2(from2._f)) {
    to2._f = from2._f;
  }
  if (!isUndefined$2(from2._l)) {
    to2._l = from2._l;
  }
  if (!isUndefined$2(from2._strict)) {
    to2._strict = from2._strict;
  }
  if (!isUndefined$2(from2._tzm)) {
    to2._tzm = from2._tzm;
  }
  if (!isUndefined$2(from2._isUTC)) {
    to2._isUTC = from2._isUTC;
  }
  if (!isUndefined$2(from2._offset)) {
    to2._offset = from2._offset;
  }
  if (!isUndefined$2(from2._pf)) {
    to2._pf = getParsingFlags(from2);
  }
  if (!isUndefined$2(from2._locale)) {
    to2._locale = from2._locale;
  }
  if (momentPropertiesLen > 0) {
    for (i = 0; i < momentPropertiesLen; i++) {
      prop = momentProperties[i];
      val = from2[prop];
      if (!isUndefined$2(val)) {
        to2[prop] = val;
      }
    }
  }
  return to2;
}
function Moment(config) {
  copyConfig(this, config);
  this._d = new Date(config._d != null ? config._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}
function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn) {
  var firstTime = true;
  return extend$1(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i, key, argLen = arguments.length;
      for (i = 0; i < argLen; i++) {
        arg = "";
        if (typeof arguments[i] === "object") {
          arg += "\n[" + i + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i];
        }
        args.push(arg);
      }
      warn(
        msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
      );
      firstTime = false;
    }
    return fn.apply(this, arguments);
  }, fn);
}
var deprecations = {};
function deprecateSimple(name, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name, msg);
  }
  if (!deprecations[name]) {
    warn(msg);
    deprecations[name] = true;
  }
}
hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;
function isFunction$6(input) {
  return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}
function set$1(config) {
  var prop, i;
  for (i in config) {
    if (hasOwnProp(config, i)) {
      prop = config[i];
      if (isFunction$6(prop)) {
        this[i] = prop;
      } else {
        this["_" + i] = prop;
      }
    }
  }
  this._config = config;
  this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend$1({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject$b(parentConfig[prop]) && isObject$b(childConfig[prop])) {
        res[prop] = {};
        extend$1(res[prop], parentConfig[prop]);
        extend$1(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject$b(parentConfig[prop])) {
      res[prop] = extend$1({}, res[prop]);
    }
  }
  return res;
}
function Locale(config) {
  if (config != null) {
    this.set(config);
  }
}
var keys$7;
if (Object.keys) {
  keys$7 = Object.keys;
} else {
  keys$7 = function(obj) {
    var i, res = [];
    for (i in obj) {
      if (hasOwnProp(obj, i)) {
        res.push(i);
      }
    }
    return res;
  };
}
var defaultCalendar = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function calendar(key, mom, now2) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction$6(output) ? output.call(mom, now2) : output;
}
function zeroFill(number, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
  return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
function addFormatToken(token2, padded, ordinal2, callback) {
  var func = callback;
  if (typeof callback === "string") {
    func = function() {
      return this[callback]();
    };
  }
  if (token2) {
    formatTokenFunctions[token2] = func;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal2) {
    formatTokenFunctions[ordinal2] = function() {
      return this.localeData().ordinal(
        func.apply(this, arguments),
        token2
      );
    };
  }
}
function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction(format2) {
  var array2 = format2.match(formattingTokens), i, length;
  for (i = 0, length = array2.length; i < length; i++) {
    if (formatTokenFunctions[array2[i]]) {
      array2[i] = formatTokenFunctions[array2[i]];
    } else {
      array2[i] = removeFormattingTokens(array2[i]);
    }
  }
  return function(mom) {
    var output = "", i2;
    for (i2 = 0; i2 < length; i2++) {
      output += isFunction$6(array2[i2]) ? array2[i2].call(mom, format2) : array2[i2];
    }
    return output;
  };
}
function formatMoment(m2, format2) {
  if (!m2.isValid()) {
    return m2.localeData().invalidDate();
  }
  format2 = expandFormat(format2, m2.localeData());
  formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
  return formatFunctions[format2](m2);
}
function expandFormat(format2, locale2) {
  var i = 5;
  function replaceLongDateFormatTokens(input) {
    return locale2.longDateFormat(input) || input;
  }
  localFormattingTokens.lastIndex = 0;
  while (i >= 0 && localFormattingTokens.test(format2)) {
    format2 = format2.replace(
      localFormattingTokens,
      replaceLongDateFormatTokens
    );
    localFormattingTokens.lastIndex = 0;
    i -= 1;
  }
  return format2;
}
var defaultLongDateFormat = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function longDateFormat(key) {
  var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format2 || !formatUpper) {
    return format2;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
var defaultInvalidDate = "Invalid date";
function invalidDate() {
  return this._invalidDate;
}
var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
function ordinal(number) {
  return this._ordinal.replace("%d", number);
}
var defaultRelativeTime = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function relativeTime(number, withoutSuffix, string, isFuture) {
  var output = this._relativeTime[string];
  return isFunction$6(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
}
function pastFuture(diff2, output) {
  var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
  return isFunction$6(format2) ? format2(output) : format2.replace(/%s/i, output);
}
var aliases = {
  D: "date",
  dates: "date",
  date: "date",
  d: "day",
  days: "day",
  day: "day",
  e: "weekday",
  weekdays: "weekday",
  weekday: "weekday",
  E: "isoWeekday",
  isoweekdays: "isoWeekday",
  isoweekday: "isoWeekday",
  DDD: "dayOfYear",
  dayofyears: "dayOfYear",
  dayofyear: "dayOfYear",
  h: "hour",
  hours: "hour",
  hour: "hour",
  ms: "millisecond",
  milliseconds: "millisecond",
  millisecond: "millisecond",
  m: "minute",
  minutes: "minute",
  minute: "minute",
  M: "month",
  months: "month",
  month: "month",
  Q: "quarter",
  quarters: "quarter",
  quarter: "quarter",
  s: "second",
  seconds: "second",
  second: "second",
  gg: "weekYear",
  weekyears: "weekYear",
  weekyear: "weekYear",
  GG: "isoWeekYear",
  isoweekyears: "isoWeekYear",
  isoweekyear: "isoWeekYear",
  w: "week",
  weeks: "week",
  week: "week",
  W: "isoWeek",
  isoweeks: "isoWeek",
  isoweek: "isoWeek",
  y: "year",
  years: "year",
  year: "year"
};
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}
var priorities = {
  date: 9,
  day: 11,
  weekday: 11,
  isoWeekday: 11,
  dayOfYear: 4,
  hour: 13,
  millisecond: 16,
  minute: 14,
  month: 8,
  quarter: 7,
  second: 15,
  weekYear: 1,
  isoWeekYear: 1,
  week: 5,
  isoWeek: 5,
  year: 1
};
function getPrioritizedUnits(unitsObj) {
  var units = [], u;
  for (u in unitsObj) {
    if (hasOwnProp(unitsObj, u)) {
      units.push({ unit: u, priority: priorities[u] });
    }
  }
  units.sort(function(a, b) {
    return a.priority - b.priority;
  });
  return units;
}
var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, match1to2NoLeadingZero = /^[1-9]\d?/, match1to2HasZero = /^([1-9]\d|\d)/, regexes;
regexes = {};
function addRegexToken(token2, regex, strictRegex) {
  regexes[token2] = isFunction$6(regex) ? regex : function(isStrict, localeData2) {
    return isStrict && strictRegex ? strictRegex : regex;
  };
}
function getParseRegexForToken(token2, config) {
  if (!hasOwnProp(regexes, token2)) {
    return new RegExp(unescapeFormat(token2));
  }
  return regexes[token2](config._strict, config._locale);
}
function unescapeFormat(s) {
  return regexEscape(
    s.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }
    )
  );
}
function regexEscape(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function absFloor(number) {
  if (number < 0) {
    return Math.ceil(number) || 0;
  } else {
    return Math.floor(number);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }
  return value;
}
var tokens = {};
function addParseToken(token2, callback) {
  var i, func = callback, tokenLen;
  if (typeof token2 === "string") {
    token2 = [token2];
  }
  if (isNumber$1(callback)) {
    func = function(input, array2) {
      array2[callback] = toInt(input);
    };
  }
  tokenLen = token2.length;
  for (i = 0; i < tokenLen; i++) {
    tokens[token2[i]] = func;
  }
}
function addWeekParseToken(token2, callback) {
  addParseToken(token2, function(input, array2, config, token3) {
    config._w = config._w || {};
    callback(input, config._w, config, token3);
  });
}
function addTimeToArrayFromToken(token2, input, config) {
  if (input != null && hasOwnProp(tokens, token2)) {
    tokens[token2](input, config._a, config, token2);
  }
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
addFormatToken("Y", 0, 0, function() {
  var y = this.year();
  return y <= 9999 ? zeroFill(y, 4) : "+" + y;
});
addFormatToken(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
addFormatToken(0, ["YYYY", 4], 0, "year");
addFormatToken(0, ["YYYYY", 5], 0, "year");
addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
addRegexToken("Y", matchSigned);
addRegexToken("YY", match1to2, match2);
addRegexToken("YYYY", match1to4, match4);
addRegexToken("YYYYY", match1to6, match6);
addRegexToken("YYYYYY", match1to6, match6);
addParseToken(["YYYYY", "YYYYYY"], YEAR);
addParseToken("YYYY", function(input, array2) {
  array2[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken("YY", function(input, array2) {
  array2[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken("Y", function(input, array2) {
  array2[YEAR] = parseInt(input, 10);
});
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
hooks.parseTwoDigitYear = function(input) {
  return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
};
var getSetYear = makeGetSet("FullYear", true);
function getIsLeapYear() {
  return isLeapYear(this.year());
}
function makeGetSet(unit, keepTime) {
  return function(value) {
    if (value != null) {
      set$1$1(this, unit, value);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get$5(this, unit);
    }
  };
}
function get$5(mom, unit) {
  if (!mom.isValid()) {
    return NaN;
  }
  var d = mom._d, isUTC = mom._isUTC;
  switch (unit) {
    case "Milliseconds":
      return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
    case "Seconds":
      return isUTC ? d.getUTCSeconds() : d.getSeconds();
    case "Minutes":
      return isUTC ? d.getUTCMinutes() : d.getMinutes();
    case "Hours":
      return isUTC ? d.getUTCHours() : d.getHours();
    case "Date":
      return isUTC ? d.getUTCDate() : d.getDate();
    case "Day":
      return isUTC ? d.getUTCDay() : d.getDay();
    case "Month":
      return isUTC ? d.getUTCMonth() : d.getMonth();
    case "FullYear":
      return isUTC ? d.getUTCFullYear() : d.getFullYear();
    default:
      return NaN;
  }
}
function set$1$1(mom, unit, value) {
  var d, isUTC, year, month, date2;
  if (!mom.isValid() || isNaN(value)) {
    return;
  }
  d = mom._d;
  isUTC = mom._isUTC;
  switch (unit) {
    case "Milliseconds":
      return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
    case "Seconds":
      return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
    case "Minutes":
      return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
    case "Hours":
      return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
    case "Date":
      return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
    case "FullYear":
      break;
    default:
      return;
  }
  year = value;
  month = mom.month();
  date2 = mom.date();
  date2 = date2 === 29 && month === 1 && !isLeapYear(year) ? 28 : date2;
  void (isUTC ? d.setUTCFullYear(year, month, date2) : d.setFullYear(year, month, date2));
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction$6(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
    for (i = 0; i < prioritizedLen; i++) {
      this[prioritized[i].unit](units[prioritized[i].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction$6(this[units])) {
      return this[units](value);
    }
  }
  return this;
}
function mod(n2, x) {
  return (n2 % x + x) % x;
}
var indexOf;
if (Array.prototype.indexOf) {
  indexOf = Array.prototype.indexOf;
} else {
  indexOf = function(o) {
    var i;
    for (i = 0; i < this.length; ++i) {
      if (this[i] === o) {
        return i;
      }
    }
    return -1;
  };
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
addFormatToken("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
addFormatToken("MMM", 0, 0, function(format2) {
  return this.localeData().monthsShort(this, format2);
});
addFormatToken("MMMM", 0, 0, function(format2) {
  return this.localeData().months(this, format2);
});
addRegexToken("M", match1to2, match1to2NoLeadingZero);
addRegexToken("MM", match1to2, match2);
addRegexToken("MMM", function(isStrict, locale2) {
  return locale2.monthsShortRegex(isStrict);
});
addRegexToken("MMMM", function(isStrict, locale2) {
  return locale2.monthsRegex(isStrict);
});
addParseToken(["M", "MM"], function(input, array2) {
  array2[MONTH] = toInt(input) - 1;
});
addParseToken(["MMM", "MMMM"], function(input, array2, config, token2) {
  var month = config._locale.monthsParse(input, token2, config._strict);
  if (month != null) {
    array2[MONTH] = month;
  } else {
    getParsingFlags(config).invalidMonth = input;
  }
});
var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
function localeMonths(m2, format2) {
  if (!m2) {
    return isArray$f(this._months) ? this._months : this._months["standalone"];
  }
  return isArray$f(this._months) ? this._months[m2.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m2.month()];
}
function localeMonthsShort(m2, format2) {
  if (!m2) {
    return isArray$f(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray$f(this._monthsShort) ? this._monthsShort[m2.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m2.month()];
}
function handleStrictParse(monthName, format2, strict) {
  var i, ii, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i = 0; i < 12; ++i) {
      mom = createUTC([2e3, i]);
      this._shortMonthsParse[i] = this.monthsShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeMonthsParse(monthName, format2, strict) {
  var i, mom, regex;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format2, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    if (strict && !this._longMonthsParse[i]) {
      this._longMonthsParse[i] = new RegExp(
        "^" + this.months(mom, "").replace(".", "") + "$",
        "i"
      );
      this._shortMonthsParse[i] = new RegExp(
        "^" + this.monthsShort(mom, "").replace(".", "") + "$",
        "i"
      );
    }
    if (!strict && !this._monthsParse[i]) {
      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
      return i;
    } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
      return i;
    } else if (!strict && this._monthsParse[i].test(monthName)) {
      return i;
    }
  }
}
function setMonth$1(mom, value) {
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber$1(value)) {
        return mom;
      }
    }
  }
  var month = value, date2 = mom.date();
  date2 = date2 < 29 ? date2 : Math.min(date2, daysInMonth(mom.year(), month));
  void (mom._isUTC ? mom._d.setUTCMonth(month, date2) : mom._d.setMonth(month, date2));
  return mom;
}
function getSetMonth(value) {
  if (value != null) {
    setMonth$1(this, value);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get$5(this, "Month");
  }
}
function getDaysInMonth$1() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i, mom, shortP, longP;
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    shortP = regexEscape(this.monthsShort(mom, ""));
    longP = regexEscape(this.months(mom, ""));
    shortPieces.push(shortP);
    longPieces.push(longP);
    mixedPieces.push(longP);
    mixedPieces.push(shortP);
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._monthsShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
}
function createDate(y, m2, d, h, M, s, ms) {
  var date2;
  if (y < 100 && y >= 0) {
    date2 = new Date(y + 400, m2, d, h, M, s, ms);
    if (isFinite(date2.getFullYear())) {
      date2.setFullYear(y);
    }
  } else {
    date2 = new Date(y, m2, d, h, M, s, ms);
  }
  return date2;
}
function createUTCDate(y) {
  var date2, args;
  if (y < 100 && y >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y + 400;
    date2 = new Date(Date.UTC.apply(null, args));
    if (isFinite(date2.getUTCFullYear())) {
      date2.setUTCFullYear(y);
    }
  } else {
    date2 = new Date(Date.UTC.apply(null, arguments));
  }
  return date2;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
addFormatToken("w", ["ww", 2], "wo", "week");
addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
addRegexToken("w", match1to2, match1to2NoLeadingZero);
addRegexToken("ww", match1to2, match2);
addRegexToken("W", match1to2, match1to2NoLeadingZero);
addRegexToken("WW", match1to2, match2);
addWeekParseToken(
  ["w", "ww", "W", "WW"],
  function(input, week, config, token2) {
    week[token2.substr(0, 1)] = toInt(input);
  }
);
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
var defaultLocaleWeek = {
  dow: 0,
  doy: 6
};
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek(input) {
  var week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}
addFormatToken("d", 0, "do", "day");
addFormatToken("dd", 0, 0, function(format2) {
  return this.localeData().weekdaysMin(this, format2);
});
addFormatToken("ddd", 0, 0, function(format2) {
  return this.localeData().weekdaysShort(this, format2);
});
addFormatToken("dddd", 0, 0, function(format2) {
  return this.localeData().weekdays(this, format2);
});
addFormatToken("e", 0, 0, "weekday");
addFormatToken("E", 0, 0, "isoWeekday");
addRegexToken("d", match1to2);
addRegexToken("e", match1to2);
addRegexToken("E", match1to2);
addRegexToken("dd", function(isStrict, locale2) {
  return locale2.weekdaysMinRegex(isStrict);
});
addRegexToken("ddd", function(isStrict, locale2) {
  return locale2.weekdaysShortRegex(isStrict);
});
addRegexToken("dddd", function(isStrict, locale2) {
  return locale2.weekdaysRegex(isStrict);
});
addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
  var weekday = config._locale.weekdaysParse(input, token2, config._strict);
  if (weekday != null) {
    week.d = weekday;
  } else {
    getParsingFlags(config).invalidWeekday = input;
  }
});
addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
  week[token2] = toInt(input);
});
function parseWeekday(input, locale2) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale2.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday(input, locale2) {
  if (typeof input === "string") {
    return locale2.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
function shiftWeekdays(ws, n2) {
  return ws.slice(n2, 7).concat(ws.slice(0, n2));
}
var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
function localeWeekdays(m2, format2) {
  var weekdays = isArray$f(this._weekdays) ? this._weekdays : this._weekdays[m2 && m2 !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
  return m2 === true ? shiftWeekdays(weekdays, this._week.dow) : m2 ? weekdays[m2.day()] : weekdays;
}
function localeWeekdaysShort(m2) {
  return m2 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m2 ? this._weekdaysShort[m2.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m2) {
  return m2 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m2 ? this._weekdaysMin[m2.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format2, strict) {
  var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i = 0; i < 7; ++i) {
      mom = createUTC([2e3, 1]).day(i);
      this._minWeekdaysParse[i] = this.weekdaysMin(
        mom,
        ""
      ).toLocaleLowerCase();
      this._shortWeekdaysParse[i] = this.weekdaysShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format2, strict) {
  var i, mom, regex;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format2, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    if (strict && !this._fullWeekdaysParse[i]) {
      this._fullWeekdaysParse[i] = new RegExp(
        "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._shortWeekdaysParse[i] = new RegExp(
        "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._minWeekdaysParse[i] = new RegExp(
        "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
    }
    if (!this._weekdaysParse[i]) {
      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
      return i;
    }
  }
}
function getSetDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = get$5(this, "Day");
  if (input != null) {
    input = parseWeekday(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    minp = regexEscape(this.weekdaysMin(mom, ""));
    shortp = regexEscape(this.weekdaysShort(mom, ""));
    longp = regexEscape(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._weekdaysShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
  this._weekdaysMinStrictRegex = new RegExp(
    "^(" + minPieces.join("|") + ")",
    "i"
  );
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
addFormatToken("H", ["HH", 2], 0, "hour");
addFormatToken("h", ["hh", 2], 0, hFormat);
addFormatToken("k", ["kk", 2], 0, kFormat);
addFormatToken("hmm", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});
addFormatToken("hmmss", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
addFormatToken("Hmm", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2);
});
addFormatToken("Hmmss", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
function meridiem(token2, lowercase) {
  addFormatToken(token2, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      lowercase
    );
  });
}
meridiem("a", true);
meridiem("A", false);
function matchMeridiem(isStrict, locale2) {
  return locale2._meridiemParse;
}
addRegexToken("a", matchMeridiem);
addRegexToken("A", matchMeridiem);
addRegexToken("H", match1to2, match1to2HasZero);
addRegexToken("h", match1to2, match1to2NoLeadingZero);
addRegexToken("k", match1to2, match1to2NoLeadingZero);
addRegexToken("HH", match1to2, match2);
addRegexToken("hh", match1to2, match2);
addRegexToken("kk", match1to2, match2);
addRegexToken("hmm", match3to4);
addRegexToken("hmmss", match5to6);
addRegexToken("Hmm", match3to4);
addRegexToken("Hmmss", match5to6);
addParseToken(["H", "HH"], HOUR);
addParseToken(["k", "kk"], function(input, array2, config) {
  var kInput = toInt(input);
  array2[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(["a", "A"], function(input, array2, config) {
  config._isPm = config._locale.isPM(input);
  config._meridiem = input;
});
addParseToken(["h", "hh"], function(input, array2, config) {
  array2[HOUR] = toInt(input);
  getParsingFlags(config).bigHour = true;
});
addParseToken("hmm", function(input, array2, config) {
  var pos = input.length - 2;
  array2[HOUR] = toInt(input.substr(0, pos));
  array2[MINUTE] = toInt(input.substr(pos));
  getParsingFlags(config).bigHour = true;
});
addParseToken("hmmss", function(input, array2, config) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array2[HOUR] = toInt(input.substr(0, pos1));
  array2[MINUTE] = toInt(input.substr(pos1, 2));
  array2[SECOND] = toInt(input.substr(pos2));
  getParsingFlags(config).bigHour = true;
});
addParseToken("Hmm", function(input, array2, config) {
  var pos = input.length - 2;
  array2[HOUR] = toInt(input.substr(0, pos));
  array2[MINUTE] = toInt(input.substr(pos));
});
addParseToken("Hmmss", function(input, array2, config) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array2[HOUR] = toInt(input.substr(0, pos1));
  array2[MINUTE] = toInt(input.substr(pos1, 2));
  array2[SECOND] = toInt(input.substr(pos2));
});
function localeIsPM(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
function localeMeridiem(hours2, minutes2, isLower) {
  if (hours2 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
var baseConfig = {
  calendar: defaultCalendar,
  longDateFormat: defaultLongDateFormat,
  invalidDate: defaultInvalidDate,
  ordinal: defaultOrdinal,
  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
  relativeTime: defaultRelativeTime,
  months: defaultLocaleMonths,
  monthsShort: defaultLocaleMonthsShort,
  week: defaultLocaleWeek,
  weekdays: defaultLocaleWeekdays,
  weekdaysMin: defaultLocaleWeekdaysMin,
  weekdaysShort: defaultLocaleWeekdaysShort,
  meridiemParse: defaultLocaleMeridiemParse
};
var locales = {}, localeFamilies = {}, globalLocale;
function commonPrefix(arr1, arr2) {
  var i, minl = Math.min(arr1.length, arr2.length);
  for (i = 0; i < minl; i += 1) {
    if (arr1[i] !== arr2[i]) {
      return i;
    }
  }
  return minl;
}
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names2) {
  var i = 0, j, next, locale2, split;
  while (i < names2.length) {
    split = normalizeLocale(names2[i]).split("-");
    j = split.length;
    next = normalizeLocale(names2[i + 1]);
    next = next ? next.split("-") : null;
    while (j > 0) {
      locale2 = loadLocale(split.slice(0, j).join("-"));
      if (locale2) {
        return locale2;
      }
      if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
        break;
      }
      j--;
    }
    i++;
  }
  return globalLocale;
}
function isLocaleNameSane(name) {
  return !!(name && name.match("^[^/\\\\]*$"));
}
function loadLocale(name) {
  var oldLocale = null, aliasedRequire;
  if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = require;
      aliasedRequire("./locale/" + name);
      getSetGlobalLocale(oldLocale);
    } catch (e) {
      locales[name] = null;
    }
  }
  return locales[name];
}
function getSetGlobalLocale(key, values) {
  var data;
  if (key) {
    if (isUndefined$2(values)) {
      data = getLocale(key);
    } else {
      data = defineLocale(key, values);
    }
    if (data) {
      globalLocale = data;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(
          "Locale " + key + " not found. Did you forget to load it?"
        );
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name, config) {
  if (config !== null) {
    var locale2, parentConfig = baseConfig;
    config.abbr = name;
    if (locales[name] != null) {
      deprecateSimple(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      );
      parentConfig = locales[name]._config;
    } else if (config.parentLocale != null) {
      if (locales[config.parentLocale] != null) {
        parentConfig = locales[config.parentLocale]._config;
      } else {
        locale2 = loadLocale(config.parentLocale);
        if (locale2 != null) {
          parentConfig = locale2._config;
        } else {
          if (!localeFamilies[config.parentLocale]) {
            localeFamilies[config.parentLocale] = [];
          }
          localeFamilies[config.parentLocale].push({
            name,
            config
          });
          return null;
        }
      }
    }
    locales[name] = new Locale(mergeConfigs(parentConfig, config));
    if (localeFamilies[name]) {
      localeFamilies[name].forEach(function(x) {
        defineLocale(x.name, x.config);
      });
    }
    getSetGlobalLocale(name);
    return locales[name];
  } else {
    delete locales[name];
    return null;
  }
}
function updateLocale(name, config) {
  if (config != null) {
    var locale2, tmpLocale, parentConfig = baseConfig;
    if (locales[name] != null && locales[name].parentLocale != null) {
      locales[name].set(mergeConfigs(locales[name]._config, config));
    } else {
      tmpLocale = loadLocale(name);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config = mergeConfigs(parentConfig, config);
      if (tmpLocale == null) {
        config.abbr = name;
      }
      locale2 = new Locale(config);
      locale2.parentLocale = locales[name];
      locales[name] = locale2;
    }
    getSetGlobalLocale(name);
  } else {
    if (locales[name] != null) {
      if (locales[name].parentLocale != null) {
        locales[name] = locales[name].parentLocale;
        if (name === getSetGlobalLocale()) {
          getSetGlobalLocale(name);
        }
      } else if (locales[name] != null) {
        delete locales[name];
      }
    }
  }
  return locales[name];
}
function getLocale(key) {
  var locale2;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray$f(key)) {
    locale2 = loadLocale(key);
    if (locale2) {
      return locale2;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys$7(locales);
}
function checkOverflow(m2) {
  var overflow, a = m2._a;
  if (a && getParsingFlags(m2).overflow === -2) {
    overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m2)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m2)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m2)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m2).overflow = overflow;
  }
  return m2;
}
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, false],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, false],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, false],
  ["YYYY", /\d{4}/, false]
], isoTimes = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function configFromISO(config) {
  var i, l2, string = config._i, match5 = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
  if (match5) {
    getParsingFlags(config).iso = true;
    for (i = 0, l2 = isoDatesLen; i < l2; i++) {
      if (isoDates[i][1].exec(match5[1])) {
        dateFormat = isoDates[i][0];
        allowTime = isoDates[i][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config._isValid = false;
      return;
    }
    if (match5[3]) {
      for (i = 0, l2 = isoTimesLen; i < l2; i++) {
        if (isoTimes[i][1].exec(match5[3])) {
          timeFormat = (match5[2] || " ") + isoTimes[i][0];
          break;
        }
      }
      if (timeFormat == null) {
        config._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config._isValid = false;
      return;
    }
    if (match5[4]) {
      if (tzRegex.exec(match5[4])) {
        tzFormat = "Z";
      } else {
        config._isValid = false;
        return;
      }
    }
    config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config);
  } else {
    config._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s) {
  return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
      parsedInput[0],
      parsedInput[1],
      parsedInput[2]
    ).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config).weekdayMismatch = true;
      config._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m2 = hm % 100, h = (hm - m2) / 100;
    return h * 60 + m2;
  }
}
function configFromRFC2822(config) {
  var match5 = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
  if (match5) {
    parsedArray = extractFromRFC2822Strings(
      match5[4],
      match5[3],
      match5[2],
      match5[5],
      match5[6],
      match5[7]
    );
    if (!checkWeekday(match5[1], parsedArray, config)) {
      return;
    }
    config._a = parsedArray;
    config._tzm = calculateOffset(match5[8], match5[9], match5[10]);
    config._d = createUTCDate.apply(null, config._a);
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    getParsingFlags(config).rfc2822 = true;
  } else {
    config._isValid = false;
  }
}
function configFromString(config) {
  var matched = aspNetJsonRegex.exec(config._i);
  if (matched !== null) {
    config._d = new Date(+matched[1]);
    return;
  }
  configFromISO(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  configFromRFC2822(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  if (config._strict) {
    config._isValid = false;
  } else {
    hooks.createFromInputFallback(config);
  }
}
hooks.createFromInputFallback = deprecate(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(config) {
    config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
  }
);
function defaults$2(a, b, c) {
  if (a != null) {
    return a;
  }
  if (b != null) {
    return b;
  }
  return c;
}
function currentDateArray(config) {
  var nowValue = new Date(hooks.now());
  if (config._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config) {
  var i, date2, input = [], currentDate, expectedWeekday, yearToUse;
  if (config._d) {
    return;
  }
  currentDate = currentDateArray(config);
  if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config);
  }
  if (config._dayOfYear != null) {
    yearToUse = defaults$2(config._a[YEAR], currentDate[YEAR]);
    if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
      getParsingFlags(config)._overflowDayOfYear = true;
    }
    date2 = createUTCDate(yearToUse, 0, config._dayOfYear);
    config._a[MONTH] = date2.getUTCMonth();
    config._a[DATE] = date2.getUTCDate();
  }
  for (i = 0; i < 3 && config._a[i] == null; ++i) {
    config._a[i] = input[i] = currentDate[i];
  }
  for (; i < 7; i++) {
    config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
  }
  if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
    config._nextDay = true;
    config._a[HOUR] = 0;
  }
  config._d = (config._useUTC ? createUTCDate : createDate).apply(
    null,
    input
  );
  expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
  if (config._tzm != null) {
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
  }
  if (config._nextDay) {
    config._a[HOUR] = 24;
  }
  if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
    getParsingFlags(config).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config) {
  var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w = config._w;
  if (w.GG != null || w.W != null || w.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults$2(
      w.GG,
      config._a[YEAR],
      weekOfYear(createLocal(), 1, 4).year
    );
    week = defaults$2(w.W, 1);
    weekday = defaults$2(w.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config._locale._week.dow;
    doy = config._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults$2(w.gg, config._a[YEAR], curWeek.year);
    week = defaults$2(w.w, curWeek.week);
    if (w.d != null) {
      weekday = w.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w.e != null) {
      weekday = w.e + dow;
      if (w.e < 0 || w.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config._a[YEAR] = temp.year;
    config._dayOfYear = temp.dayOfYear;
  }
}
hooks.ISO_8601 = function() {
};
hooks.RFC_2822 = function() {
};
function configFromStringAndFormat(config) {
  if (config._f === hooks.ISO_8601) {
    configFromISO(config);
    return;
  }
  if (config._f === hooks.RFC_2822) {
    configFromRFC2822(config);
    return;
  }
  config._a = [];
  getParsingFlags(config).empty = true;
  var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
  tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
  tokenLen = tokens2.length;
  for (i = 0; i < tokenLen; i++) {
    token2 = tokens2[i];
    parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
    if (parsedInput) {
      skipped = string.substr(0, string.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config).unusedInput.push(skipped);
      }
      string = string.slice(
        string.indexOf(parsedInput) + parsedInput.length
      );
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token2]) {
      if (parsedInput) {
        getParsingFlags(config).empty = false;
      } else {
        getParsingFlags(config).unusedTokens.push(token2);
      }
      addTimeToArrayFromToken(token2, parsedInput, config);
    } else if (config._strict && !parsedInput) {
      getParsingFlags(config).unusedTokens.push(token2);
    }
  }
  getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
  if (string.length > 0) {
    getParsingFlags(config).unusedInput.push(string);
  }
  if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
    getParsingFlags(config).bigHour = void 0;
  }
  getParsingFlags(config).parsedDateParts = config._a.slice(0);
  getParsingFlags(config).meridiem = config._meridiem;
  config._a[HOUR] = meridiemFixWrap(
    config._locale,
    config._a[HOUR],
    config._meridiem
  );
  era = getParsingFlags(config).era;
  if (era !== null) {
    config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
  }
  configFromArray(config);
  checkOverflow(config);
}
function meridiemFixWrap(locale2, hour, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour;
  }
  if (locale2.meridiemHour != null) {
    return locale2.meridiemHour(hour, meridiem2);
  } else if (locale2.isPM != null) {
    isPm = locale2.isPM(meridiem2);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray(config) {
  var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
  if (configfLen === 0) {
    getParsingFlags(config).invalidFormat = true;
    config._d = new Date(NaN);
    return;
  }
  for (i = 0; i < configfLen; i++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config);
    if (config._useUTC != null) {
      tempConfig._useUTC = config._useUTC;
    }
    tempConfig._f = config._f[i];
    configFromStringAndFormat(tempConfig);
    if (isValid$2(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend$1(config, bestMoment || tempConfig);
}
function configFromObject(config) {
  if (config._d) {
    return;
  }
  var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
  config._a = map$2(
    [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
    function(obj) {
      return obj && parseInt(obj, 10);
    }
  );
  configFromArray(config);
}
function createFromConfig(config) {
  var res = new Moment(checkOverflow(prepareConfig(config)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig(config) {
  var input = config._i, format2 = config._f;
  config._locale = config._locale || getLocale(config._l);
  if (input === null || format2 === void 0 && input === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input === "string") {
    config._i = input = config._locale.preparse(input);
  }
  if (isMoment(input)) {
    return new Moment(checkOverflow(input));
  } else if (isDate$2(input)) {
    config._d = input;
  } else if (isArray$f(format2)) {
    configFromStringAndArray(config);
  } else if (format2) {
    configFromStringAndFormat(config);
  } else {
    configFromInput(config);
  }
  if (!isValid$2(config)) {
    config._d = null;
  }
  return config;
}
function configFromInput(config) {
  var input = config._i;
  if (isUndefined$2(input)) {
    config._d = new Date(hooks.now());
  } else if (isDate$2(input)) {
    config._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString(config);
  } else if (isArray$f(input)) {
    config._a = map$2(input.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config);
  } else if (isObject$b(input)) {
    configFromObject(config);
  } else if (isNumber$1(input)) {
    config._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config);
  }
}
function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
  var c = {};
  if (format2 === true || format2 === false) {
    strict = format2;
    format2 = void 0;
  }
  if (locale2 === true || locale2 === false) {
    strict = locale2;
    locale2 = void 0;
  }
  if (isObject$b(input) && isObjectEmpty(input) || isArray$f(input) && input.length === 0) {
    input = void 0;
  }
  c._isAMomentObject = true;
  c._useUTC = c._isUTC = isUTC;
  c._l = locale2;
  c._i = input;
  c._f = format2;
  c._strict = strict;
  return createFromConfig(c);
}
function createLocal(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, false);
}
var prototypeMin = deprecate(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return createInvalid();
    }
  }
), prototypeMax = deprecate(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return createInvalid();
    }
  }
);
function pickBy(fn, moments) {
  var res, i;
  if (moments.length === 1 && isArray$f(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i = 1; i < moments.length; ++i) {
    if (!moments[i].isValid() || moments[i][fn](res)) {
      res = moments[i];
    }
  }
  return res;
}
function min$2() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isBefore", args);
}
function max$2() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isAfter", args);
}
var now$2 = function() {
  return Date.now ? Date.now() : +new Date();
};
var ordering = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function isDurationValid(m2) {
  var key, unitHasDecimal = false, i, orderLen = ordering.length;
  for (key in m2) {
    if (hasOwnProp(m2, key) && !(indexOf.call(ordering, key) !== -1 && (m2[key] == null || !isNaN(m2[key])))) {
      return false;
    }
  }
  for (i = 0; i < orderLen; ++i) {
    if (m2[ordering[i]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m2[ordering[i]]) !== toInt(m2[ordering[i]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration(duration) {
  var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
  this._days = +days2 + weeks2 * 7;
  this._months = +months2 + quarters * 3 + years2 * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration;
}
function absRound(number) {
  if (number < 0) {
    return Math.round(-1 * number) * -1;
  } else {
    return Math.round(number);
  }
}
function compareArrays(array1, array2, dontConvert) {
  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
  for (i = 0; i < len; i++) {
    if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset$3(token2, separator) {
  addFormatToken(token2, 0, 0, function() {
    var offset2 = this.utcOffset(), sign2 = "+";
    if (offset2 < 0) {
      offset2 = -offset2;
      sign2 = "-";
    }
    return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
  });
}
offset$3("Z", ":");
offset$3("ZZ", "");
addRegexToken("Z", matchShortOffset);
addRegexToken("ZZ", matchShortOffset);
addParseToken(["Z", "ZZ"], function(input, array2, config) {
  config._useUTC = true;
  config._tzm = offsetFromString(matchShortOffset, input);
});
var chunkOffset = /([\+\-]|\d\d)/gi;
function offsetFromString(matcher, string) {
  var matches = (string || "").match(matcher), chunk, parts, minutes2;
  if (matches === null) {
    return null;
  }
  chunk = matches[matches.length - 1] || [];
  parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
  minutes2 = +(parts[1] * 60) + toInt(parts[2]);
  return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
}
function cloneWithOffset(input, model) {
  var res, diff2;
  if (model._isUTC) {
    res = model.clone();
    diff2 = (isMoment(input) || isDate$2(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff2);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input).local();
  }
}
function getDateOffset(m2) {
  return -Math.round(m2._d.getTimezoneOffset());
}
hooks.updateOffset = function() {
};
function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset2 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString(matchShortOffset, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset2 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(
          this,
          createDuration(input - offset2, "m"),
          1,
          false
        );
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset2 : getDateOffset(this);
  }
}
function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined$2(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c = {}, other;
  copyConfig(c, this);
  c = prepareConfig(c);
  if (c._a) {
    other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
    this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function createDuration(input, key) {
  var duration = input, match5 = null, sign2, ret, diffRes;
  if (isDuration(input)) {
    duration = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber$1(input) || !isNaN(+input)) {
    duration = {};
    if (key) {
      duration[key] = +input;
    } else {
      duration.milliseconds = +input;
    }
  } else if (match5 = aspNetRegex.exec(input)) {
    sign2 = match5[1] === "-" ? -1 : 1;
    duration = {
      y: 0,
      d: toInt(match5[DATE]) * sign2,
      h: toInt(match5[HOUR]) * sign2,
      m: toInt(match5[MINUTE]) * sign2,
      s: toInt(match5[SECOND]) * sign2,
      ms: toInt(absRound(match5[MILLISECOND] * 1e3)) * sign2
    };
  } else if (match5 = isoRegex.exec(input)) {
    sign2 = match5[1] === "-" ? -1 : 1;
    duration = {
      y: parseIso(match5[2], sign2),
      M: parseIso(match5[3], sign2),
      w: parseIso(match5[4], sign2),
      d: parseIso(match5[5], sign2),
      h: parseIso(match5[6], sign2),
      m: parseIso(match5[7], sign2),
      s: parseIso(match5[8], sign2)
    };
  } else if (duration == null) {
    duration = {};
  } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
    diffRes = momentsDifference(
      createLocal(duration.from),
      createLocal(duration.to)
    );
    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }
  ret = new Duration(duration);
  if (isDuration(input) && hasOwnProp(input, "_locale")) {
    ret._locale = input._locale;
  }
  if (isDuration(input) && hasOwnProp(input, "_isValid")) {
    ret._isValid = input._isValid;
  }
  return ret;
}
createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;
function parseIso(inp, sign2) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign2;
}
function positiveMomentsDifference(base, other) {
  var res = {};
  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
  if (base.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base, other) {
  var res;
  if (!(base.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base);
  if (base.isBefore(other)) {
    res = positiveMomentsDifference(base, other);
  } else {
    res = positiveMomentsDifference(other, base);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(
        name,
        "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
      );
      tmp = val;
      val = period;
      period = tmp;
    }
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration, isAdding, updateOffset) {
  var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months2) {
    setMonth$1(mom, get$5(mom, "Month") + months2 * isAdding);
  }
  if (days2) {
    set$1$1(mom, "Date", get$5(mom, "Date") + days2 * isAdding);
  }
  if (milliseconds2) {
    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days2 || months2);
  }
}
var add$1 = createAdder(1, "add"), subtract$1 = createAdder(-1, "subtract");
function isString$2(input) {
  return typeof input === "string" || input instanceof String;
}
function isMomentInput(input) {
  return isMoment(input) || isDate$2(input) || isString$2(input) || isNumber$1(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
}
function isMomentInputObject(input) {
  var objectTest = isObject$b(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i, property2, propertyLen = properties.length;
  for (i = 0; i < propertyLen; i += 1) {
    property2 = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property2);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input) {
  var arrayTest = isArray$f(input), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input.filter(function(item) {
      return !isNumber$1(item) && isString$2(input);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input) {
  var objectTest = isObject$b(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i, property2;
  for (i = 0; i < properties.length; i += 1) {
    property2 = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property2);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now2) {
  var diff2 = myMoment.diff(now2, "days", true);
  return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time, formats) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time = void 0;
      formats = void 0;
    } else if (isMomentInput(arguments[0])) {
      time = arguments[0];
      formats = void 0;
    } else if (isCalendarSpec(arguments[0])) {
      formats = arguments[0];
      time = void 0;
    }
  }
  var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction$6(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
  return this.format(
    output || this.localeData().calendar(format2, this, createLocal(now2))
  );
}
function clone() {
  return new Moment(this);
}
function isAfter$1(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore$1(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween(from2, to2, units, inclusivity) {
  var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}
function diff(input, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    case "minute":
      output = (this - that) / 6e4;
      break;
    case "hour":
      output = (this - that) / 36e5;
      break;
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a, b) {
  if (a.date() < b.date()) {
    return -monthDiff(b, a);
  }
  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b - anchor < 0) {
    anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}
hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function toString$5() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m2 = utc ? this.clone().utc() : this;
  if (m2.year() < 0 || m2.year() > 9999) {
    return formatMoment(
      m2,
      utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
    );
  }
  if (isFunction$6(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m2, "Z"));
    }
  }
  return formatMoment(
    m2,
    utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func = "moment", zone = "", prefix, year, datetime, suffix;
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix = "[" + func + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone + '[")]';
  return this.format(prefix + year + datetime + suffix);
}
function format$1(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale(key) {
  var newLocaleData;
  if (key === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
var lang = deprecate(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(key) {
    if (key === void 0) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  }
);
function localeData() {
  return this._locale;
}
var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y, m2, d) {
  if (y < 100 && y >= 0) {
    return new Date(y + 400, m2, d) - MS_PER_400_YEARS;
  } else {
    return new Date(y, m2, d).valueOf();
  }
}
function utcStartOfDate(y, m2, d) {
  if (y < 100 && y >= 0) {
    return Date.UTC(y + 400, m2, d) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y, m2, d);
  }
}
function startOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      time = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time = this._d.valueOf();
      time -= mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      );
      break;
    case "minute":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_MINUTE);
      break;
    case "second":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time = this._d.valueOf();
      time += MS_PER_HOUR - mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      ) - 1;
      break;
    case "minute":
      time = this._d.valueOf();
      time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time = this._d.valueOf();
      time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate$1() {
  return new Date(this.valueOf());
}
function toArray$1() {
  var m2 = this;
  return [
    m2.year(),
    m2.month(),
    m2.date(),
    m2.hour(),
    m2.minute(),
    m2.second(),
    m2.millisecond()
  ];
}
function toObject() {
  var m2 = this;
  return {
    years: m2.year(),
    months: m2.month(),
    date: m2.date(),
    hours: m2.hours(),
    minutes: m2.minutes(),
    seconds: m2.seconds(),
    milliseconds: m2.milliseconds()
  };
}
function toJSON() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2$1() {
  return isValid$2(this);
}
function parsingFlags() {
  return extend$1({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
addFormatToken("N", 0, 0, "eraAbbr");
addFormatToken("NN", 0, 0, "eraAbbr");
addFormatToken("NNN", 0, 0, "eraAbbr");
addFormatToken("NNNN", 0, 0, "eraName");
addFormatToken("NNNNN", 0, 0, "eraNarrow");
addFormatToken("y", ["y", 1], "yo", "eraYear");
addFormatToken("y", ["yy", 2], 0, "eraYear");
addFormatToken("y", ["yyy", 3], 0, "eraYear");
addFormatToken("y", ["yyyy", 4], 0, "eraYear");
addRegexToken("N", matchEraAbbr);
addRegexToken("NN", matchEraAbbr);
addRegexToken("NNN", matchEraAbbr);
addRegexToken("NNNN", matchEraName);
addRegexToken("NNNNN", matchEraNarrow);
addParseToken(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(input, array2, config, token2) {
    var era = config._locale.erasParse(input, token2, config._strict);
    if (era) {
      getParsingFlags(config).era = era;
    } else {
      getParsingFlags(config).invalidEra = input;
    }
  }
);
addRegexToken("y", matchUnsigned);
addRegexToken("yy", matchUnsigned);
addRegexToken("yyy", matchUnsigned);
addRegexToken("yyyy", matchUnsigned);
addRegexToken("yo", matchEraYearOrdinal);
addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
addParseToken(["yo"], function(input, array2, config, token2) {
  var match5;
  if (config._locale._eraYearOrdinalRegex) {
    match5 = input.match(config._locale._eraYearOrdinalRegex);
  }
  if (config._locale.eraYearOrdinalParse) {
    array2[YEAR] = config._locale.eraYearOrdinalParse(input, match5);
  } else {
    array2[YEAR] = parseInt(input, 10);
  }
});
function localeEras(m2, format2) {
  var i, l2, date2, eras = this._eras || getLocale("en")._eras;
  for (i = 0, l2 = eras.length; i < l2; ++i) {
    switch (typeof eras[i].since) {
      case "string":
        date2 = hooks(eras[i].since).startOf("day");
        eras[i].since = date2.valueOf();
        break;
    }
    switch (typeof eras[i].until) {
      case "undefined":
        eras[i].until = Infinity;
        break;
      case "string":
        date2 = hooks(eras[i].until).startOf("day").valueOf();
        eras[i].until = date2.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format2, strict) {
  var i, l2, eras = this.eras(), name, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i = 0, l2 = eras.length; i < l2; ++i) {
    name = eras[i].name.toUpperCase();
    abbr = eras[i].abbr.toUpperCase();
    narrow = eras[i].narrow.toUpperCase();
    if (strict) {
      switch (format2) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i];
          }
          break;
        case "NNNN":
          if (name === eraName) {
            return eras[i];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i];
          }
          break;
      }
    } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === void 0) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i, l2, val, eras = this.localeData().eras();
  for (i = 0, l2 = eras.length; i < l2; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].name;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i, l2, val, eras = this.localeData().eras();
  for (i = 0, l2 = eras.length; i < l2; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].narrow;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i, l2, val, eras = this.localeData().eras();
  for (i = 0, l2 = eras.length; i < l2; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].abbr;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i, l2, dir, val, eras = this.localeData().eras();
  for (i = 0, l2 = eras.length; i < l2; ++i) {
    dir = eras[i].since <= eras[i].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
      return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale2) {
  return locale2.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale2) {
  return locale2.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale2) {
  return locale2.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale2) {
  return locale2._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l2, erasName, erasAbbr, erasNarrow, eras = this.eras();
  for (i = 0, l2 = eras.length; i < l2; ++i) {
    erasName = regexEscape(eras[i].name);
    erasAbbr = regexEscape(eras[i].abbr);
    erasNarrow = regexEscape(eras[i].narrow);
    namePieces.push(erasName);
    abbrPieces.push(erasAbbr);
    narrowPieces.push(erasNarrow);
    mixedPieces.push(erasName);
    mixedPieces.push(erasAbbr);
    mixedPieces.push(erasNarrow);
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp(
    "^(" + narrowPieces.join("|") + ")",
    "i"
  );
}
addFormatToken(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
addFormatToken(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function addWeekYearFormatToken(token2, getter) {
  addFormatToken(0, [token2, token2.length], 0, getter);
}
addWeekYearFormatToken("gggg", "weekYear");
addWeekYearFormatToken("ggggg", "weekYear");
addWeekYearFormatToken("GGGG", "isoWeekYear");
addWeekYearFormatToken("GGGGG", "isoWeekYear");
addRegexToken("G", matchSigned);
addRegexToken("g", matchSigned);
addRegexToken("GG", match1to2, match2);
addRegexToken("gg", match1to2, match2);
addRegexToken("GGGG", match1to4, match4);
addRegexToken("gggg", match1to4, match4);
addRegexToken("GGGGG", match1to6, match6);
addRegexToken("ggggg", match1to6, match6);
addWeekParseToken(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(input, week, config, token2) {
    week[token2.substr(0, 2)] = toInt(input);
  }
);
addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
  week[token2] = hooks.parseTwoDigitYear(input);
});
function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.week(),
    this.weekday() + this.localeData()._week.dow,
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date2 = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date2.getUTCFullYear());
  this.month(date2.getUTCMonth());
  this.date(date2.getUTCDate());
  return this;
}
addFormatToken("Q", 0, "Qo", "quarter");
addRegexToken("Q", match1);
addParseToken("Q", function(input, array2) {
  array2[MONTH] = (toInt(input) - 1) * 3;
});
function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
addFormatToken("D", ["DD", 2], "Do", "date");
addRegexToken("D", match1to2, match1to2NoLeadingZero);
addRegexToken("DD", match1to2, match2);
addRegexToken("Do", function(isStrict, locale2) {
  return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
});
addParseToken(["D", "DD"], DATE);
addParseToken("Do", function(input, array2) {
  array2[DATE] = toInt(input.match(match1to2)[0]);
});
var getSetDayOfMonth = makeGetSet("Date", true);
addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
addRegexToken("DDD", match1to3);
addRegexToken("DDDD", match3);
addParseToken(["DDD", "DDDD"], function(input, array2, config) {
  config._dayOfYear = toInt(input);
});
function getSetDayOfYear(input) {
  var dayOfYear = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}
addFormatToken("m", ["mm", 2], 0, "minute");
addRegexToken("m", match1to2, match1to2HasZero);
addRegexToken("mm", match1to2, match2);
addParseToken(["m", "mm"], MINUTE);
var getSetMinute = makeGetSet("Minutes", false);
addFormatToken("s", ["ss", 2], 0, "second");
addRegexToken("s", match1to2, match1to2HasZero);
addRegexToken("ss", match1to2, match2);
addParseToken(["s", "ss"], SECOND);
var getSetSecond = makeGetSet("Seconds", false);
addFormatToken("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
addFormatToken(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
addFormatToken(0, ["SSS", 3], 0, "millisecond");
addFormatToken(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
addFormatToken(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
addFormatToken(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
addFormatToken(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
addRegexToken("S", match1to3, match1);
addRegexToken("SS", match1to3, match2);
addRegexToken("SSS", match1to3, match3);
var token, getSetMillisecond;
for (token = "SSSS"; token.length <= 9; token += "S") {
  addRegexToken(token, matchUnsigned);
}
function parseMs(input, array2) {
  array2[MILLISECOND] = toInt(("0." + input) * 1e3);
}
for (token = "S"; token.length <= 9; token += "S") {
  addParseToken(token, parseMs);
}
getSetMillisecond = makeGetSet("Milliseconds", false);
addFormatToken("z", 0, 0, "zoneAbbr");
addFormatToken("zz", 0, 0, "zoneName");
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var proto = Moment.prototype;
proto.add = add$1;
proto.calendar = calendar$1;
proto.clone = clone;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format$1;
proto.from = from;
proto.fromNow = fromNow;
proto.to = to;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter$1;
proto.isBefore = isBefore$1;
proto.isBetween = isBetween;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid$2$1;
proto.lang = lang;
proto.locale = locale;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract$1;
proto.toArray = toArray$1;
proto.toObject = toObject;
proto.toDate = toDate$1;
proto.toISOString = toISOString;
proto.inspect = inspect;
if (typeof Symbol !== "undefined" && Symbol.for != null) {
  proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
    return "Moment<" + this.format() + ">";
  };
}
proto.toJSON = toJSON;
proto.toString = toString$5;
proto.unix = unix;
proto.valueOf = valueOf;
proto.creationData = creationData;
proto.eraName = getEraName;
proto.eraNarrow = getEraNarrow;
proto.eraAbbr = getEraAbbr;
proto.eraYear = getEraYear;
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth$1;
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.weeksInWeekYear = getWeeksInWeekYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates = deprecate(
  "dates accessor is deprecated. Use date instead.",
  getSetDayOfMonth
);
proto.months = deprecate(
  "months accessor is deprecated. Use month instead",
  getSetMonth
);
proto.years = deprecate(
  "years accessor is deprecated. Use year instead",
  getSetYear
);
proto.zone = deprecate(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  getSetZone
);
proto.isDSTShifted = deprecate(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  isDaylightSavingTimeShifted
);
function createUnix(input) {
  return createLocal(input * 1e3);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string) {
  return string;
}
var proto$1 = Locale.prototype;
proto$1.calendar = calendar;
proto$1.longDateFormat = longDateFormat;
proto$1.invalidDate = invalidDate;
proto$1.ordinal = ordinal;
proto$1.preparse = preParsePostFormat;
proto$1.postformat = preParsePostFormat;
proto$1.relativeTime = relativeTime;
proto$1.pastFuture = pastFuture;
proto$1.set = set$1;
proto$1.eras = localeEras;
proto$1.erasParse = localeErasParse;
proto$1.erasConvertYear = localeErasConvertYear;
proto$1.erasAbbrRegex = erasAbbrRegex;
proto$1.erasNameRegex = erasNameRegex;
proto$1.erasNarrowRegex = erasNarrowRegex;
proto$1.months = localeMonths;
proto$1.monthsShort = localeMonthsShort;
proto$1.monthsParse = localeMonthsParse;
proto$1.monthsRegex = monthsRegex;
proto$1.monthsShortRegex = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;
proto$1.weekdays = localeWeekdays;
proto$1.weekdaysMin = localeWeekdaysMin;
proto$1.weekdaysShort = localeWeekdaysShort;
proto$1.weekdaysParse = localeWeekdaysParse;
proto$1.weekdaysRegex = weekdaysRegex;
proto$1.weekdaysShortRegex = weekdaysShortRegex;
proto$1.weekdaysMinRegex = weekdaysMinRegex;
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;
function get$1$1(format2, index2, field, setter) {
  var locale2 = getLocale(), utc = createUTC().set(setter, index2);
  return locale2[field](utc, format2);
}
function listMonthsImpl(format2, index2, field) {
  if (isNumber$1(format2)) {
    index2 = format2;
    format2 = void 0;
  }
  format2 = format2 || "";
  if (index2 != null) {
    return get$1$1(format2, index2, field, "month");
  }
  var i, out = [];
  for (i = 0; i < 12; i++) {
    out[i] = get$1$1(format2, i, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format2, index2, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber$1(format2)) {
      index2 = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  } else {
    format2 = localeSorted;
    index2 = format2;
    localeSorted = false;
    if (isNumber$1(format2)) {
      index2 = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  }
  var locale2 = getLocale(), shift3 = localeSorted ? locale2._week.dow : 0, i, out = [];
  if (index2 != null) {
    return get$1$1(format2, (index2 + shift3) % 7, field, "day");
  }
  for (i = 0; i < 7; i++) {
    out[i] = get$1$1(format2, (i + shift3) % 7, field, "day");
  }
  return out;
}
function listMonths(format2, index2) {
  return listMonthsImpl(format2, index2, "months");
}
function listMonthsShort(format2, index2) {
  return listMonthsImpl(format2, index2, "monthsShort");
}
function listWeekdays(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdays");
}
function listWeekdaysShort(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysMin");
}
getSetGlobalLocale("en", {
  eras: [
    {
      since: "0001-01-01",
      until: Infinity,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -Infinity,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(number) {
    var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
    return number + output;
  }
});
hooks.lang = deprecate(
  "moment.lang is deprecated. Use moment.locale instead.",
  getSetGlobalLocale
);
hooks.langData = deprecate(
  "moment.langData is deprecated. Use moment.localeData instead.",
  getLocale
);
var mathAbs = Math.abs;
function abs() {
  var data = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data.milliseconds = mathAbs(data.milliseconds);
  data.seconds = mathAbs(data.seconds);
  data.minutes = mathAbs(data.minutes);
  data.hours = mathAbs(data.hours);
  data.months = mathAbs(data.months);
  data.years = mathAbs(data.years);
  return this;
}
function addSubtract$1(duration, input, value, direction) {
  var other = createDuration(input, value);
  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;
  return duration._bubble();
}
function add$1$1(input, value) {
  return addSubtract$1(this, input, value, 1);
}
function subtract$1$1(input, value) {
  return addSubtract$1(this, input, value, -1);
}
function absCeil(number) {
  if (number < 0) {
    return Math.floor(number);
  } else {
    return Math.ceil(number);
  }
}
function bubble() {
  var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
  if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
    days2 = 0;
    months2 = 0;
  }
  data.milliseconds = milliseconds2 % 1e3;
  seconds2 = absFloor(milliseconds2 / 1e3);
  data.seconds = seconds2 % 60;
  minutes2 = absFloor(seconds2 / 60);
  data.minutes = minutes2 % 60;
  hours2 = absFloor(minutes2 / 60);
  data.hours = hours2 % 24;
  days2 += absFloor(hours2 / 24);
  monthsFromDays = absFloor(daysToMonths(days2));
  months2 += monthsFromDays;
  days2 -= absCeil(monthsToDays(monthsFromDays));
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  data.days = days2;
  data.months = months2;
  data.years = years2;
  return this;
}
function daysToMonths(days2) {
  return days2 * 4800 / 146097;
}
function monthsToDays(months2) {
  return months2 * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days2, months2, milliseconds2 = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days2 = this._days + milliseconds2 / 864e5;
    months2 = this._months + daysToMonths(days2);
    switch (units) {
      case "month":
        return months2;
      case "quarter":
        return months2 / 3;
      case "year":
        return months2 / 12;
    }
  } else {
    days2 = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days2 / 7 + milliseconds2 / 6048e5;
      case "day":
        return days2 + milliseconds2 / 864e5;
      case "hour":
        return days2 * 24 + milliseconds2 / 36e5;
      case "minute":
        return days2 * 1440 + milliseconds2 / 6e4;
      case "second":
        return days2 * 86400 + milliseconds2 / 1e3;
      case "millisecond":
        return Math.floor(days2 * 864e5) + milliseconds2;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y"), valueOf$1 = asMilliseconds;
function clone$1() {
  return createDuration(this);
}
function get$2$1(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name) {
  return function() {
    return this.isValid() ? this._data[name] : NaN;
  };
}
var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
function weeks() {
  return absFloor(this.days() / 7);
}
var round$1 = Math.round, thresholds = {
  ss: 44,
  s: 45,
  m: 45,
  h: 22,
  d: 26,
  w: null,
  M: 11
};
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
  return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
  var duration = createDuration(posNegDuration).abs(), seconds2 = round$1(duration.as("s")), minutes2 = round$1(duration.as("m")), hours2 = round$1(duration.as("h")), days2 = round$1(duration.as("d")), months2 = round$1(duration.as("M")), weeks2 = round$1(duration.as("w")), years2 = round$1(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
  if (thresholds2.w != null) {
    a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
  a[2] = withoutSuffix;
  a[3] = +posNegDuration > 0;
  a[4] = locale2;
  return substituteTimeAgo.apply(null, a);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === void 0) {
    return round$1;
  }
  if (typeof roundingFunction === "function") {
    round$1 = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th = thresholds, locale2, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th.ss = argThresholds.s - 1;
    }
  }
  locale2 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th, locale2);
  if (withSuffix) {
    output = locale2.pastFuture(+this, output);
  }
  return locale2.postformat(output);
}
var abs$1 = Math.abs;
function sign(x) {
  return (x > 0) - (x < 0) || +x;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign(this._months) !== sign(total) ? "-" : "";
  daysSign = sign(this._days) !== sign(total) ? "-" : "";
  hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
}
var proto$2 = Duration.prototype;
proto$2.isValid = isValid$1$1;
proto$2.abs = abs;
proto$2.add = add$1$1;
proto$2.subtract = subtract$1$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asQuarters = asQuarters;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1;
proto$2._bubble = bubble;
proto$2.clone = clone$1;
proto$2.get = get$2$1;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale;
proto$2.localeData = localeData;
proto$2.toIsoString = deprecate(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  toISOString$1
);
proto$2.lang = lang;
addFormatToken("X", 0, 0, "unix");
addFormatToken("x", 0, 0, "valueOf");
addRegexToken("x", matchSigned);
addRegexToken("X", matchTimestamp);
addParseToken("X", function(input, array2, config) {
  config._d = new Date(parseFloat(input) * 1e3);
});
addParseToken("x", function(input, array2, config) {
  config._d = new Date(toInt(input));
});
//! moment.js
hooks.version = "2.30.1";
setHookCallback(createLocal);
hooks.fn = proto;
hooks.min = min$2;
hooks.max = max$2;
hooks.now = now$2;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate$2;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;
hooks.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  DATE: "YYYY-MM-DD",
  TIME: "HH:mm",
  TIME_SECONDS: "HH:mm:ss",
  TIME_MS: "HH:mm:ss.SSS",
  WEEK: "GGGG-[W]WW",
  MONTH: "YYYY-MM"
};
var UTILS$2 = {
  addHideClassIf: function addHideClassIf(requirement) {
    return requirement ? " d-none" : "";
  },
  addActiveClassIf: function addActiveClassIf(requirement) {
    return requirement ? " active" : "";
  },
  random16: function random16() {
    return Math.floor(Math.random() * 1e16);
  }
};
UTILS$2.whenUserClickOutsideTheElement = function(ref, callback) {
  React__default.useEffect(function() {
    function handleClickOutside(event) {
      if (ref.current && !ref.current.contains(event.target)) {
        callback();
      }
    }
    document.addEventListener("mousedown", handleClickOutside);
    return function() {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [ref]);
};
UTILS$2.getValueByPath = function(data, path) {
  var addr = data;
  var pathPoints = path.split(".");
  var _iterator = _createForOfIteratorHelper(pathPoints), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var point = _step.value;
      addr = addr[point];
      if (addr === void 0)
        return null;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return addr;
};
UTILS$2.monoArray = function(size2, value) {
  var arr = [];
  for (var i = 0; i < size2; i++) {
    arr.push(value);
  }
  return arr;
};
UTILS$2.parseParams = function(props) {
  if (props === false) {
    return {
      show: false
    };
  }
  if (!props) {
    return {
      show: true,
      silent: false
    };
  }
  var show = props.show, silent = props.silent;
  return {
    show: show === void 0 ? true : show,
    silent: silent === void 0 ? false : silent
  };
};
UTILS$2.textWithSearchContext = function(text, searchContext, withFlag) {
  var getArr = function getArr2() {
    if (!searchContext || !text) {
      return [text];
    }
    var from2 = text.toUpperCase().indexOf(searchContext.toUpperCase());
    if (!~from2) {
      return [text];
    }
    var to2 = from2 + searchContext.length;
    return [text.slice(0, from2), text.slice(from2, to2), text.slice(to2)];
  };
  var arr = getArr();
  var out = "";
  out += !!arr[0] ? arr[0] : "";
  out += !!arr[1] ? "<search>".concat(arr[1], "</search>") : "";
  out += !!arr[2] ? "".concat(arr[2]) : "";
  if (withFlag)
    return {
      html: out,
      find: !!arr[1]
    };
  return out;
};
UTILS$2.getParamsToString = function(params) {
  var out = "";
  var nextParam = false;
  if (!params) {
    return "";
  }
  for (var name in params) {
    var param = params[name];
    if (param !== null && param !== void 0) {
      out += "".concat(nextParam ? "&" : "?").concat(name, "=").concat(param);
      nextParam = true;
    }
  }
  return out;
};
UTILS$2.idArrayIncrease = function(arr, _add) {
  var add2 = Array.isArray(_add) ? _add : [_add];
  return arr.concat(add2);
};
UTILS$2.idArrayDecrease = function(arr, _sub) {
  var sub = Array.isArray(_sub) ? _sub : [_sub];
  return arr.filter(function(item) {
    return !sub.includes(item);
  });
};
UTILS$2.formats = {
  date: "DD.MM.YYYY",
  dateTime: "DD.MM.YYYY, hh:mm",
  datesSeparator: " - "
};
UTILS$2.checkingInput = {
  "float": function float(value) {
    return /[-\d\.]/.test(value);
  },
  "int": function int(value) {
    return /[-\d]/.test(value);
  },
  positive: function positive(value) {
    return /\d/.test(value);
  }
};
UTILS$2.validators = {
  "float": function float2(value) {
    return !(value && isNaN(value));
  },
  "int": function int2(value) {
    return !(isNaN(value) || !(parseInt(value) === parseFloat(value)) && value != "");
  },
  positive: function positive2(value) {
    return !isNaN(value) && value >= 0;
  },
  date: function date(value) {
    return hooks(value, UTILS$2.formats.date).isValid();
  },
  dateTime: function dateTime(value) {
    return hooks(value, UTILS$2.formats.dateTime).isValid();
  }
};
var table = "";
var Table = function Table2(data) {
  var _React$useState = React__default.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), props = _React$useState2[0], setProps = _React$useState2[1];
  var tablePortalElCurrent = React__default.useRef(null);
  React__default.useEffect(function() {
    setProps(data);
  }, []);
  var refresh = function refresh2() {
    setProps(null);
    setTimeout(function() {
      setProps(data);
    }, 0);
  };
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-wrapper",
    ref: tablePortalElCurrent
  }, props && /* @__PURE__ */ React__default.createElement(TableGo, _extends$h({}, props, {
    refreshTable: refresh,
    tablePortalElCurrent
  })));
};
var TableGo = function TableGo2(props) {
  var tableId = props.tableId, tableClassName = props.tableClassName, _props$options = props.options, options = _props$options === void 0 ? {} : _props$options;
  var _options$showTableSet = options.showTableSettings, showTableSettings = _options$showTableSet === void 0 ? false : _options$showTableSet;
  var tableRootRef = React__default.useRef(null);
  var utilsCurrent = React__default.useRef(new Utils(props));
  var utils2 = utilsCurrent.current;
  React__default.useEffect(function() {
    utils2.connector.refs.unitable = tableRootRef.current;
    utils2.storeRememberPage();
  }, []);
  var data = {
    utils: utils2,
    connector: utils2.connector
  };
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable",
    style: {
      maxWidth: "".concat(utils2.getTotalRowWidth(), "px")
    },
    ref: tableRootRef
  }, /* @__PURE__ */ React__default.createElement("div", {
    id: tableId,
    className: "unitable-inner ".concat(tableClassName)
  }, /* @__PURE__ */ React__default.createElement(HeaderAndBody, data), /* @__PURE__ */ React__default.createElement(TablePaginator, data), showTableSettings && /* @__PURE__ */ React__default.createElement(TableSettings, data)));
};
var HeaderAndBody = function HeaderAndBody2(props) {
  var connector = props.connector;
  var _React$useState3 = React__default.useState(1), _React$useState4 = _slicedToArray(_React$useState3, 2), _ = _React$useState4[0], setRefresh = _React$useState4[1];
  var refresh = function refresh2() {
    setRefresh(UTILS$2.random16);
  };
  React__default.useEffect(function() {
    connector.refresh.headerAndBody = refresh;
  }, []);
  if (!_)
    return null;
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(TableHeader, props), /* @__PURE__ */ React__default.createElement(TableBody, props));
};
var tableHeader = "";
var TableHeader = function TableHeader2(props) {
  var utils2 = props.utils, connector = props.connector;
  var header = connector.header, headerHeight = connector.sizes.headerHeight, rightParts = connector.refs.rightParts, orderTree = connector.orderTree, numberFixedLeftColumns = connector.numberFixedLeftColumns, _connector$options = connector.options, options = _connector$options === void 0 ? {} : _connector$options;
  var _options$background$h = options.background.header, headerBackground = _options$background$h === void 0 ? false : _options$background$h, _options$resize = options.resize, resize = _options$resize === void 0 ? false : _options$resize;
  var refRightPart = React__default.useRef(null);
  var wrapperEl = React__default.useRef(null);
  var startPosition = React__default.useRef(null);
  var _React$useState = React__default.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2);
  _React$useState2[0];
  var setRefresh = _React$useState2[1];
  var refresh = function refresh2() {
    return setRefresh(UTILS$2.random16());
  };
  React__default.useEffect(function() {
    rightParts.push(refRightPart.current);
    connector.refs.headerRight = refRightPart.current;
    connector.refresh.header = refresh;
  }, []);
  var onMouseUp = function onMouseUp2() {
    document.onmouseup = null;
    document.onmousemove = null;
    utils2.refreshTableWidth();
    var bodyHeight = utils2.getBodyHeight();
    connector.refs.unitableBody.style["max-height"] = bodyHeight;
    utils2.saveTableSettingsToLocaleStorage();
  };
  var onMouseMove = function onMouseMove2(e) {
    var _startPosition$curren = startPosition.current, cursorY = _startPosition$curren.cursorY, wrapperHeight = _startPosition$curren.wrapperHeight;
    var newHeight = Math.max(20, wrapperHeight + (e.clientY - cursorY));
    connector.sizes.headerHeight = newHeight;
    refresh();
  };
  var onMouseDown = function onMouseDown2(e) {
    startPosition.current = {
      cursorY: e.clientY,
      wrapperHeight: wrapperEl.current.getBoundingClientRect().height
    };
    document.onmouseup = onMouseUp;
    document.onmousemove = onMouseMove;
  };
  var _utils$splitRowByLeft = utils2.splitRowByLeftAndRight(orderTree, numberFixedLeftColumns), _utils$splitRowByLeft2 = _slicedToArray(_utils$splitRowByLeft, 2), orderLeft = _utils$splitRowByLeft2[0], orderRight = _utils$splitRowByLeft2[1];
  var style = utils2.getHeightStyle(headerHeight);
  if (headerBackground)
    style.background = headerBackground;
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-header",
    style,
    ref: wrapperEl
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-header-left"
  }, orderLeft.map(function(item) {
    var i = item.i, ch = item.ch;
    var cell = header[i];
    var key = "header-cell-".concat(cell._.ordinalIndex);
    return /* @__PURE__ */ React__default.createElement(_RootCells, _extends$h({
      key
    }, props, {
      parent: null,
      cell,
      ch,
      isLeft: true
    }));
  })), /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-header-right",
    style: {
      width: "(100% - ".concat(utils2.getLeftPartRowWidth(), "px")
    },
    ref: refRightPart
  }, orderRight.map(function(item) {
    var i = item.i, ch = item.ch;
    var cell = header[i];
    var key = "header-cell-".concat(cell._.ordinalIndex);
    return /* @__PURE__ */ React__default.createElement(_RootCells, _extends$h({
      key
    }, props, {
      cell,
      parent: null,
      parentCh: orderTree,
      parentChildren: header,
      ch,
      isRight: true
    }));
  })), /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-line left"
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-line right"
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-line top"
  }), resize.headerHeight && /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-line bottom header-resize",
    onMouseDown
  }));
};
var _RootCells = function RootCells(props) {
  var cell = props.cell, ch = props.ch;
  var children = cell.children, _cell$_ = cell._, isEnd = _cell$_.isEnd, endIndex = _cell$_.endIndex;
  if (isEnd)
    return /* @__PURE__ */ React__default.createElement(TableHeaderCell, _extends$h({}, props, {
      cell,
      cellIndex: endIndex
    }));
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-header-root"
  }, /* @__PURE__ */ React__default.createElement(TableHeaderCell, _extends$h({}, props, {
    cell,
    cellIndex: "root"
  })), /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-header-children"
  }, ch.map(function(item) {
    var i = item.i, _ch = item.ch;
    var _cell = children[i];
    var key = "header-cell-".concat(_cell._.ordinalIndex);
    return /* @__PURE__ */ React__default.createElement(_RootCells, _extends$h({
      key
    }, props, {
      cell: _cell,
      parent: cell,
      parentCh: ch,
      parentChildren: children,
      ch: _ch
    }));
  })));
};
var root$b = window;
var COMMUNICATION = root$b.Backbone ? {
  Backbone: root$b.Backbone,
  views: root$b.NetDB.namespace("views"),
  utils: root$b.NetDB.namespace("utils"),
  assets: root$b.NetDB.namespace("assets"),
  widgets: root$b.NetDB.namespace("widgets"),
  slickUtils: root$b.NetdbSlickgrid.Utils(),
  interpolate: root$b.interpolate,
  api: root$b.NetDB.namespace("API")
} : {
  isAbsent: true
};
COMMUNICATION.notify = function(_ref) {
  var isError = _ref.isError, isSpinner = _ref.isSpinner, isUnclosable = _ref.isUnclosable, text = _ref.text, delay = _ref.delay;
  if (COMMUNICATION.isAbsent)
    return null;
  var notify = COMMUNICATION.utils.notify({
    type: isError ? "error" : isSpinner ? "info" : "success",
    message: {
      text
    },
    closable: !isUnclosable,
    fadeOut: delay ? {
      delay
    } : {
      enabled: false
    }
  });
  return notify;
};
COMMUNICATION.prompt = function(_ref2) {
  var text = _ref2.text, _buttons = _ref2.buttons, confirmFn = _ref2.confirmFn;
  if (COMMUNICATION.isAbsent)
    return null;
  var typesClasses = {
    error: "tf_btn-error",
    primary: "tf_btn-primary",
    cancel: "tf_btn-transparent"
  };
  var buttons = _buttons.map(function(button) {
    return {
      text: button.text,
      "class": typesClasses[button.type],
      fn: button.fn
    };
  });
  new COMMUNICATION.views.PromptsView().show({
    confirmFn,
    text,
    buttons
  });
};
COMMUNICATION.getFileMultiple = function(el, options) {
  if (COMMUNICATION.isAbsent)
    return null;
  return new COMMUNICATION.Backbone.FileMultiple(el, options);
};
COMMUNICATION.getPeriodpicker = function(el, options) {
  if (COMMUNICATION.isAbsent)
    return null;
  return new COMMUNICATION.assets.Periodpicker(el, options);
};
COMMUNICATION.getDatepicker = function(el, options) {
  if (COMMUNICATION.isAbsent)
    return null;
  return new COMMUNICATION.Backbone.Datetimepicker(el, options);
};
COMMUNICATION.getSetpicker = function(el, options) {
  if (COMMUNICATION.isAbsent)
    return null;
  return new COMMUNICATION.widgets.Setpicker(el, options);
};
COMMUNICATION.getPf = function(value) {
  if (COMMUNICATION.isAbsent)
    return null;
  return COMMUNICATION.api.predefined.pf(value);
};
COMMUNICATION.getDescriptor = function(descr) {
  if (COMMUNICATION.isAbsent)
    return null;
  return COMMUNICATION.api.descriptors.get(descr) || COMMUNICATION.api.descriptors.find(function(descr2) {
    return descr2.is_lineset_multiple();
  });
};
COMMUNICATION.datetimeToHuman = function() {
  var _COMMUNICATION$slickU;
  if (COMMUNICATION.isAbsent)
    return null;
  return (_COMMUNICATION$slickU = COMMUNICATION.slickUtils).datetimeToHuman.apply(_COMMUNICATION$slickU, arguments);
};
COMMUNICATION.fileMultipleToHuman = function(value) {
  if (COMMUNICATION.isAbsent)
    return null;
  return COMMUNICATION.slickUtils.fileMultipleToHuman(value);
};
COMMUNICATION.prepareChangesToSave = function() {
  var _COMMUNICATION$slickU2;
  if (COMMUNICATION.isAbsent)
    return null;
  (_COMMUNICATION$slickU2 = COMMUNICATION.slickUtils).prepareChangesToSave.apply(_COMMUNICATION$slickU2, arguments);
};
COMMUNICATION.keyCodes = COMMUNICATION.isAbsent ? null : COMMUNICATION.assets.keyCodes(true);
var CONSTANTS = {};
CONSTANTS.fieldTypes = {
  string: {
    id: "-34",
    label: "\u0421\u0442\u0440\u043E\u043A\u0430",
    editor: "TableCellEditorString"
  },
  integer: {
    id: "-35",
    label: "\u0426\u0435\u043B\u043E\u0435",
    editor: "TableCellEditorInteger"
  },
  positive: {
    id: "-36",
    label: "\u041D\u0435\u043E\u0442\u0440\u0438\u0446\u0430\u0442\u0435\u043B\u044C\u043D\u043E\u0435",
    editor: "TableCellEditorPositive"
  },
  "float": {
    id: "-37",
    label: "\u0427\u0438\u0441\u043B\u043E",
    editor: "TableCellEditorFloat"
  },
  set: {
    id: "-38",
    label: "\u0421\u043F\u0440\u0430\u0432\u043E\u0447\u043D\u0438\u043A",
    editor: "TableCellEditorSet"
  },
  bool: {
    id: "-40",
    label: "\u0414\u0430/\u041D\u0435\u0442",
    editor: "TableCellEditorBool"
  },
  date: {
    id: "-41",
    label: "\u0414\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    editor: "TableCellEditorDate"
  },
  period: {
    id: "-42",
    label: "\u041F\u0435\u0440\u0438\u043E\u0434",
    editor: "TableCellEditorPeriod"
  },
  file: {
    id: "-43",
    label: "\u0424\u0430\u0439\u043B",
    editor: "TableCellEditorFile"
  },
  setmultiple: {
    id: "-44",
    label: "\u041C\u043D\u043E\u0436\u0435\u0441\u0442\u0432\u043E \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0439 \u0438\u0437 \u0441\u043F\u0440\u0430\u0432\u043E\u0447\u043D\u0438\u043A\u0430",
    editor: "TableCellEditorSetMultiple"
  },
  filemultiple: {
    id: "-46",
    label: "\u041C\u043D\u043E\u0436\u0435\u0441\u0442\u0432\u0435\u043D\u043D\u044B\u0439 \u0444\u0430\u0439\u043B",
    editor: "TableCellEditorFileMultiple"
  },
  currency: {
    id: "-1100",
    label: "\u0414\u0435\u043D\u0435\u0436\u043D\u044B\u0439",
    editor: "TableCellEditorFloat"
  }
};
CONSTANTS.fieldTypesById = function() {
  return Object.entries(CONSTANTS.fieldTypes).reduce(function(accumulator, value) {
    accumulator[value[1].id] = {
      type: value[0],
      label: value[1].label,
      editor: value[1].editor
    };
    return accumulator;
  }, {});
}();
CONSTANTS.booleanItems = [{
  serverValue: true,
  name: "\u0414\u0430"
}, {
  serverValue: false,
  name: "\u041D\u0435\u0442"
}];
var tableHeaderCell = "";
var TableHeaderCell = function TableHeaderCell2(props) {
  var utils2 = props.utils, connector = props.connector, cell = props.cell, cellIndex = props.cellIndex, isRight = props.isRight;
  var value = cell.value, _cell$view = cell.view, cellView = _cell$view === void 0 ? null : _cell$view, _cell$_ = cell._, level = _cell$_.level, isEnd = _cell$_.isEnd, isEndOfLeftPart = _cell$_.isEndOfLeftPart;
  var _connector$sizes = connector.sizes, columnsWidth = _connector$sizes.columnsWidth, headerHeight = _connector$sizes.headerHeight, headerMaxLevel = connector.headerMaxLevel, _connector$options = connector.options, options = _connector$options === void 0 ? {} : _connector$options, tableHasRowsTree = connector.tableHas.rowsTree, _connector$commonForH = connector.commonForHeader, commonForHeader = _connector$commonForH === void 0 ? {} : _connector$commonForH;
  var _commonForHeader$view = commonForHeader.view, headerView = _commonForHeader$view === void 0 ? null : _commonForHeader$view;
  var _options$resize = options.resize, resize = _options$resize === void 0 ? {} : _options$resize, _options$columnsMenu = options.columnsMenu, _options$columnsMenu$ = _options$columnsMenu.hasHideIcon, hasHideIcon = _options$columnsMenu$ === void 0 ? false : _options$columnsMenu$, _options$columnsMenu$2 = _options$columnsMenu.hasOrderIcon, hasOrderIcon = _options$columnsMenu$2 === void 0 ? false : _options$columnsMenu$2, _options$columnsMenu$3 = _options$columnsMenu.hasFormatIcon, hasFormatIcon = _options$columnsMenu$3 === void 0 ? false : _options$columnsMenu$3, _options$columnsMenu$4 = _options$columnsMenu.hasSearchIcon, hasSearchIcon = _options$columnsMenu$4 === void 0 ? false : _options$columnsMenu$4, _options$columnsMenu$5 = _options$columnsMenu.hasSortIcon, hasSortIcon = _options$columnsMenu$5 === void 0 ? false : _options$columnsMenu$5;
  var ExternalCellView = cellView || headerView;
  var isRoot = isNaN(cellIndex);
  var isRowsTreeMenu = tableHasRowsTree && !cellIndex;
  var heightPart = headerHeight / headerMaxLevel;
  var _React$useState = React__default.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2);
  _React$useState2[0];
  var setRefresh = _React$useState2[1];
  var refresh = function refresh2() {
    return setRefresh(UTILS$2.random16());
  };
  React__default.useEffect(function() {
    var _cell$_2;
    var data = {
      refresh,
      ref: wrapperEl.current,
      cell
    };
    connector.data.headerRoot.push(data);
    if ((_cell$_2 = cell._) !== null && _cell$_2 !== void 0 && _cell$_2.endIndex)
      connector.data.headerRootByEndIndex[cell._.endIndex] = data;
    if (isRoot) {
      return;
    }
    connector.refresh.column[cellIndex] = connector.refresh.column[cellIndex] || [];
    connector.refresh.column[cellIndex].push(refresh);
    cell._.refresh = refresh;
    setTimeout(refresh, 0);
  }, []);
  var wrapperEl = React__default.useRef(null);
  var startPosition = React__default.useRef(null);
  var onSortCurrent = React__default.useRef(function() {
  });
  var onMouseUp = function onMouseUp2(e) {
    document.onmouseup = null;
    document.onmousemove = null;
    if (e.ctrlKey && !isRoot) {
      for (var index2 in connector.sizes.columnsWidth)
        connector.sizes.columnsWidth[index2] = startPosition.current.newWidth;
      utils2.refreshAllColumns();
    }
    utils2.refreshTableWidth();
    utils2.saveTableSettingsToLocaleStorage();
    utils2.refreshHeaderRoots();
  };
  var onMouseMove = function onMouseMove2(e) {
    var _startPosition$curren = startPosition.current, cursorX = _startPosition$curren.cursorX, wrapperWidth = _startPosition$curren.wrapperWidth;
    var newWidth = Math.max(20, wrapperWidth + (e.clientX - cursorX));
    startPosition.current.newWidth = newWidth;
    if (!isRoot) {
      connector.sizes.columnsWidth[cellIndex] = newWidth;
      utils2.refreshColumn(cellIndex);
      return;
    }
    var percent = newWidth * 100 / wrapperWidth;
    var _iterator = _createForOfIteratorHelper(utils2.getEndsByHeaderCell(cell)), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var child = _step.value;
        var originalIndex = child._.endIndex;
        var w = startPosition.current.columnsWidth[originalIndex];
        columnsWidth[originalIndex] = Math.round(w / 100 * percent);
        utils2.refreshColumn(originalIndex);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  };
  var onMouseDown = function onMouseDown2(e) {
    startPosition.current = {
      cursorX: e.clientX,
      wrapperWidth: wrapperEl.current.getBoundingClientRect().width,
      columnsWidth: _toConsumableArray(columnsWidth)
    };
    document.onmouseup = onMouseUp;
    document.onmousemove = onMouseMove;
  };
  var showColumn = function showColumn2(show) {
    return function() {
      if (isRoot) {
        var _iterator2 = _createForOfIteratorHelper(utils2.getEndsByHeaderCell(cell)), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var child = _step2.value;
            var originalIndex = child._.endIndex;
            connector.showColumns[originalIndex] = show;
            utils2.refreshColumn(originalIndex);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } else {
        connector.showColumns[cellIndex] = show;
        utils2.refreshColumn(cellIndex);
      }
      utils2.refreshTableWidth();
      utils2.saveTableSettingsToLocaleStorage();
    };
  };
  var isShow = isRoot || connector.showColumns[cellIndex];
  var style = isShow ? utils2.getWidthStyle(columnsWidth[cellIndex]) : {};
  style.height = "".concat(isEnd ? heightPart * (headerMaxLevel - level) : heightPart, "px");
  var _ref = isRight && isShow ? utils2.getHeaderRootsPadding(wrapperEl.current) : {
    paddingLeft: 0,
    paddingRight: 0
  }, paddingLeft = _ref.paddingLeft, paddingRight = _ref.paddingRight;
  var cellMenuIsPresent = hasHideIcon || hasOrderIcon || hasSearchIcon || hasFormatIcon || hasSortIcon;
  if (wrapperEl.current)
    cell._.wrapperRefCurrent = wrapperEl;
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-header-cell index-".concat(cellIndex).concat(isShow ? "" : " is-hide").concat(isEnd ? " is-end" : ""),
    style,
    ref: wrapperEl
  }, isShow ? /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("div", {
    className: "uhc-content".concat(isEnd ? " is-end" : "").concat(isEndOfLeftPart ? " is-end-of-left" : ""),
    style: {
      paddingLeft: "".concat(paddingLeft, "px"),
      paddingRight: "".concat(paddingRight, "px")
    }
  }, isRowsTreeMenu ? /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(TableHeaderCellRowsTreeMenu, props), /* @__PURE__ */ React__default.createElement(TableHeaderCellMenu, _extends$h({}, props, {
    onSortCurrent
  }))) : /* @__PURE__ */ React__default.createElement("div", {
    className: "uhc-content-inner"
  }, ExternalCellView ? /* @__PURE__ */ React__default.createElement(ExternalCellView, cell) : /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, value), cell._.sort && /* @__PURE__ */ React__default.createElement("i", {
    className: "uhc-content-sort fas fa-sort-".concat(cell._.sort),
    onClick: function onClick() {
      return onSortCurrent.current();
    }
  }), /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, cellMenuIsPresent && /* @__PURE__ */ React__default.createElement(TableHeaderCellMenu, _extends$h({}, props, {
    showColumn,
    onSortCurrent
  }))))), resize.columnsWidth && /* @__PURE__ */ React__default.createElement("div", {
    className: "uhc-resizer",
    onMouseDown
  })) : /* @__PURE__ */ React__default.createElement("div", {
    className: "uhc-bookmark",
    title: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0441\u043A\u0440\u044B\u0442\u0443\u044E \u043A\u043E\u043B\u043E\u043D\u043A\u0443",
    onClick: showColumn(true)
  }));
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var lib = {};
var flattenNames$1 = {};
var freeGlobal$3 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$3;
var freeGlobal$2 = _freeGlobal;
var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
var root$a = freeGlobal$2 || freeSelf$1 || Function("return this")();
var _root = root$a;
var root$9 = _root;
var Symbol$8 = root$9.Symbol;
var _Symbol = Symbol$8;
var Symbol$7 = _Symbol;
var objectProto$u = Object.prototype;
var hasOwnProperty$p = objectProto$u.hasOwnProperty;
var nativeObjectToString$3 = objectProto$u.toString;
var symToStringTag$3 = Symbol$7 ? Symbol$7.toStringTag : void 0;
function getRawTag$2(value) {
  var isOwn = hasOwnProperty$p.call(value, symToStringTag$3), tag = value[symToStringTag$3];
  try {
    value[symToStringTag$3] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$3.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$3] = tag;
    } else {
      delete value[symToStringTag$3];
    }
  }
  return result;
}
var _getRawTag = getRawTag$2;
var objectProto$t = Object.prototype;
var nativeObjectToString$2 = objectProto$t.toString;
function objectToString$2(value) {
  return nativeObjectToString$2.call(value);
}
var _objectToString = objectToString$2;
var Symbol$6 = _Symbol, getRawTag$1 = _getRawTag, objectToString$1 = _objectToString;
var nullTag$1 = "[object Null]", undefinedTag$1 = "[object Undefined]";
var symToStringTag$2 = Symbol$6 ? Symbol$6.toStringTag : void 0;
function baseGetTag$8(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag$1 : nullTag$1;
  }
  return symToStringTag$2 && symToStringTag$2 in Object(value) ? getRawTag$1(value) : objectToString$1(value);
}
var _baseGetTag = baseGetTag$8;
var isArray$e = Array.isArray;
var isArray_1 = isArray$e;
function isObjectLike$a(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$a;
var baseGetTag$7 = _baseGetTag, isArray$d = isArray_1, isObjectLike$9 = isObjectLike_1;
var stringTag$6 = "[object String]";
function isString$1(value) {
  return typeof value == "string" || !isArray$d(value) && isObjectLike$9(value) && baseGetTag$7(value) == stringTag$6;
}
var isString_1 = isString$1;
function createBaseFor$2(fromRight) {
  return function(object2, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object2;
  };
}
var _createBaseFor = createBaseFor$2;
var createBaseFor$1 = _createBaseFor;
var baseFor$3 = createBaseFor$1();
var _baseFor = baseFor$3;
function baseTimes$2(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$2;
var baseGetTag$6 = _baseGetTag, isObjectLike$8 = isObjectLike_1;
var argsTag$6 = "[object Arguments]";
function baseIsArguments$2(value) {
  return isObjectLike$8(value) && baseGetTag$6(value) == argsTag$6;
}
var _baseIsArguments = baseIsArguments$2;
var baseIsArguments$1 = _baseIsArguments, isObjectLike$7 = isObjectLike_1;
var objectProto$s = Object.prototype;
var hasOwnProperty$o = objectProto$s.hasOwnProperty;
var propertyIsEnumerable$3 = objectProto$s.propertyIsEnumerable;
var isArguments$4 = baseIsArguments$1(function() {
  return arguments;
}()) ? baseIsArguments$1 : function(value) {
  return isObjectLike$7(value) && hasOwnProperty$o.call(value, "callee") && !propertyIsEnumerable$3.call(value, "callee");
};
var isArguments_1 = isArguments$4;
var isBuffer$6 = { exports: {} };
function stubFalse$1() {
  return false;
}
var stubFalse_1 = stubFalse$1;
(function(module2, exports2) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var Buffer2 = moduleExports2 ? root2.Buffer : void 0;
  var nativeIsBuffer2 = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer2 || stubFalse2;
  module2.exports = isBuffer2;
})(isBuffer$6, isBuffer$6.exports);
var MAX_SAFE_INTEGER$3 = 9007199254740991;
var reIsUint$1 = /^(?:0|[1-9]\d*)$/;
function isIndex$3(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$3 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint$1.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$3;
var MAX_SAFE_INTEGER$2 = 9007199254740991;
function isLength$4(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$2;
}
var isLength_1 = isLength$4;
var baseGetTag$5 = _baseGetTag, isLength$3 = isLength_1, isObjectLike$6 = isObjectLike_1;
var argsTag$5 = "[object Arguments]", arrayTag$4 = "[object Array]", boolTag$5 = "[object Boolean]", dateTag$5 = "[object Date]", errorTag$4 = "[object Error]", funcTag$4 = "[object Function]", mapTag$8 = "[object Map]", numberTag$5 = "[object Number]", objectTag$8 = "[object Object]", regexpTag$5 = "[object RegExp]", setTag$8 = "[object Set]", stringTag$5 = "[object String]", weakMapTag$4 = "[object WeakMap]";
var arrayBufferTag$5 = "[object ArrayBuffer]", dataViewTag$7 = "[object DataView]", float32Tag$3 = "[object Float32Array]", float64Tag$3 = "[object Float64Array]", int8Tag$3 = "[object Int8Array]", int16Tag$3 = "[object Int16Array]", int32Tag$3 = "[object Int32Array]", uint8Tag$3 = "[object Uint8Array]", uint8ClampedTag$3 = "[object Uint8ClampedArray]", uint16Tag$3 = "[object Uint16Array]", uint32Tag$3 = "[object Uint32Array]";
var typedArrayTags$1 = {};
typedArrayTags$1[float32Tag$3] = typedArrayTags$1[float64Tag$3] = typedArrayTags$1[int8Tag$3] = typedArrayTags$1[int16Tag$3] = typedArrayTags$1[int32Tag$3] = typedArrayTags$1[uint8Tag$3] = typedArrayTags$1[uint8ClampedTag$3] = typedArrayTags$1[uint16Tag$3] = typedArrayTags$1[uint32Tag$3] = true;
typedArrayTags$1[argsTag$5] = typedArrayTags$1[arrayTag$4] = typedArrayTags$1[arrayBufferTag$5] = typedArrayTags$1[boolTag$5] = typedArrayTags$1[dataViewTag$7] = typedArrayTags$1[dateTag$5] = typedArrayTags$1[errorTag$4] = typedArrayTags$1[funcTag$4] = typedArrayTags$1[mapTag$8] = typedArrayTags$1[numberTag$5] = typedArrayTags$1[objectTag$8] = typedArrayTags$1[regexpTag$5] = typedArrayTags$1[setTag$8] = typedArrayTags$1[stringTag$5] = typedArrayTags$1[weakMapTag$4] = false;
function baseIsTypedArray$2(value) {
  return isObjectLike$6(value) && isLength$3(value.length) && !!typedArrayTags$1[baseGetTag$5(value)];
}
var _baseIsTypedArray = baseIsTypedArray$2;
function baseUnary$4(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$4;
var _nodeUtil = { exports: {} };
(function(module2, exports2) {
  var freeGlobal2 = _freeGlobal;
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var freeProcess2 = moduleExports2 && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
    } catch (e) {
    }
  }();
  module2.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray$1 = _baseIsTypedArray, baseUnary$3 = _baseUnary, nodeUtil$4 = _nodeUtil.exports;
var nodeIsTypedArray$1 = nodeUtil$4 && nodeUtil$4.isTypedArray;
var isTypedArray$5 = nodeIsTypedArray$1 ? baseUnary$3(nodeIsTypedArray$1) : baseIsTypedArray$1;
var isTypedArray_1 = isTypedArray$5;
var baseTimes$1 = _baseTimes, isArguments$3 = isArguments_1, isArray$c = isArray_1, isBuffer$5 = isBuffer$6.exports, isIndex$2 = _isIndex, isTypedArray$4 = isTypedArray_1;
var objectProto$r = Object.prototype;
var hasOwnProperty$n = objectProto$r.hasOwnProperty;
function arrayLikeKeys$3(value, inherited) {
  var isArr = isArray$c(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$5(value), isType = !isArr && !isArg && !isBuff && isTypedArray$4(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes$1(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$n.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex$2(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$3;
var objectProto$q = Object.prototype;
function isPrototype$4(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$q;
  return value === proto2;
}
var _isPrototype = isPrototype$4;
function overArg$3(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var _overArg = overArg$3;
var overArg$2 = _overArg;
var nativeKeys$3 = overArg$2(Object.keys, Object);
var _nativeKeys = nativeKeys$3;
var isPrototype$3 = _isPrototype, nativeKeys$2 = _nativeKeys;
var objectProto$p = Object.prototype;
var hasOwnProperty$m = objectProto$p.hasOwnProperty;
function baseKeys$2(object2) {
  if (!isPrototype$3(object2)) {
    return nativeKeys$2(object2);
  }
  var result = [];
  for (var key in Object(object2)) {
    if (hasOwnProperty$m.call(object2, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$2;
function isObject$a(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$a;
var baseGetTag$4 = _baseGetTag, isObject$9 = isObject_1;
var asyncTag$1 = "[object AsyncFunction]", funcTag$3 = "[object Function]", genTag$2 = "[object GeneratorFunction]", proxyTag$1 = "[object Proxy]";
function isFunction$5(value) {
  if (!isObject$9(value)) {
    return false;
  }
  var tag = baseGetTag$4(value);
  return tag == funcTag$3 || tag == genTag$2 || tag == asyncTag$1 || tag == proxyTag$1;
}
var isFunction_1 = isFunction$5;
var isFunction$4 = isFunction_1, isLength$2 = isLength_1;
function isArrayLike$5(value) {
  return value != null && isLength$2(value.length) && !isFunction$4(value);
}
var isArrayLike_1 = isArrayLike$5;
var arrayLikeKeys$2 = _arrayLikeKeys, baseKeys$1 = _baseKeys, isArrayLike$4 = isArrayLike_1;
function keys$6(object2) {
  return isArrayLike$4(object2) ? arrayLikeKeys$2(object2) : baseKeys$1(object2);
}
var keys_1 = keys$6;
var baseFor$2 = _baseFor, keys$5 = keys_1;
function baseForOwn$3(object2, iteratee) {
  return object2 && baseFor$2(object2, iteratee, keys$5);
}
var _baseForOwn = baseForOwn$3;
function identity$3(value) {
  return value;
}
var identity_1 = identity$3;
var identity$2 = identity_1;
function castFunction$2(value) {
  return typeof value == "function" ? value : identity$2;
}
var _castFunction = castFunction$2;
var baseForOwn$2 = _baseForOwn, castFunction$1 = _castFunction;
function forOwn(object2, iteratee) {
  return object2 && baseForOwn$2(object2, castFunction$1(iteratee));
}
var forOwn_1 = forOwn;
var overArg$1 = _overArg;
var getPrototype$5 = overArg$1(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$5;
var baseGetTag$3 = _baseGetTag, getPrototype$4 = _getPrototype, isObjectLike$5 = isObjectLike_1;
var objectTag$7 = "[object Object]";
var funcProto$5 = Function.prototype, objectProto$o = Object.prototype;
var funcToString$5 = funcProto$5.toString;
var hasOwnProperty$l = objectProto$o.hasOwnProperty;
var objectCtorString$1 = funcToString$5.call(Object);
function isPlainObject$4(value) {
  if (!isObjectLike$5(value) || baseGetTag$3(value) != objectTag$7) {
    return false;
  }
  var proto2 = getPrototype$4(value);
  if (proto2 === null) {
    return true;
  }
  var Ctor = hasOwnProperty$l.call(proto2, "constructor") && proto2.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$5.call(Ctor) == objectCtorString$1;
}
var isPlainObject_1 = isPlainObject$4;
function arrayMap$3(array2, iteratee) {
  var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array2[index2], index2, array2);
  }
  return result;
}
var _arrayMap = arrayMap$3;
function listCacheClear$2() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$2;
function eq$5(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$5;
var eq$4 = eq_1;
function assocIndexOf$5(array2, key) {
  var length = array2.length;
  while (length--) {
    if (eq$4(array2[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$5;
var assocIndexOf$4 = _assocIndexOf;
var arrayProto$1 = Array.prototype;
var splice$1 = arrayProto$1.splice;
function listCacheDelete$2(key) {
  var data = this.__data__, index2 = assocIndexOf$4(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice$1.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$2;
var assocIndexOf$3 = _assocIndexOf;
function listCacheGet$2(key) {
  var data = this.__data__, index2 = assocIndexOf$3(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet = listCacheGet$2;
var assocIndexOf$2 = _assocIndexOf;
function listCacheHas$2(key) {
  return assocIndexOf$2(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$2;
var assocIndexOf$1 = _assocIndexOf;
function listCacheSet$2(key, value) {
  var data = this.__data__, index2 = assocIndexOf$1(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$2;
var listCacheClear$1 = _listCacheClear, listCacheDelete$1 = _listCacheDelete, listCacheGet$1 = _listCacheGet, listCacheHas$1 = _listCacheHas, listCacheSet$1 = _listCacheSet;
function ListCache$5(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$5.prototype.clear = listCacheClear$1;
ListCache$5.prototype["delete"] = listCacheDelete$1;
ListCache$5.prototype.get = listCacheGet$1;
ListCache$5.prototype.has = listCacheHas$1;
ListCache$5.prototype.set = listCacheSet$1;
var _ListCache = ListCache$5;
var ListCache$4 = _ListCache;
function stackClear$2() {
  this.__data__ = new ListCache$4();
  this.size = 0;
}
var _stackClear = stackClear$2;
function stackDelete$2(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$2;
function stackGet$2(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$2;
function stackHas$2(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$2;
var root$8 = _root;
var coreJsData$3 = root$8["__core-js_shared__"];
var _coreJsData = coreJsData$3;
var coreJsData$2 = _coreJsData;
var maskSrcKey$1 = function() {
  var uid = /[^.]+$/.exec(coreJsData$2 && coreJsData$2.keys && coreJsData$2.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$2(func) {
  return !!maskSrcKey$1 && maskSrcKey$1 in func;
}
var _isMasked = isMasked$2;
var funcProto$4 = Function.prototype;
var funcToString$4 = funcProto$4.toString;
function toSource$3(func) {
  if (func != null) {
    try {
      return funcToString$4.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$3;
var isFunction$3 = isFunction_1, isMasked$1 = _isMasked, isObject$8 = isObject_1, toSource$2 = _toSource;
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
var funcProto$3 = Function.prototype, objectProto$n = Object.prototype;
var funcToString$3 = funcProto$3.toString;
var hasOwnProperty$k = objectProto$n.hasOwnProperty;
var reIsNative$1 = RegExp(
  "^" + funcToString$3.call(hasOwnProperty$k).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$2(value) {
  if (!isObject$8(value) || isMasked$1(value)) {
    return false;
  }
  var pattern = isFunction$3(value) ? reIsNative$1 : reIsHostCtor$1;
  return pattern.test(toSource$2(value));
}
var _baseIsNative = baseIsNative$2;
function getValue$2(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
var _getValue = getValue$2;
var baseIsNative$1 = _baseIsNative, getValue$1 = _getValue;
function getNative$8(object2, key) {
  var value = getValue$1(object2, key);
  return baseIsNative$1(value) ? value : void 0;
}
var _getNative = getNative$8;
var getNative$7 = _getNative, root$7 = _root;
var Map$6 = getNative$7(root$7, "Map");
var _Map = Map$6;
var getNative$6 = _getNative;
var nativeCreate$6 = getNative$6(Object, "create");
var _nativeCreate = nativeCreate$6;
var nativeCreate$5 = _nativeCreate;
function hashClear$2() {
  this.__data__ = nativeCreate$5 ? nativeCreate$5(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$2;
function hashDelete$2(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$2;
var nativeCreate$4 = _nativeCreate;
var HASH_UNDEFINED$5 = "__lodash_hash_undefined__";
var objectProto$m = Object.prototype;
var hasOwnProperty$j = objectProto$m.hasOwnProperty;
function hashGet$2(key) {
  var data = this.__data__;
  if (nativeCreate$4) {
    var result = data[key];
    return result === HASH_UNDEFINED$5 ? void 0 : result;
  }
  return hasOwnProperty$j.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$2;
var nativeCreate$3 = _nativeCreate;
var objectProto$l = Object.prototype;
var hasOwnProperty$i = objectProto$l.hasOwnProperty;
function hashHas$2(key) {
  var data = this.__data__;
  return nativeCreate$3 ? data[key] !== void 0 : hasOwnProperty$i.call(data, key);
}
var _hashHas = hashHas$2;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$4 = "__lodash_hash_undefined__";
function hashSet$2(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$2 && value === void 0 ? HASH_UNDEFINED$4 : value;
  return this;
}
var _hashSet = hashSet$2;
var hashClear$1 = _hashClear, hashDelete$1 = _hashDelete, hashGet$1 = _hashGet, hashHas$1 = _hashHas, hashSet$1 = _hashSet;
function Hash$2(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$2.prototype.clear = hashClear$1;
Hash$2.prototype["delete"] = hashDelete$1;
Hash$2.prototype.get = hashGet$1;
Hash$2.prototype.has = hashHas$1;
Hash$2.prototype.set = hashSet$1;
var _Hash = Hash$2;
var Hash$1 = _Hash, ListCache$3 = _ListCache, Map$5 = _Map;
function mapCacheClear$2() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash$1(),
    "map": new (Map$5 || ListCache$3)(),
    "string": new Hash$1()
  };
}
var _mapCacheClear = mapCacheClear$2;
function isKeyable$2(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$2;
var isKeyable$1 = _isKeyable;
function getMapData$5(map3, key) {
  var data = map3.__data__;
  return isKeyable$1(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$5;
var getMapData$4 = _getMapData;
function mapCacheDelete$2(key) {
  var result = getMapData$4(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$2;
var getMapData$3 = _getMapData;
function mapCacheGet$2(key) {
  return getMapData$3(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$2;
var getMapData$2 = _getMapData;
function mapCacheHas$2(key) {
  return getMapData$2(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$2;
var getMapData$1 = _getMapData;
function mapCacheSet$2(key, value) {
  var data = getMapData$1(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$2;
var mapCacheClear$1 = _mapCacheClear, mapCacheDelete$1 = _mapCacheDelete, mapCacheGet$1 = _mapCacheGet, mapCacheHas$1 = _mapCacheHas, mapCacheSet$1 = _mapCacheSet;
function MapCache$4(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$4.prototype.clear = mapCacheClear$1;
MapCache$4.prototype["delete"] = mapCacheDelete$1;
MapCache$4.prototype.get = mapCacheGet$1;
MapCache$4.prototype.has = mapCacheHas$1;
MapCache$4.prototype.set = mapCacheSet$1;
var _MapCache = MapCache$4;
var ListCache$2 = _ListCache, Map$4 = _Map, MapCache$3 = _MapCache;
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet$2(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$2) {
    var pairs = data.__data__;
    if (!Map$4 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$3(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$2;
var ListCache$1 = _ListCache, stackClear$1 = _stackClear, stackDelete$1 = _stackDelete, stackGet$1 = _stackGet, stackHas$1 = _stackHas, stackSet$1 = _stackSet;
function Stack$4(entries) {
  var data = this.__data__ = new ListCache$1(entries);
  this.size = data.size;
}
Stack$4.prototype.clear = stackClear$1;
Stack$4.prototype["delete"] = stackDelete$1;
Stack$4.prototype.get = stackGet$1;
Stack$4.prototype.has = stackHas$1;
Stack$4.prototype.set = stackSet$1;
var _Stack = Stack$4;
var HASH_UNDEFINED$3 = "__lodash_hash_undefined__";
function setCacheAdd$2(value) {
  this.__data__.set(value, HASH_UNDEFINED$3);
  return this;
}
var _setCacheAdd = setCacheAdd$2;
function setCacheHas$2(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$2;
var MapCache$2 = _MapCache, setCacheAdd$1 = _setCacheAdd, setCacheHas$1 = _setCacheHas;
function SetCache$2(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache$2();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd$1;
SetCache$2.prototype.has = setCacheHas$1;
var _SetCache = SetCache$2;
function arraySome$2(array2, predicate) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (predicate(array2[index2], index2, array2)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$2;
function cacheHas$2(cache2, key) {
  return cache2.has(key);
}
var _cacheHas = cacheHas$2;
var SetCache$1 = _SetCache, arraySome$1 = _arraySome, cacheHas$1 = _cacheHas;
var COMPARE_PARTIAL_FLAG$b = 1, COMPARE_UNORDERED_FLAG$7 = 2;
function equalArrays$3(array2, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$b, arrLength = array2.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array2);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array2;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$7 ? new SetCache$1() : void 0;
  stack.set(array2, other);
  stack.set(other, array2);
  while (++index2 < arrLength) {
    var arrValue = array2[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome$1(other, function(othValue2, othIndex) {
        if (!cacheHas$1(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array2);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$3;
var root$6 = _root;
var Uint8Array$5 = root$6.Uint8Array;
var _Uint8Array = Uint8Array$5;
function mapToArray$2(map3) {
  var index2 = -1, result = Array(map3.size);
  map3.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$2;
function setToArray$2(set5) {
  var index2 = -1, result = Array(set5.size);
  set5.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var _setToArray = setToArray$2;
var Symbol$5 = _Symbol, Uint8Array$4 = _Uint8Array, eq$3 = eq_1, equalArrays$2 = _equalArrays, mapToArray$1 = _mapToArray, setToArray$1 = _setToArray;
var COMPARE_PARTIAL_FLAG$a = 1, COMPARE_UNORDERED_FLAG$6 = 2;
var boolTag$4 = "[object Boolean]", dateTag$4 = "[object Date]", errorTag$3 = "[object Error]", mapTag$7 = "[object Map]", numberTag$4 = "[object Number]", regexpTag$4 = "[object RegExp]", setTag$7 = "[object Set]", stringTag$4 = "[object String]", symbolTag$5 = "[object Symbol]";
var arrayBufferTag$4 = "[object ArrayBuffer]", dataViewTag$6 = "[object DataView]";
var symbolProto$4 = Symbol$5 ? Symbol$5.prototype : void 0, symbolValueOf$2 = symbolProto$4 ? symbolProto$4.valueOf : void 0;
function equalByTag$2(object2, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$6:
      if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
        return false;
      }
      object2 = object2.buffer;
      other = other.buffer;
    case arrayBufferTag$4:
      if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$4(object2), new Uint8Array$4(other))) {
        return false;
      }
      return true;
    case boolTag$4:
    case dateTag$4:
    case numberTag$4:
      return eq$3(+object2, +other);
    case errorTag$3:
      return object2.name == other.name && object2.message == other.message;
    case regexpTag$4:
    case stringTag$4:
      return object2 == other + "";
    case mapTag$7:
      var convert = mapToArray$1;
    case setTag$7:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$a;
      convert || (convert = setToArray$1);
      if (object2.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object2);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$6;
      stack.set(object2, other);
      var result = equalArrays$2(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object2);
      return result;
    case symbolTag$5:
      if (symbolValueOf$2) {
        return symbolValueOf$2.call(object2) == symbolValueOf$2.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$2;
function arrayPush$3(array2, values) {
  var index2 = -1, length = values.length, offset2 = array2.length;
  while (++index2 < length) {
    array2[offset2 + index2] = values[index2];
  }
  return array2;
}
var _arrayPush = arrayPush$3;
var arrayPush$2 = _arrayPush, isArray$b = isArray_1;
function baseGetAllKeys$3(object2, keysFunc, symbolsFunc) {
  var result = keysFunc(object2);
  return isArray$b(object2) ? result : arrayPush$2(result, symbolsFunc(object2));
}
var _baseGetAllKeys = baseGetAllKeys$3;
function arrayFilter$2(array2, predicate) {
  var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array2[index2];
    if (predicate(value, index2, array2)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$2;
function stubArray$3() {
  return [];
}
var stubArray_1 = stubArray$3;
var arrayFilter$1 = _arrayFilter, stubArray$2 = stubArray_1;
var objectProto$k = Object.prototype;
var propertyIsEnumerable$2 = objectProto$k.propertyIsEnumerable;
var nativeGetSymbols$2 = Object.getOwnPropertySymbols;
var getSymbols$5 = !nativeGetSymbols$2 ? stubArray$2 : function(object2) {
  if (object2 == null) {
    return [];
  }
  object2 = Object(object2);
  return arrayFilter$1(nativeGetSymbols$2(object2), function(symbol) {
    return propertyIsEnumerable$2.call(object2, symbol);
  });
};
var _getSymbols = getSymbols$5;
var baseGetAllKeys$2 = _baseGetAllKeys, getSymbols$4 = _getSymbols, keys$4 = keys_1;
function getAllKeys$3(object2) {
  return baseGetAllKeys$2(object2, keys$4, getSymbols$4);
}
var _getAllKeys = getAllKeys$3;
var getAllKeys$2 = _getAllKeys;
var COMPARE_PARTIAL_FLAG$9 = 1;
var objectProto$j = Object.prototype;
var hasOwnProperty$h = objectProto$j.hasOwnProperty;
function equalObjects$2(object2, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$9, objProps = getAllKeys$2(object2), objLength = objProps.length, othProps = getAllKeys$2(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$h.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object2);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object2;
  }
  var result = true;
  stack.set(object2, other);
  stack.set(other, object2);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object2[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object2.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object2);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$2;
var getNative$5 = _getNative, root$5 = _root;
var DataView$3 = getNative$5(root$5, "DataView");
var _DataView = DataView$3;
var getNative$4 = _getNative, root$4 = _root;
var Promise$4 = getNative$4(root$4, "Promise");
var _Promise = Promise$4;
var getNative$3 = _getNative, root$3 = _root;
var Set$4 = getNative$3(root$3, "Set");
var _Set = Set$4;
var getNative$2 = _getNative, root$2 = _root;
var WeakMap$3 = getNative$2(root$2, "WeakMap");
var _WeakMap = WeakMap$3;
var DataView$2 = _DataView, Map$3 = _Map, Promise$3 = _Promise, Set$3 = _Set, WeakMap$2 = _WeakMap, baseGetTag$2 = _baseGetTag, toSource$1 = _toSource;
var mapTag$6 = "[object Map]", objectTag$6 = "[object Object]", promiseTag$1 = "[object Promise]", setTag$6 = "[object Set]", weakMapTag$3 = "[object WeakMap]";
var dataViewTag$5 = "[object DataView]";
var dataViewCtorString$1 = toSource$1(DataView$2), mapCtorString$1 = toSource$1(Map$3), promiseCtorString$1 = toSource$1(Promise$3), setCtorString$1 = toSource$1(Set$3), weakMapCtorString$1 = toSource$1(WeakMap$2);
var getTag$6 = baseGetTag$2;
if (DataView$2 && getTag$6(new DataView$2(new ArrayBuffer(1))) != dataViewTag$5 || Map$3 && getTag$6(new Map$3()) != mapTag$6 || Promise$3 && getTag$6(Promise$3.resolve()) != promiseTag$1 || Set$3 && getTag$6(new Set$3()) != setTag$6 || WeakMap$2 && getTag$6(new WeakMap$2()) != weakMapTag$3) {
  getTag$6 = function(value) {
    var result = baseGetTag$2(value), Ctor = result == objectTag$6 ? value.constructor : void 0, ctorString = Ctor ? toSource$1(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString$1:
          return dataViewTag$5;
        case mapCtorString$1:
          return mapTag$6;
        case promiseCtorString$1:
          return promiseTag$1;
        case setCtorString$1:
          return setTag$6;
        case weakMapCtorString$1:
          return weakMapTag$3;
      }
    }
    return result;
  };
}
var _getTag = getTag$6;
var Stack$3 = _Stack, equalArrays$1 = _equalArrays, equalByTag$1 = _equalByTag, equalObjects$1 = _equalObjects, getTag$5 = _getTag, isArray$a = isArray_1, isBuffer$4 = isBuffer$6.exports, isTypedArray$3 = isTypedArray_1;
var COMPARE_PARTIAL_FLAG$8 = 1;
var argsTag$4 = "[object Arguments]", arrayTag$3 = "[object Array]", objectTag$5 = "[object Object]";
var objectProto$i = Object.prototype;
var hasOwnProperty$g = objectProto$i.hasOwnProperty;
function baseIsEqualDeep$2(object2, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$a(object2), othIsArr = isArray$a(other), objTag = objIsArr ? arrayTag$3 : getTag$5(object2), othTag = othIsArr ? arrayTag$3 : getTag$5(other);
  objTag = objTag == argsTag$4 ? objectTag$5 : objTag;
  othTag = othTag == argsTag$4 ? objectTag$5 : othTag;
  var objIsObj = objTag == objectTag$5, othIsObj = othTag == objectTag$5, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$4(object2)) {
    if (!isBuffer$4(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$3());
    return objIsArr || isTypedArray$3(object2) ? equalArrays$1(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag$1(object2, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$8)) {
    var objIsWrapped = objIsObj && hasOwnProperty$g.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$g.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$3());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$3());
  return equalObjects$1(object2, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$2;
var baseIsEqualDeep$1 = _baseIsEqualDeep, isObjectLike$4 = isObjectLike_1;
function baseIsEqual$3(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$4(value) && !isObjectLike$4(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep$1(value, other, bitmask, customizer, baseIsEqual$3, stack);
}
var _baseIsEqual = baseIsEqual$3;
var Stack$2 = _Stack, baseIsEqual$2 = _baseIsEqual;
var COMPARE_PARTIAL_FLAG$7 = 1, COMPARE_UNORDERED_FLAG$5 = 2;
function baseIsMatch$2(object2, source, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object2 == null) {
    return !length;
  }
  object2 = Object(object2);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key = data[0], objValue = object2[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object2)) {
        return false;
      }
    } else {
      var stack = new Stack$2();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object2, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual$2(srcValue, objValue, COMPARE_PARTIAL_FLAG$7 | COMPARE_UNORDERED_FLAG$5, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch$2;
var isObject$7 = isObject_1;
function isStrictComparable$3(value) {
  return value === value && !isObject$7(value);
}
var _isStrictComparable = isStrictComparable$3;
var isStrictComparable$2 = _isStrictComparable, keys$3 = keys_1;
function getMatchData$2(object2) {
  var result = keys$3(object2), length = result.length;
  while (length--) {
    var key = result[length], value = object2[key];
    result[length] = [key, value, isStrictComparable$2(value)];
  }
  return result;
}
var _getMatchData = getMatchData$2;
function matchesStrictComparable$3(key, srcValue) {
  return function(object2) {
    if (object2 == null) {
      return false;
    }
    return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
  };
}
var _matchesStrictComparable = matchesStrictComparable$3;
var baseIsMatch$1 = _baseIsMatch, getMatchData$1 = _getMatchData, matchesStrictComparable$2 = _matchesStrictComparable;
function baseMatches$2(source) {
  var matchData = getMatchData$1(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$2(matchData[0][0], matchData[0][1]);
  }
  return function(object2) {
    return object2 === source || baseIsMatch$1(object2, source, matchData);
  };
}
var _baseMatches = baseMatches$2;
var baseGetTag$1 = _baseGetTag, isObjectLike$3 = isObjectLike_1;
var symbolTag$4 = "[object Symbol]";
function isSymbol$4(value) {
  return typeof value == "symbol" || isObjectLike$3(value) && baseGetTag$1(value) == symbolTag$4;
}
var isSymbol_1 = isSymbol$4;
var isArray$9 = isArray_1, isSymbol$3 = isSymbol_1;
var reIsDeepProp$1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp$1 = /^\w*$/;
function isKey$4(value, object2) {
  if (isArray$9(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$3(value)) {
    return true;
  }
  return reIsPlainProp$1.test(value) || !reIsDeepProp$1.test(value) || object2 != null && value in Object(object2);
}
var _isKey = isKey$4;
var MapCache$1 = _MapCache;
var FUNC_ERROR_TEXT$3 = "Expected a function";
function memoize$3(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$3);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize$3.Cache || MapCache$1)();
  return memoized;
}
memoize$3.Cache = MapCache$1;
var memoize_1 = memoize$3;
var memoize$2 = memoize_1;
var MAX_MEMOIZE_SIZE$1 = 500;
function memoizeCapped$2(func) {
  var result = memoize$2(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE$1) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$2;
var memoizeCapped$1 = _memoizeCapped;
var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar$1 = /\\(\\)?/g;
var stringToPath$3 = memoizeCapped$1(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName$1, function(match5, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar$1, "$1") : number || match5);
  });
  return result;
});
var _stringToPath = stringToPath$3;
var Symbol$4 = _Symbol, arrayMap$2 = _arrayMap, isArray$8 = isArray_1, isSymbol$2 = isSymbol_1;
var INFINITY$3 = 1 / 0;
var symbolProto$3 = Symbol$4 ? Symbol$4.prototype : void 0, symbolToString$1 = symbolProto$3 ? symbolProto$3.toString : void 0;
function baseToString$2(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$8(value)) {
    return arrayMap$2(value, baseToString$2) + "";
  }
  if (isSymbol$2(value)) {
    return symbolToString$1 ? symbolToString$1.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
}
var _baseToString = baseToString$2;
var baseToString$1 = _baseToString;
function toString$4(value) {
  return value == null ? "" : baseToString$1(value);
}
var toString_1 = toString$4;
var isArray$7 = isArray_1, isKey$3 = _isKey, stringToPath$2 = _stringToPath, toString$3 = toString_1;
function castPath$3(value, object2) {
  if (isArray$7(value)) {
    return value;
  }
  return isKey$3(value, object2) ? [value] : stringToPath$2(toString$3(value));
}
var _castPath = castPath$3;
var isSymbol$1 = isSymbol_1;
var INFINITY$2 = 1 / 0;
function toKey$5(value) {
  if (typeof value == "string" || isSymbol$1(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
}
var _toKey = toKey$5;
var castPath$2 = _castPath, toKey$4 = _toKey;
function baseGet$3(object2, path) {
  path = castPath$2(path, object2);
  var index2 = 0, length = path.length;
  while (object2 != null && index2 < length) {
    object2 = object2[toKey$4(path[index2++])];
  }
  return index2 && index2 == length ? object2 : void 0;
}
var _baseGet = baseGet$3;
var baseGet$2 = _baseGet;
function get$4(object2, path, defaultValue) {
  var result = object2 == null ? void 0 : baseGet$2(object2, path);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get$4;
function baseHasIn$2(object2, key) {
  return object2 != null && key in Object(object2);
}
var _baseHasIn = baseHasIn$2;
var castPath$1 = _castPath, isArguments$2 = isArguments_1, isArray$6 = isArray_1, isIndex$1 = _isIndex, isLength$1 = isLength_1, toKey$3 = _toKey;
function hasPath$2(object2, path, hasFunc) {
  path = castPath$1(path, object2);
  var index2 = -1, length = path.length, result = false;
  while (++index2 < length) {
    var key = toKey$3(path[index2]);
    if (!(result = object2 != null && hasFunc(object2, key))) {
      break;
    }
    object2 = object2[key];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object2 == null ? 0 : object2.length;
  return !!length && isLength$1(length) && isIndex$1(key, length) && (isArray$6(object2) || isArguments$2(object2));
}
var _hasPath = hasPath$2;
var baseHasIn$1 = _baseHasIn, hasPath$1 = _hasPath;
function hasIn$2(object2, path) {
  return object2 != null && hasPath$1(object2, path, baseHasIn$1);
}
var hasIn_1 = hasIn$2;
var baseIsEqual$1 = _baseIsEqual, get$3 = get_1, hasIn$1 = hasIn_1, isKey$2 = _isKey, isStrictComparable$1 = _isStrictComparable, matchesStrictComparable$1 = _matchesStrictComparable, toKey$2 = _toKey;
var COMPARE_PARTIAL_FLAG$6 = 1, COMPARE_UNORDERED_FLAG$4 = 2;
function baseMatchesProperty$2(path, srcValue) {
  if (isKey$2(path) && isStrictComparable$1(srcValue)) {
    return matchesStrictComparable$1(toKey$2(path), srcValue);
  }
  return function(object2) {
    var objValue = get$3(object2, path);
    return objValue === void 0 && objValue === srcValue ? hasIn$1(object2, path) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$6 | COMPARE_UNORDERED_FLAG$4);
  };
}
var _baseMatchesProperty = baseMatchesProperty$2;
function baseProperty$2(key) {
  return function(object2) {
    return object2 == null ? void 0 : object2[key];
  };
}
var _baseProperty = baseProperty$2;
var baseGet$1 = _baseGet;
function basePropertyDeep$2(path) {
  return function(object2) {
    return baseGet$1(object2, path);
  };
}
var _basePropertyDeep = basePropertyDeep$2;
var baseProperty$1 = _baseProperty, basePropertyDeep$1 = _basePropertyDeep, isKey$1 = _isKey, toKey$1 = _toKey;
function property$2(path) {
  return isKey$1(path) ? baseProperty$1(toKey$1(path)) : basePropertyDeep$1(path);
}
var property_1 = property$2;
var baseMatches$1 = _baseMatches, baseMatchesProperty$1 = _baseMatchesProperty, identity$1 = identity_1, isArray$5 = isArray_1, property$1 = property_1;
function baseIteratee$2(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity$1;
  }
  if (typeof value == "object") {
    return isArray$5(value) ? baseMatchesProperty$1(value[0], value[1]) : baseMatches$1(value);
  }
  return property$1(value);
}
var _baseIteratee = baseIteratee$2;
var isArrayLike$3 = isArrayLike_1;
function createBaseEach$2(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike$3(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var _createBaseEach = createBaseEach$2;
var baseForOwn$1 = _baseForOwn, createBaseEach$1 = _createBaseEach;
var baseEach$3 = createBaseEach$1(baseForOwn$1);
var _baseEach = baseEach$3;
var baseEach$2 = _baseEach, isArrayLike$2 = isArrayLike_1;
function baseMap$2(collection, iteratee) {
  var index2 = -1, result = isArrayLike$2(collection) ? Array(collection.length) : [];
  baseEach$2(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
var _baseMap = baseMap$2;
var arrayMap$1 = _arrayMap, baseIteratee$1 = _baseIteratee, baseMap$1 = _baseMap, isArray$4 = isArray_1;
function map$1(collection, iteratee) {
  var func = isArray$4(collection) ? arrayMap$1 : baseMap$1;
  return func(collection, baseIteratee$1(iteratee));
}
var map_1 = map$1;
Object.defineProperty(flattenNames$1, "__esModule", {
  value: true
});
flattenNames$1.flattenNames = void 0;
var _isString2 = isString_1;
var _isString3 = _interopRequireDefault$7(_isString2);
var _forOwn2$2 = forOwn_1;
var _forOwn3$2 = _interopRequireDefault$7(_forOwn2$2);
var _isPlainObject2 = isPlainObject_1;
var _isPlainObject3 = _interopRequireDefault$7(_isPlainObject2);
var _map2 = map_1;
var _map3 = _interopRequireDefault$7(_map2);
function _interopRequireDefault$7(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var flattenNames = flattenNames$1.flattenNames = function flattenNames2() {
  var things = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var names2 = [];
  (0, _map3.default)(things, function(thing) {
    if (Array.isArray(thing)) {
      flattenNames2(thing).map(function(name) {
        return names2.push(name);
      });
    } else if ((0, _isPlainObject3.default)(thing)) {
      (0, _forOwn3$2.default)(thing, function(value, key) {
        value === true && names2.push(key);
        names2.push(key + "-" + value);
      });
    } else if ((0, _isString3.default)(thing)) {
      names2.push(thing);
    }
  });
  return names2;
};
flattenNames$1.default = flattenNames;
var mergeClasses$1 = {};
function arrayEach$2(array2, iteratee) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (iteratee(array2[index2], index2, array2) === false) {
      break;
    }
  }
  return array2;
}
var _arrayEach = arrayEach$2;
var getNative$1 = _getNative;
var defineProperty$4 = function() {
  try {
    var func = getNative$1(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var _defineProperty$6 = defineProperty$4;
var defineProperty$3 = _defineProperty$6;
function baseAssignValue$3(object2, key, value) {
  if (key == "__proto__" && defineProperty$3) {
    defineProperty$3(object2, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object2[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$3;
var baseAssignValue$2 = _baseAssignValue, eq$2 = eq_1;
var objectProto$h = Object.prototype;
var hasOwnProperty$f = objectProto$h.hasOwnProperty;
function assignValue$3(object2, key, value) {
  var objValue = object2[key];
  if (!(hasOwnProperty$f.call(object2, key) && eq$2(objValue, value)) || value === void 0 && !(key in object2)) {
    baseAssignValue$2(object2, key, value);
  }
}
var _assignValue = assignValue$3;
var assignValue$2 = _assignValue, baseAssignValue$1 = _baseAssignValue;
function copyObject$5(source, props, object2, customizer) {
  var isNew = !object2;
  object2 || (object2 = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue$1(object2, key, newValue);
    } else {
      assignValue$2(object2, key, newValue);
    }
  }
  return object2;
}
var _copyObject = copyObject$5;
var copyObject$4 = _copyObject, keys$2 = keys_1;
function baseAssign$1(object2, source) {
  return object2 && copyObject$4(source, keys$2(source), object2);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$2(object2) {
  var result = [];
  if (object2 != null) {
    for (var key in Object(object2)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$2;
var isObject$6 = isObject_1, isPrototype$2 = _isPrototype, nativeKeysIn$1 = _nativeKeysIn;
var objectProto$g = Object.prototype;
var hasOwnProperty$e = objectProto$g.hasOwnProperty;
function baseKeysIn$2(object2) {
  if (!isObject$6(object2)) {
    return nativeKeysIn$1(object2);
  }
  var isProto = isPrototype$2(object2), result = [];
  for (var key in object2) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$e.call(object2, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$2;
var arrayLikeKeys$1 = _arrayLikeKeys, baseKeysIn$1 = _baseKeysIn, isArrayLike$1 = isArrayLike_1;
function keysIn$4(object2) {
  return isArrayLike$1(object2) ? arrayLikeKeys$1(object2, true) : baseKeysIn$1(object2);
}
var keysIn_1 = keysIn$4;
var copyObject$3 = _copyObject, keysIn$3 = keysIn_1;
function baseAssignIn$1(object2, source) {
  return object2 && copyObject$3(source, keysIn$3(source), object2);
}
var _baseAssignIn = baseAssignIn$1;
var _cloneBuffer = { exports: {} };
(function(module2, exports2) {
  var root2 = _root;
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var Buffer2 = moduleExports2 ? root2.Buffer : void 0, allocUnsafe2 = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe2 ? allocUnsafe2(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module2.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
function copyArray$2(source, array2) {
  var index2 = -1, length = source.length;
  array2 || (array2 = Array(length));
  while (++index2 < length) {
    array2[index2] = source[index2];
  }
  return array2;
}
var _copyArray = copyArray$2;
var copyObject$2 = _copyObject, getSymbols$3 = _getSymbols;
function copySymbols$1(source, object2) {
  return copyObject$2(source, getSymbols$3(source), object2);
}
var _copySymbols = copySymbols$1;
var arrayPush$1 = _arrayPush, getPrototype$3 = _getPrototype, getSymbols$2 = _getSymbols, stubArray$1 = stubArray_1;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols$1 ? stubArray$1 : function(object2) {
  var result = [];
  while (object2) {
    arrayPush$1(result, getSymbols$2(object2));
    object2 = getPrototype$3(object2);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject$1 = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object2) {
  return copyObject$1(source, getSymbolsIn$1(source), object2);
}
var _copySymbolsIn = copySymbolsIn$1;
var baseGetAllKeys$1 = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$2 = keysIn_1;
function getAllKeysIn$1(object2) {
  return baseGetAllKeys$1(object2, keysIn$2, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$1;
var objectProto$f = Object.prototype;
var hasOwnProperty$d = objectProto$f.hasOwnProperty;
function initCloneArray$1(array2) {
  var length = array2.length, result = new array2.constructor(length);
  if (length && typeof array2[0] == "string" && hasOwnProperty$d.call(array2, "index")) {
    result.index = array2.index;
    result.input = array2.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var Uint8Array$3 = _Uint8Array;
function cloneArrayBuffer$4(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$3(result).set(new Uint8Array$3(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$4;
var cloneArrayBuffer$3 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$3(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$3 = _Symbol;
var symbolProto$2 = Symbol$3 ? Symbol$3.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneTypedArray$2(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$2;
var cloneArrayBuffer$1 = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray$1 = _cloneTypedArray;
var boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", symbolTag$3 = "[object Symbol]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
function initCloneByTag$1(object2, tag, isDeep) {
  var Ctor = object2.constructor;
  switch (tag) {
    case arrayBufferTag$3:
      return cloneArrayBuffer$1(object2);
    case boolTag$3:
    case dateTag$3:
      return new Ctor(+object2);
    case dataViewTag$4:
      return cloneDataView(object2, isDeep);
    case float32Tag$2:
    case float64Tag$2:
    case int8Tag$2:
    case int16Tag$2:
    case int32Tag$2:
    case uint8Tag$2:
    case uint8ClampedTag$2:
    case uint16Tag$2:
    case uint32Tag$2:
      return cloneTypedArray$1(object2, isDeep);
    case mapTag$5:
      return new Ctor();
    case numberTag$3:
    case stringTag$3:
      return new Ctor(object2);
    case regexpTag$3:
      return cloneRegExp(object2);
    case setTag$5:
      return new Ctor();
    case symbolTag$3:
      return cloneSymbol(object2);
  }
}
var _initCloneByTag = initCloneByTag$1;
var isObject$5 = isObject_1;
var objectCreate$1 = Object.create;
var baseCreate$3 = function() {
  function object2() {
  }
  return function(proto2) {
    if (!isObject$5(proto2)) {
      return {};
    }
    if (objectCreate$1) {
      return objectCreate$1(proto2);
    }
    object2.prototype = proto2;
    var result = new object2();
    object2.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$3;
var baseCreate$2 = _baseCreate, getPrototype$2 = _getPrototype, isPrototype$1 = _isPrototype;
function initCloneObject$2(object2) {
  return typeof object2.constructor == "function" && !isPrototype$1(object2) ? baseCreate$2(getPrototype$2(object2)) : {};
}
var _initCloneObject = initCloneObject$2;
var getTag$4 = _getTag, isObjectLike$2 = isObjectLike_1;
var mapTag$4 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$2(value) && getTag$4(value) == mapTag$4;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap, baseUnary$2 = _baseUnary, nodeUtil$3 = _nodeUtil.exports;
var nodeIsMap = nodeUtil$3 && nodeUtil$3.isMap;
var isMap$1 = nodeIsMap ? baseUnary$2(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$3 = _getTag, isObjectLike$1 = isObjectLike_1;
var setTag$4 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike$1(value) && getTag$3(value) == setTag$4;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet, baseUnary$1 = _baseUnary, nodeUtil$2 = _nodeUtil.exports;
var nodeIsSet = nodeUtil$2 && nodeUtil$2.isSet;
var isSet$1 = nodeIsSet ? baseUnary$1(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack$1 = _Stack, arrayEach$1 = _arrayEach, assignValue$1 = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer$1 = _cloneBuffer.exports, copyArray$1 = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys$1 = _getAllKeys, getAllKeysIn = _getAllKeysIn, getTag$2 = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject$1 = _initCloneObject, isArray$3 = isArray_1, isBuffer$3 = isBuffer$6.exports, isMap = isMap_1, isObject$4 = isObject_1, isSet = isSet_1, keys$1 = keys_1, keysIn$1 = keysIn_1;
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag$3 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$2 = "[object Error]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag$3] = cloneableTags[arrayTag$2] = cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] = cloneableTags[boolTag$2] = cloneableTags[dateTag$2] = cloneableTags[float32Tag$1] = cloneableTags[float64Tag$1] = cloneableTags[int8Tag$1] = cloneableTags[int16Tag$1] = cloneableTags[int32Tag$1] = cloneableTags[mapTag$3] = cloneableTags[numberTag$2] = cloneableTags[objectTag$4] = cloneableTags[regexpTag$2] = cloneableTags[setTag$3] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$2] = cloneableTags[uint8Tag$1] = cloneableTags[uint8ClampedTag$1] = cloneableTags[uint16Tag$1] = cloneableTags[uint32Tag$1] = true;
cloneableTags[errorTag$2] = cloneableTags[funcTag$2] = cloneableTags[weakMapTag$2] = false;
function baseClone$1(value, bitmask, customizer, key, object2, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result = object2 ? customizer(value, key, object2, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$4(value)) {
    return value;
  }
  var isArr = isArray$3(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray$1(value, result);
    }
  } else {
    var tag = getTag$2(value), isFunc = tag == funcTag$2 || tag == genTag$1;
    if (isBuffer$3(value)) {
      return cloneBuffer$1(value, isDeep);
    }
    if (tag == objectTag$4 || tag == argsTag$3 || isFunc && !object2) {
      result = isFlat || isFunc ? {} : initCloneObject$1(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object2 ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack$1());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$1(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone$1(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys$1 : isFlat ? keysIn$1 : keys$1;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach$1(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue$1(result, key2, baseClone$1(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone = baseClone$1;
var baseClone = _baseClone;
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
var cloneDeep_1 = cloneDeep;
Object.defineProperty(mergeClasses$1, "__esModule", {
  value: true
});
mergeClasses$1.mergeClasses = void 0;
var _forOwn2$1 = forOwn_1;
var _forOwn3$1 = _interopRequireDefault$6(_forOwn2$1);
var _cloneDeep2 = cloneDeep_1;
var _cloneDeep3 = _interopRequireDefault$6(_cloneDeep2);
var _extends$g = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
function _interopRequireDefault$6(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var mergeClasses = mergeClasses$1.mergeClasses = function mergeClasses2(classes) {
  var activeNames = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var styles = classes.default && (0, _cloneDeep3.default)(classes.default) || {};
  activeNames.map(function(name) {
    var toMerge = classes[name];
    if (toMerge) {
      (0, _forOwn3$1.default)(toMerge, function(value, key) {
        if (!styles[key]) {
          styles[key] = {};
        }
        styles[key] = _extends$g({}, styles[key], toMerge[key]);
      });
    }
    return name;
  });
  return styles;
};
mergeClasses$1.default = mergeClasses;
var autoprefix$1 = {};
Object.defineProperty(autoprefix$1, "__esModule", {
  value: true
});
autoprefix$1.autoprefix = void 0;
var _forOwn2 = forOwn_1;
var _forOwn3 = _interopRequireDefault$5(_forOwn2);
var _extends$f = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
function _interopRequireDefault$5(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var transforms = {
  borderRadius: function borderRadius(value) {
    return {
      msBorderRadius: value,
      MozBorderRadius: value,
      OBorderRadius: value,
      WebkitBorderRadius: value,
      borderRadius: value
    };
  },
  boxShadow: function boxShadow(value) {
    return {
      msBoxShadow: value,
      MozBoxShadow: value,
      OBoxShadow: value,
      WebkitBoxShadow: value,
      boxShadow: value
    };
  },
  userSelect: function userSelect(value) {
    return {
      WebkitTouchCallout: value,
      KhtmlUserSelect: value,
      MozUserSelect: value,
      msUserSelect: value,
      WebkitUserSelect: value,
      userSelect: value
    };
  },
  flex: function flex(value) {
    return {
      WebkitBoxFlex: value,
      MozBoxFlex: value,
      WebkitFlex: value,
      msFlex: value,
      flex: value
    };
  },
  flexBasis: function flexBasis(value) {
    return {
      WebkitFlexBasis: value,
      flexBasis: value
    };
  },
  justifyContent: function justifyContent(value) {
    return {
      WebkitJustifyContent: value,
      justifyContent: value
    };
  },
  transition: function transition(value) {
    return {
      msTransition: value,
      MozTransition: value,
      OTransition: value,
      WebkitTransition: value,
      transition: value
    };
  },
  transform: function transform(value) {
    return {
      msTransform: value,
      MozTransform: value,
      OTransform: value,
      WebkitTransform: value,
      transform: value
    };
  },
  absolute: function absolute(value) {
    var direction = value && value.split(" ");
    return {
      position: "absolute",
      top: direction && direction[0],
      right: direction && direction[1],
      bottom: direction && direction[2],
      left: direction && direction[3]
    };
  },
  extend: function extend(name, otherElementStyles) {
    var otherStyle = otherElementStyles[name];
    if (otherStyle) {
      return otherStyle;
    }
    return {
      "extend": name
    };
  }
};
var autoprefix = autoprefix$1.autoprefix = function autoprefix2(elements) {
  var prefixed = {};
  (0, _forOwn3.default)(elements, function(styles, element) {
    var expanded = {};
    (0, _forOwn3.default)(styles, function(value, key) {
      var transform2 = transforms[key];
      if (transform2) {
        expanded = _extends$f({}, expanded, transform2(value));
      } else {
        expanded[key] = value;
      }
    });
    prefixed[element] = expanded;
  });
  return prefixed;
};
autoprefix$1.default = autoprefix;
var hover$1 = {};
Object.defineProperty(hover$1, "__esModule", {
  value: true
});
hover$1.hover = void 0;
var _extends$e = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _react$3 = React__default;
var _react2$3 = _interopRequireDefault$4(_react$3);
function _interopRequireDefault$4(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _classCallCheck$9(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$9(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$9(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var hover = hover$1.hover = function hover2(Component2) {
  var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
  return function(_React$Component) {
    _inherits$9(Hover, _React$Component);
    function Hover() {
      var _ref;
      var _temp, _this, _ret;
      _classCallCheck$9(this, Hover);
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _ret = (_temp = (_this = _possibleConstructorReturn$9(this, (_ref = Hover.__proto__ || Object.getPrototypeOf(Hover)).call.apply(_ref, [this].concat(args))), _this), _this.state = { hover: false }, _this.handleMouseOver = function() {
        return _this.setState({ hover: true });
      }, _this.handleMouseOut = function() {
        return _this.setState({ hover: false });
      }, _this.render = function() {
        return _react2$3.default.createElement(
          Span,
          { onMouseOver: _this.handleMouseOver, onMouseOut: _this.handleMouseOut },
          _react2$3.default.createElement(Component2, _extends$e({}, _this.props, _this.state))
        );
      }, _temp), _possibleConstructorReturn$9(_this, _ret);
    }
    return Hover;
  }(_react2$3.default.Component);
};
hover$1.default = hover;
var active$1 = {};
Object.defineProperty(active$1, "__esModule", {
  value: true
});
active$1.active = void 0;
var _extends$d = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _react$2 = React__default;
var _react2$2 = _interopRequireDefault$3(_react$2);
function _interopRequireDefault$3(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _classCallCheck$8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$8(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var active = active$1.active = function active2(Component2) {
  var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
  return function(_React$Component) {
    _inherits$8(Active, _React$Component);
    function Active() {
      var _ref;
      var _temp, _this, _ret;
      _classCallCheck$8(this, Active);
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _ret = (_temp = (_this = _possibleConstructorReturn$8(this, (_ref = Active.__proto__ || Object.getPrototypeOf(Active)).call.apply(_ref, [this].concat(args))), _this), _this.state = { active: false }, _this.handleMouseDown = function() {
        return _this.setState({ active: true });
      }, _this.handleMouseUp = function() {
        return _this.setState({ active: false });
      }, _this.render = function() {
        return _react2$2.default.createElement(
          Span,
          { onMouseDown: _this.handleMouseDown, onMouseUp: _this.handleMouseUp },
          _react2$2.default.createElement(Component2, _extends$d({}, _this.props, _this.state))
        );
      }, _temp), _possibleConstructorReturn$8(_this, _ret);
    }
    return Active;
  }(_react2$2.default.Component);
};
active$1.default = active;
var loop = {};
Object.defineProperty(loop, "__esModule", {
  value: true
});
var loopable = function loopable2(i, length) {
  var props = {};
  var setProp = function setProp2(name) {
    var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    props[name] = value;
  };
  i === 0 && setProp("first-child");
  i === length - 1 && setProp("last-child");
  (i === 0 || i % 2 === 0) && setProp("even");
  Math.abs(i % 2) === 1 && setProp("odd");
  setProp("nth-child", i);
  return props;
};
loop.default = loopable;
Object.defineProperty(lib, "__esModule", {
  value: true
});
lib.ReactCSS = lib.loop = lib.handleActive = handleHover = lib.handleHover = lib.hover = void 0;
var _flattenNames = flattenNames$1;
var _flattenNames2 = _interopRequireDefault$2(_flattenNames);
var _mergeClasses = mergeClasses$1;
var _mergeClasses2 = _interopRequireDefault$2(_mergeClasses);
var _autoprefix = autoprefix$1;
var _autoprefix2 = _interopRequireDefault$2(_autoprefix);
var _hover2 = hover$1;
var _hover3 = _interopRequireDefault$2(_hover2);
var _active = active$1;
var _active2 = _interopRequireDefault$2(_active);
var _loop2 = loop;
var _loop3 = _interopRequireDefault$2(_loop2);
function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
lib.hover = _hover3.default;
var handleHover = lib.handleHover = _hover3.default;
lib.handleActive = _active2.default;
lib.loop = _loop3.default;
var ReactCSS = lib.ReactCSS = function ReactCSS2(classes) {
  for (var _len = arguments.length, activations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    activations[_key - 1] = arguments[_key];
  }
  var activeNames = (0, _flattenNames2.default)(activations);
  var merged = (0, _mergeClasses2.default)(classes, activeNames);
  return (0, _autoprefix2.default)(merged);
};
var _default$2 = lib.default = ReactCSS;
var calculateChange$2 = function calculateChange(e, hsl, direction, initialA, container) {
  var containerWidth = container.clientWidth;
  var containerHeight = container.clientHeight;
  var x = typeof e.pageX === "number" ? e.pageX : e.touches[0].pageX;
  var y = typeof e.pageY === "number" ? e.pageY : e.touches[0].pageY;
  var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container.getBoundingClientRect().top + window.pageYOffset);
  if (direction === "vertical") {
    var a = void 0;
    if (top < 0) {
      a = 0;
    } else if (top > containerHeight) {
      a = 1;
    } else {
      a = Math.round(top * 100 / containerHeight) / 100;
    }
    if (hsl.a !== a) {
      return {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a,
        source: "rgb"
      };
    }
  } else {
    var _a2 = void 0;
    if (left < 0) {
      _a2 = 0;
    } else if (left > containerWidth) {
      _a2 = 1;
    } else {
      _a2 = Math.round(left * 100 / containerWidth) / 100;
    }
    if (initialA !== _a2) {
      return {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: _a2,
        source: "rgb"
      };
    }
  }
  return null;
};
var checkboardCache = {};
var render = function render2(c1, c2, size2, serverCanvas) {
  if (typeof document === "undefined" && !serverCanvas) {
    return null;
  }
  var canvas = serverCanvas ? new serverCanvas() : document.createElement("canvas");
  canvas.width = size2 * 2;
  canvas.height = size2 * 2;
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return null;
  }
  ctx.fillStyle = c1;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = c2;
  ctx.fillRect(0, 0, size2, size2);
  ctx.translate(size2, size2);
  ctx.fillRect(0, 0, size2, size2);
  return canvas.toDataURL();
};
var get$2 = function get(c1, c2, size2, serverCanvas) {
  var key = c1 + "-" + c2 + "-" + size2 + (serverCanvas ? "-server" : "");
  if (checkboardCache[key]) {
    return checkboardCache[key];
  }
  var checkboard = render(c1, c2, size2, serverCanvas);
  checkboardCache[key] = checkboard;
  return checkboard;
};
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f = React__default, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m$1 = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
function q(c, a, g) {
  var b, d = {}, e = null, h = null;
  void 0 !== g && (e = "" + g);
  void 0 !== a.key && (e = "" + a.key);
  void 0 !== a.ref && (h = a.ref);
  for (b in a)
    m$1.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
  if (c && c.defaultProps)
    for (b in a = c.defaultProps, a)
      void 0 === d[b] && (d[b] = a[b]);
  return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
}
reactJsxRuntime_production_min.Fragment = l;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
const jsx = jsxRuntime.exports.jsx;
const jsxs = jsxRuntime.exports.jsxs;
const Fragment = jsxRuntime.exports.Fragment;
var _extends$c = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var Checkboard = function Checkboard2(_ref) {
  var white = _ref.white, grey = _ref.grey, size2 = _ref.size, renderers = _ref.renderers, borderRadius2 = _ref.borderRadius, boxShadow2 = _ref.boxShadow, children = _ref.children;
  var styles = _default$2({
    "default": {
      grid: {
        borderRadius: borderRadius2,
        boxShadow: boxShadow2,
        absolute: "0px 0px 0px 0px",
        background: "url(" + get$2(white, grey, size2, renderers.canvas) + ") center left"
      }
    }
  });
  return isValidElement(children) ? React__default.cloneElement(children, _extends$c({}, children.props, {
    style: _extends$c({}, children.props.style, styles.grid)
  })) : /* @__PURE__ */ jsx("div", {
    style: styles.grid
  });
};
Checkboard.defaultProps = {
  size: 8,
  white: "transparent",
  grey: "rgba(0,0,0,.08)",
  renderers: {}
};
var _extends$b = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass$8 = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$7(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Alpha = function(_ref) {
  _inherits$7(Alpha2, _ref);
  function Alpha2() {
    var _ref2;
    var _temp, _this, _ret;
    _classCallCheck$7(this, Alpha2);
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _ret = (_temp = (_this = _possibleConstructorReturn$7(this, (_ref2 = Alpha2.__proto__ || Object.getPrototypeOf(Alpha2)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function(e) {
      var change = calculateChange$2(e, _this.props.hsl, _this.props.direction, _this.props.a, _this.container);
      change && typeof _this.props.onChange === "function" && _this.props.onChange(change, e);
    }, _this.handleMouseDown = function(e) {
      _this.handleChange(e);
      window.addEventListener("mousemove", _this.handleChange);
      window.addEventListener("mouseup", _this.handleMouseUp);
    }, _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    }, _this.unbindEventListeners = function() {
      window.removeEventListener("mousemove", _this.handleChange);
      window.removeEventListener("mouseup", _this.handleMouseUp);
    }, _temp), _possibleConstructorReturn$7(_this, _ret);
  }
  _createClass$8(Alpha2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var rgb = this.props.rgb;
      var styles = _default$2({
        "default": {
          alpha: {
            absolute: "0px 0px 0px 0px",
            borderRadius: this.props.radius
          },
          checkboard: {
            absolute: "0px 0px 0px 0px",
            overflow: "hidden",
            borderRadius: this.props.radius
          },
          gradient: {
            absolute: "0px 0px 0px 0px",
            background: "linear-gradient(to right, rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 0) 0%,\n           rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 1) 100%)",
            boxShadow: this.props.shadow,
            borderRadius: this.props.radius
          },
          container: {
            position: "relative",
            height: "100%",
            margin: "0 3px"
          },
          pointer: {
            position: "absolute",
            left: rgb.a * 100 + "%"
          },
          slider: {
            width: "4px",
            borderRadius: "1px",
            height: "8px",
            boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
            background: "#fff",
            marginTop: "1px",
            transform: "translateX(-2px)"
          }
        },
        "vertical": {
          gradient: {
            background: "linear-gradient(to bottom, rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 0) 0%,\n           rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 1) 100%)"
          },
          pointer: {
            left: 0,
            top: rgb.a * 100 + "%"
          }
        },
        "overwrite": _extends$b({}, this.props.style)
      }, {
        vertical: this.props.direction === "vertical",
        overwrite: true
      });
      return /* @__PURE__ */ jsxs("div", {
        style: styles.alpha,
        children: [/* @__PURE__ */ jsx("div", {
          style: styles.checkboard,
          children: /* @__PURE__ */ jsx(Checkboard, {
            renderers: this.props.renderers
          })
        }), /* @__PURE__ */ jsx("div", {
          style: styles.gradient
        }), /* @__PURE__ */ jsx("div", {
          style: styles.container,
          ref: function ref(container) {
            return _this2.container = container;
          },
          onMouseDown: this.handleMouseDown,
          onTouchMove: this.handleChange,
          onTouchStart: this.handleChange,
          children: /* @__PURE__ */ jsx("div", {
            style: styles.pointer,
            children: this.props.pointer ? React__default.createElement(this.props.pointer, this.props) : /* @__PURE__ */ jsx("div", {
              style: styles.slider
            })
          })
        })]
      });
    }
  }]);
  return Alpha2;
}(PureComponent || Component);
var _createClass$7 = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _defineProperty$5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$6(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var DEFAULT_ARROW_OFFSET = 1;
var UP_KEY_CODE = 38;
var DOWN_KEY_CODE = 40;
var VALID_KEY_CODES = [UP_KEY_CODE, DOWN_KEY_CODE];
var isValidKeyCode = function isValidKeyCode2(keyCode) {
  return VALID_KEY_CODES.indexOf(keyCode) > -1;
};
var getNumberValue = function getNumberValue2(value) {
  return Number(String(value).replace(/%/g, ""));
};
var idCounter = 1;
var EditableInput = function(_ref) {
  _inherits$6(EditableInput2, _ref);
  function EditableInput2(props) {
    _classCallCheck$6(this, EditableInput2);
    var _this = _possibleConstructorReturn$6(this, (EditableInput2.__proto__ || Object.getPrototypeOf(EditableInput2)).call(this));
    _this.handleBlur = function() {
      if (_this.state.blurValue) {
        _this.setState({
          value: _this.state.blurValue,
          blurValue: null
        });
      }
    };
    _this.handleChange = function(e) {
      _this.setUpdatedValue(e.target.value, e);
    };
    _this.handleKeyDown = function(e) {
      var value = getNumberValue(e.target.value);
      if (!isNaN(value) && isValidKeyCode(e.keyCode)) {
        var offset2 = _this.getArrowOffset();
        var updatedValue = e.keyCode === UP_KEY_CODE ? value + offset2 : value - offset2;
        _this.setUpdatedValue(updatedValue, e);
      }
    };
    _this.handleDrag = function(e) {
      if (_this.props.dragLabel) {
        var newValue = Math.round(_this.props.value + e.movementX);
        if (newValue >= 0 && newValue <= _this.props.dragMax) {
          _this.props.onChange && _this.props.onChange(_this.getValueObjectWithLabel(newValue), e);
        }
      }
    };
    _this.handleMouseDown = function(e) {
      if (_this.props.dragLabel) {
        e.preventDefault();
        _this.handleDrag(e);
        window.addEventListener("mousemove", _this.handleDrag);
        window.addEventListener("mouseup", _this.handleMouseUp);
      }
    };
    _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    };
    _this.unbindEventListeners = function() {
      window.removeEventListener("mousemove", _this.handleDrag);
      window.removeEventListener("mouseup", _this.handleMouseUp);
    };
    _this.state = {
      value: String(props.value).toUpperCase(),
      blurValue: String(props.value).toUpperCase()
    };
    _this.inputId = "rc-editable-input-" + idCounter++;
    return _this;
  }
  _createClass$7(EditableInput2, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.props.value !== this.state.value && (prevProps.value !== this.props.value || prevState.value !== this.state.value)) {
        if (this.input === document.activeElement) {
          this.setState({
            blurValue: String(this.props.value).toUpperCase()
          });
        } else {
          this.setState({
            value: String(this.props.value).toUpperCase(),
            blurValue: !this.state.blurValue && String(this.props.value).toUpperCase()
          });
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: "getValueObjectWithLabel",
    value: function getValueObjectWithLabel(value) {
      return _defineProperty$5({}, this.props.label, value);
    }
  }, {
    key: "getArrowOffset",
    value: function getArrowOffset() {
      return this.props.arrowOffset || DEFAULT_ARROW_OFFSET;
    }
  }, {
    key: "setUpdatedValue",
    value: function setUpdatedValue(value, e) {
      var onChangeValue = this.props.label ? this.getValueObjectWithLabel(value) : value;
      this.props.onChange && this.props.onChange(onChangeValue, e);
      this.setState({
        value
      });
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var styles = _default$2({
        "default": {
          wrap: {
            position: "relative"
          }
        },
        "user-override": {
          wrap: this.props.style && this.props.style.wrap ? this.props.style.wrap : {},
          input: this.props.style && this.props.style.input ? this.props.style.input : {},
          label: this.props.style && this.props.style.label ? this.props.style.label : {}
        },
        "dragLabel-true": {
          label: {
            cursor: "ew-resize"
          }
        }
      }, {
        "user-override": true
      }, this.props);
      return /* @__PURE__ */ jsxs("div", {
        style: styles.wrap,
        children: [/* @__PURE__ */ jsx("input", {
          id: this.inputId,
          style: styles.input,
          ref: function ref(input) {
            return _this2.input = input;
          },
          value: this.state.value,
          onKeyDown: this.handleKeyDown,
          onChange: this.handleChange,
          onBlur: this.handleBlur,
          placeholder: this.props.placeholder,
          spellCheck: "false"
        }), this.props.label && !this.props.hideLabel ? /* @__PURE__ */ jsx("label", {
          htmlFor: this.inputId,
          style: styles.label,
          onMouseDown: this.handleMouseDown,
          children: this.props.label
        }) : null]
      });
    }
  }]);
  return EditableInput2;
}(PureComponent || Component);
var calculateChange$1 = function calculateChange2(e, direction, hsl, container) {
  var containerWidth = container.clientWidth;
  var containerHeight = container.clientHeight;
  var x = typeof e.pageX === "number" ? e.pageX : e.touches[0].pageX;
  var y = typeof e.pageY === "number" ? e.pageY : e.touches[0].pageY;
  var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container.getBoundingClientRect().top + window.pageYOffset);
  if (direction === "vertical") {
    var h = void 0;
    if (top < 0) {
      h = 359;
    } else if (top > containerHeight) {
      h = 0;
    } else {
      var percent = -(top * 100 / containerHeight) + 100;
      h = 360 * percent / 100;
    }
    if (hsl.h !== h) {
      return {
        h,
        s: hsl.s,
        l: hsl.l,
        a: hsl.a,
        source: "hsl"
      };
    }
  } else {
    var _h = void 0;
    if (left < 0) {
      _h = 0;
    } else if (left > containerWidth) {
      _h = 359;
    } else {
      var _percent = left * 100 / containerWidth;
      _h = 360 * _percent / 100;
    }
    if (hsl.h !== _h) {
      return {
        h: _h,
        s: hsl.s,
        l: hsl.l,
        a: hsl.a,
        source: "hsl"
      };
    }
  }
  return null;
};
var _createClass$6 = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$5(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Hue = function(_ref) {
  _inherits$5(Hue2, _ref);
  function Hue2() {
    var _ref2;
    var _temp, _this, _ret;
    _classCallCheck$5(this, Hue2);
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _ret = (_temp = (_this = _possibleConstructorReturn$5(this, (_ref2 = Hue2.__proto__ || Object.getPrototypeOf(Hue2)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function(e) {
      var change = calculateChange$1(e, _this.props.direction, _this.props.hsl, _this.container);
      change && typeof _this.props.onChange === "function" && _this.props.onChange(change, e);
    }, _this.handleMouseDown = function(e) {
      _this.handleChange(e);
      window.addEventListener("mousemove", _this.handleChange);
      window.addEventListener("mouseup", _this.handleMouseUp);
    }, _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    }, _temp), _possibleConstructorReturn$5(_this, _ret);
  }
  _createClass$6(Hue2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: "unbindEventListeners",
    value: function unbindEventListeners() {
      window.removeEventListener("mousemove", this.handleChange);
      window.removeEventListener("mouseup", this.handleMouseUp);
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var _props$direction = this.props.direction, direction = _props$direction === void 0 ? "horizontal" : _props$direction;
      var styles = _default$2({
        "default": {
          hue: {
            absolute: "0px 0px 0px 0px",
            borderRadius: this.props.radius,
            boxShadow: this.props.shadow
          },
          container: {
            padding: "0 2px",
            position: "relative",
            height: "100%",
            borderRadius: this.props.radius
          },
          pointer: {
            position: "absolute",
            left: this.props.hsl.h * 100 / 360 + "%"
          },
          slider: {
            marginTop: "1px",
            width: "4px",
            borderRadius: "1px",
            height: "8px",
            boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
            background: "#fff",
            transform: "translateX(-2px)"
          }
        },
        "vertical": {
          pointer: {
            left: "0px",
            top: -(this.props.hsl.h * 100 / 360) + 100 + "%"
          }
        }
      }, {
        vertical: direction === "vertical"
      });
      return /* @__PURE__ */ jsx("div", {
        style: styles.hue,
        children: /* @__PURE__ */ jsxs("div", {
          className: "hue-" + direction,
          style: styles.container,
          ref: function ref(container) {
            return _this2.container = container;
          },
          onMouseDown: this.handleMouseDown,
          onTouchMove: this.handleChange,
          onTouchStart: this.handleChange,
          children: [/* @__PURE__ */ jsx("style", {
            children: ".hue-horizontal { background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%); background: -webkit-linear-gradient(to right, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%); } .hue-vertical { background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%); background: -webkit-linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%); }"
          }), /* @__PURE__ */ jsx("div", {
            style: styles.pointer,
            children: this.props.pointer ? React__default.createElement(this.props.pointer, this.props) : /* @__PURE__ */ jsx("div", {
              style: styles.slider
            })
          })]
        })
      });
    }
  }]);
  return Hue2;
}(PureComponent || Component);
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims();
}
var PropTypes = propTypes.exports;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function eq$1(value, other) {
  return value === other || value !== value && other !== other;
}
function assocIndexOf(array2, key) {
  var length = array2.length;
  while (length--) {
    if (eq$1(array2[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
var root$1 = root;
var Symbol$1 = root$1.Symbol;
var Symbol$2 = Symbol$1;
var objectProto$e = Object.prototype;
var hasOwnProperty$c = objectProto$e.hasOwnProperty;
var nativeObjectToString$1 = objectProto$e.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$c.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$d = Object.prototype;
var nativeObjectToString = objectProto$d.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObject$3(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$2(value) {
  if (!isObject$3(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
var coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$c = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$b = objectProto$c.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject$3(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
function getNative(object2, key) {
  var value = getValue(object2, key);
  return baseIsNative(value) ? value : void 0;
}
var Map$1 = getNative(root$1, "Map");
var Map$2 = Map$1;
var nativeCreate = getNative(Object, "create");
var nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$b = Object.prototype;
var hasOwnProperty$a = objectProto$b.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$a.call(data, key) ? data[key] : void 0;
}
var objectProto$a = Object.prototype;
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$9.call(data, key);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map3, key) {
  var data = map3.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data = getMapData(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var defineProperty$1 = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty$2 = defineProperty$1;
function baseAssignValue(object2, key, value) {
  if (key == "__proto__" && defineProperty$2) {
    defineProperty$2(object2, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object2[key] = value;
  }
}
function assignMergeValue(object2, key, value) {
  if (value !== void 0 && !eq$1(object2[key], value) || value === void 0 && !(key in object2)) {
    baseAssignValue(object2, key, value);
  }
}
function createBaseFor(fromRight) {
  return function(object2, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object2;
  };
}
var baseFor = createBaseFor();
var baseFor$1 = baseFor;
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$2 = moduleExports$2 ? root$1.Buffer : void 0, allocUnsafe = Buffer$2 ? Buffer$2.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
var Uint8Array$1 = root$1.Uint8Array;
var Uint8Array$2 = Uint8Array$1;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
function copyArray(source, array2) {
  var index2 = -1, length = source.length;
  array2 || (array2 = Array(length));
  while (++index2 < length) {
    array2[index2] = source[index2];
  }
  return array2;
}
var objectCreate = Object.create;
var baseCreate = function() {
  function object2() {
  }
  return function(proto2) {
    if (!isObject$3(proto2)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto2);
    }
    object2.prototype = proto2;
    var result = new object2();
    object2.prototype = void 0;
    return result;
  };
}();
var baseCreate$1 = baseCreate;
function overArg(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
var getPrototype$1 = getPrototype;
var objectProto$9 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$9;
  return value === proto2;
}
function initCloneObject(object2) {
  return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate$1(getPrototype$1(object2)) : {};
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}
var objectProto$8 = Object.prototype;
var hasOwnProperty$8 = objectProto$8.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments$1 = isArguments;
var isArray$1 = Array.isArray;
var isArray$2 = isArray$1;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction$2(value);
}
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
function stubFalse() {
  return false;
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var Buffer$1 = moduleExports$1 ? root$1.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer$1 = nativeIsBuffer || stubFalse;
var isBuffer$2 = isBuffer$1;
var objectTag$3 = "[object Object]";
var funcProto = Function.prototype, objectProto$7 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$3(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
    return false;
  }
  var proto2 = getPrototype$1(value);
  if (proto2 === null) {
    return true;
  }
  var Ctor = hasOwnProperty$7.call(proto2, "constructor") && proto2.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types = freeModule && freeModule.require && freeModule.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray$2 = isTypedArray$1;
function safeGet(object2, key) {
  if (key === "constructor" && typeof object2[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object2[key];
}
var objectProto$6 = Object.prototype;
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
function assignValue(object2, key, value) {
  var objValue = object2[key];
  if (!(hasOwnProperty$6.call(object2, key) && eq$1(objValue, value)) || value === void 0 && !(key in object2)) {
    baseAssignValue(object2, key, value);
  }
}
function copyObject(source, props, object2, customizer) {
  var isNew = !object2;
  object2 || (object2 = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object2, key, newValue);
    } else {
      assignValue(object2, key, newValue);
    }
  }
  return object2;
}
function baseTimes(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$2(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$5.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
function nativeKeysIn(object2) {
  var result = [];
  if (object2 != null) {
    for (var key in Object(object2)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function baseKeysIn(object2) {
  if (!isObject$3(object2)) {
    return nativeKeysIn(object2);
  }
  var isProto = isPrototype(object2), result = [];
  for (var key in object2) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$4.call(object2, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object2) {
  return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
}
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}
function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue(object2, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$2(srcValue), isBuff = !isArr && isBuffer$2(srcValue), isTyped = !isArr && !isBuff && isTypedArray$2(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$2(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject$3(srcValue) || isArguments$1(srcValue)) {
      newValue = objValue;
      if (isArguments$1(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$3(objValue) || isFunction$2(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue(object2, key, newValue);
}
function baseMerge(object2, source, srcIndex, customizer, stack) {
  if (object2 === source) {
    return;
  }
  baseFor$1(source, function(srcValue, key) {
    stack || (stack = new Stack());
    if (isObject$3(srcValue)) {
      baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object2, key, newValue);
    }
  }, keysIn);
}
function identity(value) {
  return value;
}
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var nativeMax$1 = Math.max;
function overRest(func, start, transform2) {
  start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax$1(args.length - start, 0), array2 = Array(length);
    while (++index2 < length) {
      array2[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = transform2(array2);
    return apply(func, this, otherArgs);
  };
}
function constant(value) {
  return function() {
    return value;
  };
}
var baseSetToString = !defineProperty$2 ? identity : function(func, string) {
  return defineProperty$2(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var baseSetToString$1 = baseSetToString;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var setToString = shortOut(baseSetToString$1);
var setToString$1 = setToString;
function baseRest(func, start) {
  return setToString$1(overRest(func, start, identity), func + "");
}
function isIterateeCall(value, index2, object2) {
  if (!isObject$3(object2)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike(object2) && isIndex(index2, object2.length) : type == "string" && index2 in object2) {
    return eq$1(object2[index2], value);
  }
  return false;
}
function createAssigner(assigner) {
  return baseRest(function(object2, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object2 = Object(object2);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object2, source, index2, customizer);
      }
    }
    return object2;
  });
}
var merge$1 = createAssigner(function(object2, source, srcIndex) {
  baseMerge(object2, source, srcIndex);
});
var merge$2 = merge$1;
var Raised = function Raised2(_ref) {
  var zDepth = _ref.zDepth, radius = _ref.radius, background = _ref.background, children = _ref.children, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles;
  var styles = _default$2(merge$2({
    "default": {
      wrap: {
        position: "relative",
        display: "inline-block"
      },
      content: {
        position: "relative"
      },
      bg: {
        absolute: "0px 0px 0px 0px",
        boxShadow: "0 " + zDepth + "px " + zDepth * 4 + "px rgba(0,0,0,.24)",
        borderRadius: radius,
        background
      }
    },
    "zDepth-0": {
      bg: {
        boxShadow: "none"
      }
    },
    "zDepth-1": {
      bg: {
        boxShadow: "0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16)"
      }
    },
    "zDepth-2": {
      bg: {
        boxShadow: "0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2)"
      }
    },
    "zDepth-3": {
      bg: {
        boxShadow: "0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24)"
      }
    },
    "zDepth-4": {
      bg: {
        boxShadow: "0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22)"
      }
    },
    "zDepth-5": {
      bg: {
        boxShadow: "0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2)"
      }
    },
    "square": {
      bg: {
        borderRadius: "0"
      }
    },
    "circle": {
      bg: {
        borderRadius: "50%"
      }
    }
  }, passedStyles), { "zDepth-1": zDepth === 1 });
  return React__default.createElement(
    "div",
    { style: styles.wrap },
    React__default.createElement("div", { style: styles.bg }),
    React__default.createElement(
      "div",
      { style: styles.content },
      children
    )
  );
};
Raised.propTypes = {
  background: PropTypes.string,
  zDepth: PropTypes.oneOf([0, 1, 2, 3, 4, 5]),
  radius: PropTypes.number,
  styles: PropTypes.object
};
Raised.defaultProps = {
  background: "#fff",
  zDepth: 1,
  radius: 2,
  styles: {}
};
var now = function() {
  return root$1.Date.now();
};
var now$1 = now;
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var symbolTag$1 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
}
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$3(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$3(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var FUNC_ERROR_TEXT$2 = "Expected a function";
var nativeMax = Math.max, nativeMin = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  wait = toNumber(wait) || 0;
  if (isObject$3(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now$1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$1());
  }
  function debounced() {
    var time = now$1(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var FUNC_ERROR_TEXT$1 = "Expected a function";
function throttle$1(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  if (isObject$3(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var calculateChange3 = function calculateChange4(e, hsl, container) {
  var _container$getBoundin = container.getBoundingClientRect(), containerWidth = _container$getBoundin.width, containerHeight = _container$getBoundin.height;
  var x = typeof e.pageX === "number" ? e.pageX : e.touches[0].pageX;
  var y = typeof e.pageY === "number" ? e.pageY : e.touches[0].pageY;
  var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container.getBoundingClientRect().top + window.pageYOffset);
  if (left < 0) {
    left = 0;
  } else if (left > containerWidth) {
    left = containerWidth;
  }
  if (top < 0) {
    top = 0;
  } else if (top > containerHeight) {
    top = containerHeight;
  }
  var saturation = left / containerWidth;
  var bright = 1 - top / containerHeight;
  return {
    h: hsl.h,
    s: saturation,
    v: bright,
    a: hsl.a,
    source: "hsv"
  };
};
var _createClass$5 = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$4(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Saturation = function(_ref) {
  _inherits$4(Saturation2, _ref);
  function Saturation2(props) {
    _classCallCheck$4(this, Saturation2);
    var _this = _possibleConstructorReturn$4(this, (Saturation2.__proto__ || Object.getPrototypeOf(Saturation2)).call(this, props));
    _this.handleChange = function(e) {
      typeof _this.props.onChange === "function" && _this.throttle(_this.props.onChange, calculateChange3(e, _this.props.hsl, _this.container), e);
    };
    _this.handleMouseDown = function(e) {
      _this.handleChange(e);
      var renderWindow = _this.getContainerRenderWindow();
      renderWindow.addEventListener("mousemove", _this.handleChange);
      renderWindow.addEventListener("mouseup", _this.handleMouseUp);
    };
    _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    };
    _this.throttle = throttle$1(function(fn, data, e) {
      fn(data, e);
    }, 50);
    return _this;
  }
  _createClass$5(Saturation2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.throttle.cancel();
      this.unbindEventListeners();
    }
  }, {
    key: "getContainerRenderWindow",
    value: function getContainerRenderWindow() {
      var container = this.container;
      var renderWindow = window;
      while (!renderWindow.document.contains(container) && renderWindow.parent !== renderWindow) {
        renderWindow = renderWindow.parent;
      }
      return renderWindow;
    }
  }, {
    key: "unbindEventListeners",
    value: function unbindEventListeners() {
      var renderWindow = this.getContainerRenderWindow();
      renderWindow.removeEventListener("mousemove", this.handleChange);
      renderWindow.removeEventListener("mouseup", this.handleMouseUp);
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var _ref2 = this.props.style || {}, color = _ref2.color, white = _ref2.white, black = _ref2.black, pointer = _ref2.pointer, circle = _ref2.circle;
      var styles = _default$2({
        "default": {
          color: {
            absolute: "0px 0px 0px 0px",
            background: "hsl(" + this.props.hsl.h + ",100%, 50%)",
            borderRadius: this.props.radius
          },
          white: {
            absolute: "0px 0px 0px 0px",
            borderRadius: this.props.radius
          },
          black: {
            absolute: "0px 0px 0px 0px",
            boxShadow: this.props.shadow,
            borderRadius: this.props.radius
          },
          pointer: {
            position: "absolute",
            top: -(this.props.hsv.v * 100) + 100 + "%",
            left: this.props.hsv.s * 100 + "%",
            cursor: "default"
          },
          circle: {
            width: "4px",
            height: "4px",
            boxShadow: "0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3),\n            0 0 1px 2px rgba(0,0,0,.4)",
            borderRadius: "50%",
            cursor: "hand",
            transform: "translate(-2px, -2px)"
          }
        },
        "custom": {
          color,
          white,
          black,
          pointer,
          circle
        }
      }, {
        "custom": !!this.props.style
      });
      return /* @__PURE__ */ jsxs("div", {
        style: styles.color,
        ref: function ref(container) {
          return _this2.container = container;
        },
        onMouseDown: this.handleMouseDown,
        onTouchMove: this.handleChange,
        onTouchStart: this.handleChange,
        children: [/* @__PURE__ */ jsx("style", {
          children: ".saturation-white { background: -webkit-linear-gradient(to right, #fff, rgba(255,255,255,0)); background: linear-gradient(to right, #fff, rgba(255,255,255,0)); } .saturation-black { background: -webkit-linear-gradient(to top, #000, rgba(0,0,0,0)); background: linear-gradient(to top, #000, rgba(0,0,0,0)); }"
        }), /* @__PURE__ */ jsxs("div", {
          style: styles.white,
          className: "saturation-white",
          children: [/* @__PURE__ */ jsx("div", {
            style: styles.black,
            className: "saturation-black"
          }), /* @__PURE__ */ jsx("div", {
            style: styles.pointer,
            children: this.props.pointer ? React__default.createElement(this.props.pointer, this.props) : /* @__PURE__ */ jsx("div", {
              style: styles.circle
            })
          })]
        })]
      });
    }
  }]);
  return Saturation2;
}(PureComponent || Component);
function arrayEach(array2, iteratee) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (iteratee(array2[index2], index2, array2) === false) {
      break;
    }
  }
  return array2;
}
var nativeKeys = overArg(Object.keys, Object);
var nativeKeys$1 = nativeKeys;
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function baseKeys(object2) {
  if (!isPrototype(object2)) {
    return nativeKeys$1(object2);
  }
  var result = [];
  for (var key in Object(object2)) {
    if (hasOwnProperty$3.call(object2, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function keys(object2) {
  return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
}
function baseForOwn(object2, iteratee) {
  return object2 && baseFor$1(object2, iteratee, keys);
}
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var baseEach = createBaseEach(baseForOwn);
var baseEach$1 = baseEach;
function castFunction(value) {
  return typeof value == "function" ? value : identity;
}
function forEach$1(collection, iteratee) {
  var func = isArray$2(collection) ? arrayEach : baseEach$1;
  return func(collection, castFunction(iteratee));
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color, opts) {
  color = color ? color : "";
  opts = opts || {};
  if (color instanceof tinycolor) {
    return color;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color, opts);
  }
  var rgb = inputToRGB(color);
  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1)
    this._r = Math.round(this._r);
  if (this._g < 1)
    this._g = Math.round(this._g);
  if (this._b < 1)
    this._b = Math.round(this._b);
  this._ok = rgb.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  },
  getLuminance: function getLuminance() {
    var rgb = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R, G, B;
    RsRGB = rgb.r / 255;
    GsRGB = rgb.g / 255;
    BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928)
      R = RsRGB / 12.92;
    else
      R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928)
      G = GsRGB / 12.92;
    else
      G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928)
      B = BsRGB / 12.92;
    else
      B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h = Math.round(hsv.h * 360), s = Math.round(hsv.s * 100), v = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    var h = Math.round(hsl.h * 360), s = Math.round(hsl.s * 100), l2 = Math.round(hsl.l * 100);
    return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l2 + "%)" : "hsla(" + h + ", " + s + "%, " + l2 + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString(format2) {
    var formatSet = !!format2;
    format2 = format2 || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format2 === "hex" || format2 === "hex6" || format2 === "hex3" || format2 === "hex4" || format2 === "hex8" || format2 === "name");
    if (needsAlphaFormat) {
      if (format2 === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format2 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format2 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format2 === "hex" || format2 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format2 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format2 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format2 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format2 === "name") {
      formattedString = this.toName();
    }
    if (format2 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format2 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone2() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn, args) {
    var color = fn.apply(null, [this].concat([].slice.call(args)));
    this._r = color._r;
    this._g = color._g;
    this._b = color._b;
    this.setAlpha(color._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn, args) {
    return fn.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color, opts) {
  if (_typeof(color) == "object") {
    var newColor = {};
    for (var i in color) {
      if (color.hasOwnProperty(i)) {
        if (i === "a") {
          newColor[i] = color[i];
        } else {
          newColor[i] = convertToPercentage(color[i]);
        }
      }
    }
    color = newColor;
  }
  return tinycolor(color, opts);
};
function inputToRGB(color) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a = 1;
  var s = null;
  var v = null;
  var l2 = null;
  var ok = false;
  var format2 = false;
  if (typeof color == "string") {
    color = stringInputToObject(color);
  }
  if (_typeof(color) == "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s, v);
      ok = true;
      format2 = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s = convertToPercentage(color.s);
      l2 = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s, l2);
      ok = true;
      format2 = "hsl";
    }
    if (color.hasOwnProperty("a")) {
      a = color.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok,
    format: color.format || format2,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a
  };
}
function rgbToRgb(r2, g, b) {
  return {
    r: bound01(r2, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
function rgbToHsl(r2, g, b) {
  r2 = bound01(r2, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max2 = Math.max(r2, g, b), min2 = Math.min(r2, g, b);
  var h, s, l2 = (max2 + min2) / 2;
  if (max2 == min2) {
    h = s = 0;
  } else {
    var d = max2 - min2;
    s = l2 > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
    switch (max2) {
      case r2:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r2) / d + 2;
        break;
      case b:
        h = (r2 - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h,
    s,
    l: l2
  };
}
function hslToRgb(h, s, l2) {
  var r2, g, b;
  h = bound01(h, 360);
  s = bound01(s, 100);
  l2 = bound01(l2, 100);
  function hue2rgb(p3, q3, t) {
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p3 + (q3 - p3) * 6 * t;
    if (t < 1 / 2)
      return q3;
    if (t < 2 / 3)
      return p3 + (q3 - p3) * (2 / 3 - t) * 6;
    return p3;
  }
  if (s === 0) {
    r2 = g = b = l2;
  } else {
    var q2 = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
    var p2 = 2 * l2 - q2;
    r2 = hue2rgb(p2, q2, h + 1 / 3);
    g = hue2rgb(p2, q2, h);
    b = hue2rgb(p2, q2, h - 1 / 3);
  }
  return {
    r: r2 * 255,
    g: g * 255,
    b: b * 255
  };
}
function rgbToHsv(r2, g, b) {
  r2 = bound01(r2, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max2 = Math.max(r2, g, b), min2 = Math.min(r2, g, b);
  var h, s, v = max2;
  var d = max2 - min2;
  s = max2 === 0 ? 0 : d / max2;
  if (max2 == min2) {
    h = 0;
  } else {
    switch (max2) {
      case r2:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r2) / d + 2;
        break;
      case b:
        h = (r2 - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h,
    s,
    v
  };
}
function hsvToRgb(h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  var i = Math.floor(h), f2 = h - i, p2 = v * (1 - s), q2 = v * (1 - f2 * s), t = v * (1 - (1 - f2) * s), mod2 = i % 6, r2 = [v, q2, p2, p2, t, v][mod2], g = [t, v, v, q2, p2, p2][mod2], b = [p2, p2, t, v, v, q2][mod2];
  return {
    r: r2 * 255,
    g: g * 255,
    b: b * 255
  };
}
function rgbToHex(r2, g, b, allow3Char) {
  var hex = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r2, g, b, a, allow4Char) {
  var hex = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];
  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function rgbaToArgbHex(r2, g, b, a) {
  var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r2).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  return hex.join("");
}
tinycolor.equals = function(color1, color2) {
  if (!color1 || !color2)
    return false;
  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s -= amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _saturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s += amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _greyscale(color) {
  return tinycolor(color).desaturate(100);
}
function _lighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l += amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _brighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb = tinycolor(color).toRgb();
  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb);
}
function _darken(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l -= amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _spin(color, amount) {
  var hsl = tinycolor(color).toHsl();
  var hue = (hsl.h + amount) % 360;
  hsl.h = hue < 0 ? 360 + hue : hue;
  return tinycolor(hsl);
}
function _complement(color) {
  var hsl = tinycolor(color).toHsl();
  hsl.h = (hsl.h + 180) % 360;
  return tinycolor(hsl);
}
function polyad(color, number) {
  if (isNaN(number) || number <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl = tinycolor(color).toHsl();
  var result = [tinycolor(color)];
  var step = 360 / number;
  for (var i = 1; i < number; i++) {
    result.push(tinycolor({
      h: (hsl.h + i * step) % 360,
      s: hsl.s,
      l: hsl.l
    }));
  }
  return result;
}
function _splitcomplement(color) {
  var hsl = tinycolor(color).toHsl();
  var h = hsl.h;
  return [tinycolor(color), tinycolor({
    h: (h + 72) % 360,
    s: hsl.s,
    l: hsl.l
  }), tinycolor({
    h: (h + 216) % 360,
    s: hsl.s,
    l: hsl.l
  })];
}
function _analogous(color, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl = tinycolor(color).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color)];
  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
    hsl.h = (hsl.h + part) % 360;
    ret.push(tinycolor(hsl));
  }
  return ret;
}
function _monochromatic(color, results) {
  results = results || 6;
  var hsv = tinycolor(color).toHsv();
  var h = hsv.h, s = hsv.s, v = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h,
      s,
      v
    }));
    v = (v + modification) % 1;
  }
  return ret;
}
tinycolor.mix = function(color1, color2, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color2).toRgb();
  var p2 = amount / 100;
  var rgba = {
    r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
    g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
    b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
    a: (rgb2.a - rgb1.a) * p2 + rgb1.a
  };
  return tinycolor(rgba);
};
tinycolor.readability = function(color1, color2) {
  var c1 = tinycolor(color1);
  var c2 = tinycolor(color2);
  return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color2, wcag2) {
  var readability = tinycolor.readability(color1, color2);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size2;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size2 = args.size;
  for (var i = 0; i < colorList.length; i++) {
    readability = tinycolor.readability(baseColor, colorList[i]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size: size2
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip$3(names);
function flip$3(o) {
  var flipped = {};
  for (var i in o) {
    if (o.hasOwnProperty(i)) {
      flipped[o[i]] = i;
    }
  }
  return flipped;
}
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}
function bound01(n2, max2) {
  if (isOnePointZero(n2))
    n2 = "100%";
  var processPercent = isPercentage(n2);
  n2 = Math.min(max2, Math.max(0, parseFloat(n2)));
  if (processPercent) {
    n2 = parseInt(n2 * max2, 10) / 100;
  }
  if (Math.abs(n2 - max2) < 1e-6) {
    return 1;
  }
  return n2 % max2 / parseFloat(max2);
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function isOnePointZero(n2) {
  return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
}
function isPercentage(n2) {
  return typeof n2 === "string" && n2.indexOf("%") != -1;
}
function pad2(c) {
  return c.length == 1 ? "0" + c : "" + c;
}
function convertToPercentage(n2) {
  if (n2 <= 1) {
    n2 = n2 * 100 + "%";
  }
  return n2;
}
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
function convertHexToDecimal(h) {
  return parseIntFromHex(h) / 255;
}
var matchers = function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function isValidCSSUnit(color) {
  return !!matchers.CSS_UNIT.exec(color);
}
function stringInputToObject(color) {
  color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match5;
  if (match5 = matchers.rgb.exec(color)) {
    return {
      r: match5[1],
      g: match5[2],
      b: match5[3]
    };
  }
  if (match5 = matchers.rgba.exec(color)) {
    return {
      r: match5[1],
      g: match5[2],
      b: match5[3],
      a: match5[4]
    };
  }
  if (match5 = matchers.hsl.exec(color)) {
    return {
      h: match5[1],
      s: match5[2],
      l: match5[3]
    };
  }
  if (match5 = matchers.hsla.exec(color)) {
    return {
      h: match5[1],
      s: match5[2],
      l: match5[3],
      a: match5[4]
    };
  }
  if (match5 = matchers.hsv.exec(color)) {
    return {
      h: match5[1],
      s: match5[2],
      v: match5[3]
    };
  }
  if (match5 = matchers.hsva.exec(color)) {
    return {
      h: match5[1],
      s: match5[2],
      v: match5[3],
      a: match5[4]
    };
  }
  if (match5 = matchers.hex8.exec(color)) {
    return {
      r: parseIntFromHex(match5[1]),
      g: parseIntFromHex(match5[2]),
      b: parseIntFromHex(match5[3]),
      a: convertHexToDecimal(match5[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match5 = matchers.hex6.exec(color)) {
    return {
      r: parseIntFromHex(match5[1]),
      g: parseIntFromHex(match5[2]),
      b: parseIntFromHex(match5[3]),
      format: named ? "name" : "hex"
    };
  }
  if (match5 = matchers.hex4.exec(color)) {
    return {
      r: parseIntFromHex(match5[1] + "" + match5[1]),
      g: parseIntFromHex(match5[2] + "" + match5[2]),
      b: parseIntFromHex(match5[3] + "" + match5[3]),
      a: convertHexToDecimal(match5[4] + "" + match5[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match5 = matchers.hex3.exec(color)) {
    return {
      r: parseIntFromHex(match5[1] + "" + match5[1]),
      g: parseIntFromHex(match5[2] + "" + match5[2]),
      b: parseIntFromHex(match5[3] + "" + match5[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  var level, size2;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size2 = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size2 !== "small" && size2 !== "large") {
    size2 = "small";
  }
  return {
    level,
    size: size2
  };
}
var simpleCheckForValidColor = function simpleCheckForValidColor2(data) {
  var keysToCheck = ["r", "g", "b", "a", "h", "s", "l", "v"];
  var checked = 0;
  var passed = 0;
  forEach$1(keysToCheck, function(letter) {
    if (data[letter]) {
      checked += 1;
      if (!isNaN(data[letter])) {
        passed += 1;
      }
      if (letter === "s" || letter === "l") {
        var percentPatt = /^\d+%$/;
        if (percentPatt.test(data[letter])) {
          passed += 1;
        }
      }
    }
  });
  return checked === passed ? data : false;
};
var toState = function toState2(data, oldHue) {
  var color = data.hex ? tinycolor(data.hex) : tinycolor(data);
  var hsl = color.toHsl();
  var hsv = color.toHsv();
  var rgb = color.toRgb();
  var hex = color.toHex();
  if (hsl.s === 0) {
    hsl.h = oldHue || 0;
    hsv.h = oldHue || 0;
  }
  var transparent = hex === "000000" && rgb.a === 0;
  return {
    hsl,
    hex: transparent ? "transparent" : "#" + hex,
    rgb,
    hsv,
    oldHue: data.h || oldHue || hsl.h,
    source: data.source
  };
};
var isValidHex = function isValidHex2(hex) {
  if (hex === "transparent") {
    return true;
  }
  var lh = String(hex).charAt(0) === "#" ? 1 : 0;
  return hex.length !== 4 + lh && hex.length < 7 + lh && tinycolor(hex).isValid();
};
var getContrastingColor = function getContrastingColor2(data) {
  if (!data) {
    return "#fff";
  }
  var col = toState(data);
  if (col.hex === "transparent") {
    return "rgba(0,0,0,0.4)";
  }
  var yiq = (col.rgb.r * 299 + col.rgb.g * 587 + col.rgb.b * 114) / 1e3;
  return yiq >= 128 ? "#000" : "#fff";
};
var isvalidColorString = function isvalidColorString2(string, type) {
  var stringWithoutDegree = string.replace("\xB0", "");
  return tinycolor(type + " (" + stringWithoutDegree + ")")._ok;
};
var _extends$a = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass$4 = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$3(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var ColorWrap = function ColorWrap2(Picker) {
  var ColorPicker3 = function(_ref) {
    _inherits$3(ColorPicker4, _ref);
    function ColorPicker4(props) {
      _classCallCheck$3(this, ColorPicker4);
      var _this = _possibleConstructorReturn$3(this, (ColorPicker4.__proto__ || Object.getPrototypeOf(ColorPicker4)).call(this));
      _this.handleChange = function(data, event) {
        var isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
          var colors = toState(data, data.h || _this.state.oldHue);
          _this.setState(colors);
          _this.props.onChangeComplete && _this.debounce(_this.props.onChangeComplete, colors, event);
          _this.props.onChange && _this.props.onChange(colors, event);
        }
      };
      _this.handleSwatchHover = function(data, event) {
        var isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
          var colors = toState(data, data.h || _this.state.oldHue);
          _this.props.onSwatchHover && _this.props.onSwatchHover(colors, event);
        }
      };
      _this.state = _extends$a({}, toState(props.color, 0));
      _this.debounce = debounce(function(fn, data, event) {
        fn(data, event);
      }, 100);
      return _this;
    }
    _createClass$4(ColorPicker4, [{
      key: "render",
      value: function render3() {
        var optionalEvents = {};
        if (this.props.onSwatchHover) {
          optionalEvents.onSwatchHover = this.handleSwatchHover;
        }
        return /* @__PURE__ */ jsx(Picker, {
          ...this.props,
          ...this.state,
          onChange: this.handleChange,
          ...optionalEvents
        });
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(nextProps, state) {
        return _extends$a({}, toState(nextProps.color, state.oldHue));
      }
    }]);
    return ColorPicker4;
  }(PureComponent || Component);
  ColorPicker3.propTypes = _extends$a({}, Picker.propTypes);
  ColorPicker3.defaultProps = _extends$a({}, Picker.defaultProps, {
    color: {
      h: 250,
      s: 0.5,
      l: 0.2,
      a: 1
    }
  });
  return ColorPicker3;
};
var _extends$9 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass$3 = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$2(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var handleFocus = function handleFocus2(Component2) {
  var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
  return function(_React$Component) {
    _inherits$2(Focus, _React$Component);
    function Focus() {
      var _ref;
      var _temp, _this, _ret;
      _classCallCheck$2(this, Focus);
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _ret = (_temp = (_this = _possibleConstructorReturn$2(this, (_ref = Focus.__proto__ || Object.getPrototypeOf(Focus)).call.apply(_ref, [this].concat(args))), _this), _this.state = { focus: false }, _this.handleFocus = function() {
        return _this.setState({ focus: true });
      }, _this.handleBlur = function() {
        return _this.setState({ focus: false });
      }, _temp), _possibleConstructorReturn$2(_this, _ret);
    }
    _createClass$3(Focus, [{
      key: "render",
      value: function render3() {
        return React__default.createElement(
          Span,
          { onFocus: this.handleFocus, onBlur: this.handleBlur },
          React__default.createElement(Component2, _extends$9({}, this.props, this.state))
        );
      }
    }]);
    return Focus;
  }(React__default.Component);
};
var _extends$8 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var ENTER = 13;
var Swatch = function Swatch2(_ref) {
  var color = _ref.color, style = _ref.style, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onHover = _ref.onHover, _ref$title = _ref.title, title = _ref$title === void 0 ? color : _ref$title, children = _ref.children, focus = _ref.focus, _ref$focusStyle = _ref.focusStyle, focusStyle = _ref$focusStyle === void 0 ? {} : _ref$focusStyle;
  var transparent = color === "transparent";
  var styles = _default$2({
    default: {
      swatch: _extends$8({
        background: color,
        height: "100%",
        width: "100%",
        cursor: "pointer",
        position: "relative",
        outline: "none"
      }, style, focus ? focusStyle : {})
    }
  });
  var handleClick = function handleClick2(e) {
    return onClick(color, e);
  };
  var handleKeyDown = function handleKeyDown2(e) {
    return e.keyCode === ENTER && onClick(color, e);
  };
  var handleHover2 = function handleHover3(e) {
    return onHover(color, e);
  };
  var optionalEvents = {};
  if (onHover) {
    optionalEvents.onMouseOver = handleHover2;
  }
  return React__default.createElement(
    "div",
    _extends$8({
      style: styles.swatch,
      onClick: handleClick,
      title,
      tabIndex: 0,
      onKeyDown: handleKeyDown
    }, optionalEvents),
    children,
    transparent && React__default.createElement(Checkboard, {
      borderRadius: styles.swatch.borderRadius,
      boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)"
    })
  );
};
var Swatch$1 = handleFocus(Swatch);
var AlphaPointer = function AlphaPointer2(_ref) {
  var direction = _ref.direction;
  var styles = _default$2({
    "default": {
      picker: {
        width: "18px",
        height: "18px",
        borderRadius: "50%",
        transform: "translate(-9px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    },
    "vertical": {
      picker: {
        transform: "translate(-3px, -9px)"
      }
    }
  }, { vertical: direction === "vertical" });
  return React__default.createElement("div", { style: styles.picker });
};
var _extends$7 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var AlphaPicker = function AlphaPicker2(_ref) {
  var rgb = _ref.rgb, hsl = _ref.hsl, width = _ref.width, height = _ref.height, onChange = _ref.onChange, direction = _ref.direction, style = _ref.style, renderers = _ref.renderers, pointer = _ref.pointer, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2({
    "default": {
      picker: {
        position: "relative",
        width,
        height
      },
      alpha: {
        radius: "2px",
        style
      }
    }
  });
  return React__default.createElement(
    "div",
    { style: styles.picker, className: "alpha-picker " + className },
    React__default.createElement(Alpha, _extends$7({}, styles.alpha, {
      rgb,
      hsl,
      pointer,
      renderers,
      onChange,
      direction
    }))
  );
};
AlphaPicker.defaultProps = {
  width: "316px",
  height: "16px",
  direction: "horizontal",
  pointer: AlphaPointer
};
ColorWrap(AlphaPicker);
function arrayMap(array2, iteratee) {
  var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array2[index2], index2, array2);
  }
  return result;
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array2, predicate) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (predicate(array2[index2], index2, array2)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache2, key) {
  return cache2.has(key);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array2.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array2);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array2;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array2, other);
  stack.set(other, array2);
  while (++index2 < arrLength) {
    var arrValue = array2[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array2);
  stack["delete"](other);
  return result;
}
function mapToArray(map3) {
  var index2 = -1, result = Array(map3.size);
  map3.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
function setToArray(set5) {
  var index2 = -1, result = Array(set5.size);
  set5.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag$1 = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]";
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$1:
      if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
        return false;
      }
      object2 = object2.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object2), new Uint8Array$2(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq$1(+object2, +other);
    case errorTag:
      return object2.name == other.name && object2.message == other.message;
    case regexpTag:
    case stringTag:
      return object2 == other + "";
    case mapTag$1:
      var convert = mapToArray;
    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object2.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object2);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object2, other);
      var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object2);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object2) == symbolValueOf.call(other);
      }
  }
  return false;
}
function arrayPush(array2, values) {
  var index2 = -1, length = values.length, offset2 = array2.length;
  while (++index2 < length) {
    array2[offset2 + index2] = values[index2];
  }
  return array2;
}
function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
  var result = keysFunc(object2);
  return isArray$2(object2) ? result : arrayPush(result, symbolsFunc(object2));
}
function arrayFilter(array2, predicate) {
  var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array2[index2];
    if (predicate(value, index2, array2)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$2 = Object.prototype;
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
  if (object2 == null) {
    return [];
  }
  object2 = Object(object2);
  return arrayFilter(nativeGetSymbols(object2), function(symbol) {
    return propertyIsEnumerable.call(object2, symbol);
  });
};
var getSymbols$1 = getSymbols;
function getAllKeys(object2) {
  return baseGetAllKeys(object2, keys, getSymbols$1);
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object2);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object2;
  }
  var result = true;
  stack.set(object2, other);
  stack.set(other, object2);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object2[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object2.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object2);
  stack["delete"](other);
  return result;
}
var DataView = getNative(root$1, "DataView");
var DataView$1 = DataView;
var Promise$1 = getNative(root$1, "Promise");
var Promise$2 = Promise$1;
var Set$1 = getNative(root$1, "Set");
var Set$2 = Set$1;
var WeakMap = getNative(root$1, "WeakMap");
var WeakMap$1 = WeakMap;
var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$1);
var getTag = baseGetTag;
if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag || Map$2 && getTag(new Map$2()) != mapTag || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var getTag$1 = getTag;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty$1 = objectProto.hasOwnProperty;
function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$2(object2), othIsArr = isArray$2(other), objTag = objIsArr ? arrayTag : getTag$1(object2), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$2(object2)) {
    if (!isBuffer$2(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray$2(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object2, source, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object2 == null) {
    return !length;
  }
  object2 = Object(object2);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key = data[0], objValue = object2[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object2)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object2, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value) {
  return value === value && !isObject$3(value);
}
function getMatchData(object2) {
  var result = keys(object2), length = result.length;
  while (length--) {
    var key = result[length], value = object2[key];
    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}
function matchesStrictComparable(key, srcValue) {
  return function(object2) {
    if (object2 == null) {
      return false;
    }
    return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
  };
}
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object2) {
    return object2 === source || baseIsMatch(object2, source, matchData);
  };
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object2) {
  if (isArray$2(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
}
var FUNC_ERROR_TEXT = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache)();
  return memoized;
}
memoize$1.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize$1(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match5, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match5);
  });
  return result;
});
var stringToPath$1 = stringToPath;
var INFINITY$1 = 1 / 0;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$2(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
function toString$2(value) {
  return value == null ? "" : baseToString(value);
}
function castPath(value, object2) {
  if (isArray$2(value)) {
    return value;
  }
  return isKey(value, object2) ? [value] : stringToPath$1(toString$2(value));
}
var INFINITY = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function baseGet(object2, path) {
  path = castPath(path, object2);
  var index2 = 0, length = path.length;
  while (object2 != null && index2 < length) {
    object2 = object2[toKey(path[index2++])];
  }
  return index2 && index2 == length ? object2 : void 0;
}
function get$1(object2, path, defaultValue) {
  var result = object2 == null ? void 0 : baseGet(object2, path);
  return result === void 0 ? defaultValue : result;
}
function baseHasIn(object2, key) {
  return object2 != null && key in Object(object2);
}
function hasPath(object2, path, hasFunc) {
  path = castPath(path, object2);
  var index2 = -1, length = path.length, result = false;
  while (++index2 < length) {
    var key = toKey(path[index2]);
    if (!(result = object2 != null && hasFunc(object2, key))) {
      break;
    }
    object2 = object2[key];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object2 == null ? 0 : object2.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray$2(object2) || isArguments$1(object2));
}
function hasIn(object2, path) {
  return object2 != null && hasPath(object2, path, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object2) {
    var objValue = get$1(object2, path);
    return objValue === void 0 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(key) {
  return function(object2) {
    return object2 == null ? void 0 : object2[key];
  };
}
function basePropertyDeep(path) {
  return function(object2) {
    return baseGet(object2, path);
  };
}
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == "object") {
    return isArray$2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
function baseMap(collection, iteratee) {
  var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach$1(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
function map(collection, iteratee) {
  var func = isArray$2(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee));
}
var BlockSwatches = function BlockSwatches2(_ref) {
  var colors = _ref.colors, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover;
  var styles = _default$2({
    "default": {
      swatches: {
        marginRight: "-10px"
      },
      swatch: {
        width: "22px",
        height: "22px",
        float: "left",
        marginRight: "10px",
        marginBottom: "10px",
        borderRadius: "4px"
      },
      clear: {
        clear: "both"
      }
    }
  });
  return React__default.createElement(
    "div",
    { style: styles.swatches },
    map(colors, function(c) {
      return React__default.createElement(Swatch$1, {
        key: c,
        color: c,
        style: styles.swatch,
        onClick,
        onHover: onSwatchHover,
        focusStyle: {
          boxShadow: "0 0 4px " + c
        }
      });
    }),
    React__default.createElement("div", { style: styles.clear })
  );
};
var Block = function Block2(_ref) {
  var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, hex = _ref.hex, colors = _ref.colors, width = _ref.width, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var transparent = hex === "transparent";
  var handleChange = function handleChange2(hexCode, e) {
    isValidHex(hexCode) && onChange({
      hex: hexCode,
      source: "hex"
    }, e);
  };
  var styles = _default$2(merge$2({
    "default": {
      card: {
        width,
        background: "#fff",
        boxShadow: "0 1px rgba(0,0,0,.1)",
        borderRadius: "6px",
        position: "relative"
      },
      head: {
        height: "110px",
        background: hex,
        borderRadius: "6px 6px 0 0",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        position: "relative"
      },
      body: {
        padding: "10px"
      },
      label: {
        fontSize: "18px",
        color: getContrastingColor(hex),
        position: "relative"
      },
      triangle: {
        width: "0px",
        height: "0px",
        borderStyle: "solid",
        borderWidth: "0 10px 10px 10px",
        borderColor: "transparent transparent " + hex + " transparent",
        position: "absolute",
        top: "-10px",
        left: "50%",
        marginLeft: "-10px"
      },
      input: {
        width: "100%",
        fontSize: "12px",
        color: "#666",
        border: "0px",
        outline: "none",
        height: "22px",
        boxShadow: "inset 0 0 0 1px #ddd",
        borderRadius: "4px",
        padding: "0 7px",
        boxSizing: "border-box"
      }
    },
    "hide-triangle": {
      triangle: {
        display: "none"
      }
    }
  }, passedStyles), { "hide-triangle": triangle === "hide" });
  return React__default.createElement(
    "div",
    { style: styles.card, className: "block-picker " + className },
    React__default.createElement("div", { style: styles.triangle }),
    React__default.createElement(
      "div",
      { style: styles.head },
      transparent && React__default.createElement(Checkboard, { borderRadius: "6px 6px 0 0" }),
      React__default.createElement(
        "div",
        { style: styles.label },
        hex
      )
    ),
    React__default.createElement(
      "div",
      { style: styles.body },
      React__default.createElement(BlockSwatches, { colors, onClick: handleChange, onSwatchHover }),
      React__default.createElement(EditableInput, {
        style: { input: styles.input },
        value: hex,
        onChange: handleChange
      })
    )
  );
};
Block.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  colors: PropTypes.arrayOf(PropTypes.string),
  triangle: PropTypes.oneOf(["top", "hide"]),
  styles: PropTypes.object
};
Block.defaultProps = {
  width: 170,
  colors: ["#D9E3F0", "#F47373", "#697689", "#37D67A", "#2CCCE4", "#555555", "#dce775", "#ff8a65", "#ba68c8"],
  triangle: "top",
  styles: {}
};
ColorWrap(Block);
var red = { "50": "#ffebee", "100": "#ffcdd2", "200": "#ef9a9a", "300": "#e57373", "400": "#ef5350", "500": "#f44336", "600": "#e53935", "700": "#d32f2f", "800": "#c62828", "900": "#b71c1c", "a100": "#ff8a80", "a200": "#ff5252", "a400": "#ff1744", "a700": "#d50000" };
var pink = { "50": "#fce4ec", "100": "#f8bbd0", "200": "#f48fb1", "300": "#f06292", "400": "#ec407a", "500": "#e91e63", "600": "#d81b60", "700": "#c2185b", "800": "#ad1457", "900": "#880e4f", "a100": "#ff80ab", "a200": "#ff4081", "a400": "#f50057", "a700": "#c51162" };
var purple = { "50": "#f3e5f5", "100": "#e1bee7", "200": "#ce93d8", "300": "#ba68c8", "400": "#ab47bc", "500": "#9c27b0", "600": "#8e24aa", "700": "#7b1fa2", "800": "#6a1b9a", "900": "#4a148c", "a100": "#ea80fc", "a200": "#e040fb", "a400": "#d500f9", "a700": "#aa00ff" };
var deepPurple = { "50": "#ede7f6", "100": "#d1c4e9", "200": "#b39ddb", "300": "#9575cd", "400": "#7e57c2", "500": "#673ab7", "600": "#5e35b1", "700": "#512da8", "800": "#4527a0", "900": "#311b92", "a100": "#b388ff", "a200": "#7c4dff", "a400": "#651fff", "a700": "#6200ea" };
var indigo = { "50": "#e8eaf6", "100": "#c5cae9", "200": "#9fa8da", "300": "#7986cb", "400": "#5c6bc0", "500": "#3f51b5", "600": "#3949ab", "700": "#303f9f", "800": "#283593", "900": "#1a237e", "a100": "#8c9eff", "a200": "#536dfe", "a400": "#3d5afe", "a700": "#304ffe" };
var blue = { "50": "#e3f2fd", "100": "#bbdefb", "200": "#90caf9", "300": "#64b5f6", "400": "#42a5f5", "500": "#2196f3", "600": "#1e88e5", "700": "#1976d2", "800": "#1565c0", "900": "#0d47a1", "a100": "#82b1ff", "a200": "#448aff", "a400": "#2979ff", "a700": "#2962ff" };
var lightBlue = { "50": "#e1f5fe", "100": "#b3e5fc", "200": "#81d4fa", "300": "#4fc3f7", "400": "#29b6f6", "500": "#03a9f4", "600": "#039be5", "700": "#0288d1", "800": "#0277bd", "900": "#01579b", "a100": "#80d8ff", "a200": "#40c4ff", "a400": "#00b0ff", "a700": "#0091ea" };
var cyan = { "50": "#e0f7fa", "100": "#b2ebf2", "200": "#80deea", "300": "#4dd0e1", "400": "#26c6da", "500": "#00bcd4", "600": "#00acc1", "700": "#0097a7", "800": "#00838f", "900": "#006064", "a100": "#84ffff", "a200": "#18ffff", "a400": "#00e5ff", "a700": "#00b8d4" };
var teal = { "50": "#e0f2f1", "100": "#b2dfdb", "200": "#80cbc4", "300": "#4db6ac", "400": "#26a69a", "500": "#009688", "600": "#00897b", "700": "#00796b", "800": "#00695c", "900": "#004d40", "a100": "#a7ffeb", "a200": "#64ffda", "a400": "#1de9b6", "a700": "#00bfa5" };
var green = { "50": "#e8f5e9", "100": "#c8e6c9", "200": "#a5d6a7", "300": "#81c784", "400": "#66bb6a", "500": "#4caf50", "600": "#43a047", "700": "#388e3c", "800": "#2e7d32", "900": "#1b5e20", "a100": "#b9f6ca", "a200": "#69f0ae", "a400": "#00e676", "a700": "#00c853" };
var lightGreen = { "50": "#f1f8e9", "100": "#dcedc8", "200": "#c5e1a5", "300": "#aed581", "400": "#9ccc65", "500": "#8bc34a", "600": "#7cb342", "700": "#689f38", "800": "#558b2f", "900": "#33691e", "a100": "#ccff90", "a200": "#b2ff59", "a400": "#76ff03", "a700": "#64dd17" };
var lime = { "50": "#f9fbe7", "100": "#f0f4c3", "200": "#e6ee9c", "300": "#dce775", "400": "#d4e157", "500": "#cddc39", "600": "#c0ca33", "700": "#afb42b", "800": "#9e9d24", "900": "#827717", "a100": "#f4ff81", "a200": "#eeff41", "a400": "#c6ff00", "a700": "#aeea00" };
var yellow = { "50": "#fffde7", "100": "#fff9c4", "200": "#fff59d", "300": "#fff176", "400": "#ffee58", "500": "#ffeb3b", "600": "#fdd835", "700": "#fbc02d", "800": "#f9a825", "900": "#f57f17", "a100": "#ffff8d", "a200": "#ffff00", "a400": "#ffea00", "a700": "#ffd600" };
var amber = { "50": "#fff8e1", "100": "#ffecb3", "200": "#ffe082", "300": "#ffd54f", "400": "#ffca28", "500": "#ffc107", "600": "#ffb300", "700": "#ffa000", "800": "#ff8f00", "900": "#ff6f00", "a100": "#ffe57f", "a200": "#ffd740", "a400": "#ffc400", "a700": "#ffab00" };
var orange = { "50": "#fff3e0", "100": "#ffe0b2", "200": "#ffcc80", "300": "#ffb74d", "400": "#ffa726", "500": "#ff9800", "600": "#fb8c00", "700": "#f57c00", "800": "#ef6c00", "900": "#e65100", "a100": "#ffd180", "a200": "#ffab40", "a400": "#ff9100", "a700": "#ff6d00" };
var deepOrange = { "50": "#fbe9e7", "100": "#ffccbc", "200": "#ffab91", "300": "#ff8a65", "400": "#ff7043", "500": "#ff5722", "600": "#f4511e", "700": "#e64a19", "800": "#d84315", "900": "#bf360c", "a100": "#ff9e80", "a200": "#ff6e40", "a400": "#ff3d00", "a700": "#dd2c00" };
var brown = { "50": "#efebe9", "100": "#d7ccc8", "200": "#bcaaa4", "300": "#a1887f", "400": "#8d6e63", "500": "#795548", "600": "#6d4c41", "700": "#5d4037", "800": "#4e342e", "900": "#3e2723" };
var blueGrey = { "50": "#eceff1", "100": "#cfd8dc", "200": "#b0bec5", "300": "#90a4ae", "400": "#78909c", "500": "#607d8b", "600": "#546e7a", "700": "#455a64", "800": "#37474f", "900": "#263238" };
var CircleSwatch = function CircleSwatch2(_ref) {
  var color = _ref.color, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover, hover3 = _ref.hover, active3 = _ref.active, circleSize = _ref.circleSize, circleSpacing = _ref.circleSpacing;
  var styles = _default$2({
    "default": {
      swatch: {
        width: circleSize,
        height: circleSize,
        marginRight: circleSpacing,
        marginBottom: circleSpacing,
        transform: "scale(1)",
        transition: "100ms transform ease"
      },
      Swatch: {
        borderRadius: "50%",
        background: "transparent",
        boxShadow: "inset 0 0 0 " + (circleSize / 2 + 1) + "px " + color,
        transition: "100ms box-shadow ease"
      }
    },
    "hover": {
      swatch: {
        transform: "scale(1.2)"
      }
    },
    "active": {
      Swatch: {
        boxShadow: "inset 0 0 0 3px " + color
      }
    }
  }, { hover: hover3, active: active3 });
  return React__default.createElement(
    "div",
    { style: styles.swatch },
    React__default.createElement(Swatch$1, {
      style: styles.Swatch,
      color,
      onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: styles.Swatch.boxShadow + ", 0 0 5px " + color }
    })
  );
};
CircleSwatch.defaultProps = {
  circleSize: 28,
  circleSpacing: 14
};
var CircleSwatch$1 = handleHover(CircleSwatch);
var Circle = function Circle2(_ref) {
  var width = _ref.width, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors = _ref.colors, hex = _ref.hex, circleSize = _ref.circleSize, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, circleSpacing = _ref.circleSpacing, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$2({
    "default": {
      card: {
        width,
        display: "flex",
        flexWrap: "wrap",
        marginRight: -circleSpacing,
        marginBottom: -circleSpacing
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(hexCode, e) {
    return onChange({ hex: hexCode, source: "hex" }, e);
  };
  return React__default.createElement(
    "div",
    { style: styles.card, className: "circle-picker " + className },
    map(colors, function(c) {
      return React__default.createElement(CircleSwatch$1, {
        key: c,
        color: c,
        onClick: handleChange,
        onSwatchHover,
        active: hex === c.toLowerCase(),
        circleSize,
        circleSpacing
      });
    })
  );
};
Circle.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  circleSize: PropTypes.number,
  circleSpacing: PropTypes.number,
  styles: PropTypes.object
};
Circle.defaultProps = {
  width: 252,
  circleSize: 28,
  circleSpacing: 14,
  colors: [red["500"], pink["500"], purple["500"], deepPurple["500"], indigo["500"], blue["500"], lightBlue["500"], cyan["500"], teal["500"], green["500"], lightGreen["500"], lime["500"], yellow["500"], amber["500"], orange["500"], deepOrange["500"], brown["500"], blueGrey["500"]],
  styles: {}
};
ColorWrap(Circle);
function isUndefined$1(value) {
  return value === void 0;
}
var UnfoldMoreHorizontalIcon = {};
Object.defineProperty(UnfoldMoreHorizontalIcon, "__esModule", {
  value: true
});
var _extends$6 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _react$1 = React__default;
var _react2$1 = _interopRequireDefault$1(_react$1);
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _objectWithoutProperties$2(obj, keys2) {
  var target = {};
  for (var i in obj) {
    if (keys2.indexOf(i) >= 0)
      continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i))
      continue;
    target[i] = obj[i];
  }
  return target;
}
var DEFAULT_SIZE$1 = 24;
var _default$1 = UnfoldMoreHorizontalIcon.default = function(_ref) {
  var _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "currentColor" : _ref$fill, _ref$width = _ref.width, width = _ref$width === void 0 ? DEFAULT_SIZE$1 : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? DEFAULT_SIZE$1 : _ref$height, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, props = _objectWithoutProperties$2(_ref, ["fill", "width", "height", "style"]);
  return _react2$1.default.createElement(
    "svg",
    _extends$6({
      viewBox: "0 0 " + DEFAULT_SIZE$1 + " " + DEFAULT_SIZE$1,
      style: _extends$6({ fill, width, height }, style)
    }, props),
    _react2$1.default.createElement("path", { d: "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z" })
  );
};
var _createClass$2 = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$1(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var ChromeFields = function(_React$Component) {
  _inherits$1(ChromeFields2, _React$Component);
  function ChromeFields2(props) {
    _classCallCheck$1(this, ChromeFields2);
    var _this = _possibleConstructorReturn$1(this, (ChromeFields2.__proto__ || Object.getPrototypeOf(ChromeFields2)).call(this));
    _this.toggleViews = function() {
      if (_this.state.view === "hex") {
        _this.setState({ view: "rgb" });
      } else if (_this.state.view === "rgb") {
        _this.setState({ view: "hsl" });
      } else if (_this.state.view === "hsl") {
        if (_this.props.hsl.a === 1) {
          _this.setState({ view: "hex" });
        } else {
          _this.setState({ view: "rgb" });
        }
      }
    };
    _this.handleChange = function(data, e) {
      if (data.hex) {
        isValidHex(data.hex) && _this.props.onChange({
          hex: data.hex,
          source: "hex"
        }, e);
      } else if (data.r || data.g || data.b) {
        _this.props.onChange({
          r: data.r || _this.props.rgb.r,
          g: data.g || _this.props.rgb.g,
          b: data.b || _this.props.rgb.b,
          source: "rgb"
        }, e);
      } else if (data.a) {
        if (data.a < 0) {
          data.a = 0;
        } else if (data.a > 1) {
          data.a = 1;
        }
        _this.props.onChange({
          h: _this.props.hsl.h,
          s: _this.props.hsl.s,
          l: _this.props.hsl.l,
          a: Math.round(data.a * 100) / 100,
          source: "rgb"
        }, e);
      } else if (data.h || data.s || data.l) {
        if (typeof data.s === "string" && data.s.includes("%")) {
          data.s = data.s.replace("%", "");
        }
        if (typeof data.l === "string" && data.l.includes("%")) {
          data.l = data.l.replace("%", "");
        }
        if (data.s == 1) {
          data.s = 0.01;
        } else if (data.l == 1) {
          data.l = 0.01;
        }
        _this.props.onChange({
          h: data.h || _this.props.hsl.h,
          s: Number(!isUndefined$1(data.s) ? data.s : _this.props.hsl.s),
          l: Number(!isUndefined$1(data.l) ? data.l : _this.props.hsl.l),
          source: "hsl"
        }, e);
      }
    };
    _this.showHighlight = function(e) {
      e.currentTarget.style.background = "#eee";
    };
    _this.hideHighlight = function(e) {
      e.currentTarget.style.background = "transparent";
    };
    if (props.hsl.a !== 1 && props.view === "hex") {
      _this.state = {
        view: "rgb"
      };
    } else {
      _this.state = {
        view: props.view
      };
    }
    return _this;
  }
  _createClass$2(ChromeFields2, [{
    key: "render",
    value: function render3() {
      var _this2 = this;
      var styles = _default$2({
        "default": {
          wrap: {
            paddingTop: "16px",
            display: "flex"
          },
          fields: {
            flex: "1",
            display: "flex",
            marginLeft: "-6px"
          },
          field: {
            paddingLeft: "6px",
            width: "100%"
          },
          alpha: {
            paddingLeft: "6px",
            width: "100%"
          },
          toggle: {
            width: "32px",
            textAlign: "right",
            position: "relative"
          },
          icon: {
            marginRight: "-4px",
            marginTop: "12px",
            cursor: "pointer",
            position: "relative"
          },
          iconHighlight: {
            position: "absolute",
            width: "24px",
            height: "28px",
            background: "#eee",
            borderRadius: "4px",
            top: "10px",
            left: "12px",
            display: "none"
          },
          input: {
            fontSize: "11px",
            color: "#333",
            width: "100%",
            borderRadius: "2px",
            border: "none",
            boxShadow: "inset 0 0 0 1px #dadada",
            height: "21px",
            textAlign: "center"
          },
          label: {
            textTransform: "uppercase",
            fontSize: "11px",
            lineHeight: "11px",
            color: "#969696",
            textAlign: "center",
            display: "block",
            marginTop: "12px"
          },
          svg: {
            fill: "#333",
            width: "24px",
            height: "24px",
            border: "1px transparent solid",
            borderRadius: "5px"
          }
        },
        "disableAlpha": {
          alpha: {
            display: "none"
          }
        }
      }, this.props, this.state);
      var fields = void 0;
      if (this.state.view === "hex") {
        fields = React__default.createElement(
          "div",
          { style: styles.fields, className: "flexbox-fix" },
          React__default.createElement(
            "div",
            { style: styles.field },
            React__default.createElement(EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: "hex",
              value: this.props.hex,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === "rgb") {
        fields = React__default.createElement(
          "div",
          { style: styles.fields, className: "flexbox-fix" },
          React__default.createElement(
            "div",
            { style: styles.field },
            React__default.createElement(EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: "r",
              value: this.props.rgb.r,
              onChange: this.handleChange
            })
          ),
          React__default.createElement(
            "div",
            { style: styles.field },
            React__default.createElement(EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: "g",
              value: this.props.rgb.g,
              onChange: this.handleChange
            })
          ),
          React__default.createElement(
            "div",
            { style: styles.field },
            React__default.createElement(EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: "b",
              value: this.props.rgb.b,
              onChange: this.handleChange
            })
          ),
          React__default.createElement(
            "div",
            { style: styles.alpha },
            React__default.createElement(EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: "a",
              value: this.props.rgb.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === "hsl") {
        fields = React__default.createElement(
          "div",
          { style: styles.fields, className: "flexbox-fix" },
          React__default.createElement(
            "div",
            { style: styles.field },
            React__default.createElement(EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: "h",
              value: Math.round(this.props.hsl.h),
              onChange: this.handleChange
            })
          ),
          React__default.createElement(
            "div",
            { style: styles.field },
            React__default.createElement(EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: "s",
              value: Math.round(this.props.hsl.s * 100) + "%",
              onChange: this.handleChange
            })
          ),
          React__default.createElement(
            "div",
            { style: styles.field },
            React__default.createElement(EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: "l",
              value: Math.round(this.props.hsl.l * 100) + "%",
              onChange: this.handleChange
            })
          ),
          React__default.createElement(
            "div",
            { style: styles.alpha },
            React__default.createElement(EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: "a",
              value: this.props.hsl.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      }
      return React__default.createElement(
        "div",
        { style: styles.wrap, className: "flexbox-fix" },
        fields,
        React__default.createElement(
          "div",
          { style: styles.toggle },
          React__default.createElement(
            "div",
            { style: styles.icon, onClick: this.toggleViews, ref: function ref(icon) {
              return _this2.icon = icon;
            } },
            React__default.createElement(_default$1, {
              style: styles.svg,
              onMouseOver: this.showHighlight,
              onMouseEnter: this.showHighlight,
              onMouseOut: this.hideHighlight
            })
          )
        )
      );
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, state) {
      if (nextProps.hsl.a !== 1 && state.view === "hex") {
        return { view: "rgb" };
      }
      return null;
    }
  }]);
  return ChromeFields2;
}(React__default.Component);
ChromeFields.defaultProps = {
  view: "hex"
};
var ChromePointer = function ChromePointer2() {
  var styles = _default$2({
    "default": {
      picker: {
        width: "12px",
        height: "12px",
        borderRadius: "6px",
        transform: "translate(-6px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    }
  });
  return React__default.createElement("div", { style: styles.picker });
};
var ChromePointerCircle = function ChromePointerCircle2() {
  var styles = _default$2({
    "default": {
      picker: {
        width: "12px",
        height: "12px",
        borderRadius: "6px",
        boxShadow: "inset 0 0 0 1px #fff",
        transform: "translate(-6px, -6px)"
      }
    }
  });
  return React__default.createElement("div", { style: styles.picker });
};
var Chrome = function Chrome2(_ref) {
  var width = _ref.width, onChange = _ref.onChange, disableAlpha = _ref.disableAlpha, rgb = _ref.rgb, hsl = _ref.hsl, hsv = _ref.hsv, hex = _ref.hex, renderers = _ref.renderers, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className, defaultView = _ref.defaultView;
  var styles = _default$2(merge$2({
    "default": {
      picker: {
        width,
        background: "#fff",
        borderRadius: "2px",
        boxShadow: "0 0 2px rgba(0,0,0,.3), 0 4px 8px rgba(0,0,0,.3)",
        boxSizing: "initial",
        fontFamily: "Menlo"
      },
      saturation: {
        width: "100%",
        paddingBottom: "55%",
        position: "relative",
        borderRadius: "2px 2px 0 0",
        overflow: "hidden"
      },
      Saturation: {
        radius: "2px 2px 0 0"
      },
      body: {
        padding: "16px 16px 12px"
      },
      controls: {
        display: "flex"
      },
      color: {
        width: "32px"
      },
      swatch: {
        marginTop: "6px",
        width: "16px",
        height: "16px",
        borderRadius: "8px",
        position: "relative",
        overflow: "hidden"
      },
      active: {
        absolute: "0px 0px 0px 0px",
        borderRadius: "8px",
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,.1)",
        background: "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", " + rgb.a + ")",
        zIndex: "2"
      },
      toggles: {
        flex: "1"
      },
      hue: {
        height: "10px",
        position: "relative",
        marginBottom: "8px"
      },
      Hue: {
        radius: "2px"
      },
      alpha: {
        height: "10px",
        position: "relative"
      },
      Alpha: {
        radius: "2px"
      }
    },
    "disableAlpha": {
      color: {
        width: "22px"
      },
      alpha: {
        display: "none"
      },
      hue: {
        marginBottom: "0px"
      },
      swatch: {
        width: "10px",
        height: "10px",
        marginTop: "0px"
      }
    }
  }, passedStyles), { disableAlpha });
  return React__default.createElement(
    "div",
    { style: styles.picker, className: "chrome-picker " + className },
    React__default.createElement(
      "div",
      { style: styles.saturation },
      React__default.createElement(Saturation, {
        style: styles.Saturation,
        hsl,
        hsv,
        pointer: ChromePointerCircle,
        onChange
      })
    ),
    React__default.createElement(
      "div",
      { style: styles.body },
      React__default.createElement(
        "div",
        { style: styles.controls, className: "flexbox-fix" },
        React__default.createElement(
          "div",
          { style: styles.color },
          React__default.createElement(
            "div",
            { style: styles.swatch },
            React__default.createElement("div", { style: styles.active }),
            React__default.createElement(Checkboard, { renderers })
          )
        ),
        React__default.createElement(
          "div",
          { style: styles.toggles },
          React__default.createElement(
            "div",
            { style: styles.hue },
            React__default.createElement(Hue, {
              style: styles.Hue,
              hsl,
              pointer: ChromePointer,
              onChange
            })
          ),
          React__default.createElement(
            "div",
            { style: styles.alpha },
            React__default.createElement(Alpha, {
              style: styles.Alpha,
              rgb,
              hsl,
              pointer: ChromePointer,
              renderers,
              onChange
            })
          )
        )
      ),
      React__default.createElement(ChromeFields, {
        rgb,
        hsl,
        hex,
        view: defaultView,
        onChange,
        disableAlpha
      })
    )
  );
};
Chrome.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  disableAlpha: PropTypes.bool,
  styles: PropTypes.object,
  defaultView: PropTypes.oneOf(["hex", "rgb", "hsl"])
};
Chrome.defaultProps = {
  width: 225,
  disableAlpha: false,
  styles: {}
};
ColorWrap(Chrome);
var CompactColor = function CompactColor2(_ref) {
  var color = _ref.color, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onSwatchHover = _ref.onSwatchHover, active3 = _ref.active;
  var styles = _default$2({
    "default": {
      color: {
        background: color,
        width: "15px",
        height: "15px",
        float: "left",
        marginRight: "5px",
        marginBottom: "5px",
        position: "relative",
        cursor: "pointer"
      },
      dot: {
        absolute: "5px 5px 5px 5px",
        background: getContrastingColor(color),
        borderRadius: "50%",
        opacity: "0"
      }
    },
    "active": {
      dot: {
        opacity: "1"
      }
    },
    "color-#FFFFFF": {
      color: {
        boxShadow: "inset 0 0 0 1px #ddd"
      },
      dot: {
        background: "#000"
      }
    },
    "transparent": {
      dot: {
        background: "#000"
      }
    }
  }, { active: active3, "color-#FFFFFF": color === "#FFFFFF", "transparent": color === "transparent" });
  return React__default.createElement(
    Swatch$1,
    {
      style: styles.color,
      color,
      onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: "0 0 4px " + color }
    },
    React__default.createElement("div", { style: styles.dot })
  );
};
var CompactFields = function CompactFields2(_ref) {
  var hex = _ref.hex, rgb = _ref.rgb, onChange = _ref.onChange;
  var styles = _default$2({
    "default": {
      fields: {
        display: "flex",
        paddingBottom: "6px",
        paddingRight: "5px",
        position: "relative"
      },
      active: {
        position: "absolute",
        top: "6px",
        left: "5px",
        height: "9px",
        width: "9px",
        background: hex
      },
      HEXwrap: {
        flex: "6",
        position: "relative"
      },
      HEXinput: {
        width: "80%",
        padding: "0px",
        paddingLeft: "20%",
        border: "none",
        outline: "none",
        background: "none",
        fontSize: "12px",
        color: "#333",
        height: "16px"
      },
      HEXlabel: {
        display: "none"
      },
      RGBwrap: {
        flex: "3",
        position: "relative"
      },
      RGBinput: {
        width: "70%",
        padding: "0px",
        paddingLeft: "30%",
        border: "none",
        outline: "none",
        background: "none",
        fontSize: "12px",
        color: "#333",
        height: "16px"
      },
      RGBlabel: {
        position: "absolute",
        top: "3px",
        left: "0px",
        lineHeight: "16px",
        textTransform: "uppercase",
        fontSize: "12px",
        color: "#999"
      }
    }
  });
  var handleChange = function handleChange2(data, e) {
    if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: "rgb"
      }, e);
    } else {
      onChange({
        hex: data.hex,
        source: "hex"
      }, e);
    }
  };
  return React__default.createElement(
    "div",
    { style: styles.fields, className: "flexbox-fix" },
    React__default.createElement("div", { style: styles.active }),
    React__default.createElement(EditableInput, {
      style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
      label: "hex",
      value: hex,
      onChange: handleChange
    }),
    React__default.createElement(EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: "r",
      value: rgb.r,
      onChange: handleChange
    }),
    React__default.createElement(EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: "g",
      value: rgb.g,
      onChange: handleChange
    }),
    React__default.createElement(EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: "b",
      value: rgb.b,
      onChange: handleChange
    })
  );
};
var Compact = function Compact2(_ref) {
  var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors = _ref.colors, hex = _ref.hex, rgb = _ref.rgb, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$2({
    "default": {
      Compact: {
        background: "#f6f6f6",
        radius: "4px"
      },
      compact: {
        paddingTop: "5px",
        paddingLeft: "5px",
        boxSizing: "initial",
        width: "240px"
      },
      clear: {
        clear: "both"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data, e) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e);
    } else {
      onChange(data, e);
    }
  };
  return React__default.createElement(
    Raised,
    { style: styles.Compact, styles: passedStyles },
    React__default.createElement(
      "div",
      { style: styles.compact, className: "compact-picker " + className },
      React__default.createElement(
        "div",
        null,
        map(colors, function(c) {
          return React__default.createElement(CompactColor, {
            key: c,
            color: c,
            active: c.toLowerCase() === hex,
            onClick: handleChange,
            onSwatchHover
          });
        }),
        React__default.createElement("div", { style: styles.clear })
      ),
      React__default.createElement(CompactFields, { hex, rgb, onChange: handleChange })
    )
  );
};
Compact.propTypes = {
  colors: PropTypes.arrayOf(PropTypes.string),
  styles: PropTypes.object
};
Compact.defaultProps = {
  colors: ["#4D4D4D", "#999999", "#FFFFFF", "#F44E3B", "#FE9200", "#FCDC00", "#DBDF00", "#A4DD00", "#68CCCA", "#73D8FF", "#AEA1FF", "#FDA1FF", "#333333", "#808080", "#cccccc", "#D33115", "#E27300", "#FCC400", "#B0BC00", "#68BC00", "#16A5A5", "#009CE0", "#7B64FF", "#FA28FF", "#000000", "#666666", "#B3B3B3", "#9F0500", "#C45100", "#FB9E00", "#808900", "#194D33", "#0C797D", "#0062B1", "#653294", "#AB149E"],
  styles: {}
};
var CompactPicker = ColorWrap(Compact);
var GithubSwatch = function GithubSwatch2(_ref) {
  var hover3 = _ref.hover, color = _ref.color, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover;
  var hoverSwatch = {
    position: "relative",
    zIndex: "2",
    outline: "2px solid #fff",
    boxShadow: "0 0 5px 2px rgba(0,0,0,0.25)"
  };
  var styles = _default$2({
    "default": {
      swatch: {
        width: "25px",
        height: "25px",
        fontSize: "0"
      }
    },
    "hover": {
      swatch: hoverSwatch
    }
  }, { hover: hover3 });
  return React__default.createElement(
    "div",
    { style: styles.swatch },
    React__default.createElement(Swatch$1, {
      color,
      onClick,
      onHover: onSwatchHover,
      focusStyle: hoverSwatch
    })
  );
};
var GithubSwatch$1 = handleHover(GithubSwatch);
var Github = function Github2(_ref) {
  var width = _ref.width, colors = _ref.colors, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$2({
    "default": {
      card: {
        width,
        background: "#fff",
        border: "1px solid rgba(0,0,0,0.2)",
        boxShadow: "0 3px 12px rgba(0,0,0,0.15)",
        borderRadius: "4px",
        position: "relative",
        padding: "5px",
        display: "flex",
        flexWrap: "wrap"
      },
      triangle: {
        position: "absolute",
        border: "7px solid transparent",
        borderBottomColor: "#fff"
      },
      triangleShadow: {
        position: "absolute",
        border: "8px solid transparent",
        borderBottomColor: "rgba(0,0,0,0.15)"
      }
    },
    "hide-triangle": {
      triangle: {
        display: "none"
      },
      triangleShadow: {
        display: "none"
      }
    },
    "top-left-triangle": {
      triangle: {
        top: "-14px",
        left: "10px"
      },
      triangleShadow: {
        top: "-16px",
        left: "9px"
      }
    },
    "top-right-triangle": {
      triangle: {
        top: "-14px",
        right: "10px"
      },
      triangleShadow: {
        top: "-16px",
        right: "9px"
      }
    },
    "bottom-left-triangle": {
      triangle: {
        top: "35px",
        left: "10px",
        transform: "rotate(180deg)"
      },
      triangleShadow: {
        top: "37px",
        left: "9px",
        transform: "rotate(180deg)"
      }
    },
    "bottom-right-triangle": {
      triangle: {
        top: "35px",
        right: "10px",
        transform: "rotate(180deg)"
      },
      triangleShadow: {
        top: "37px",
        right: "9px",
        transform: "rotate(180deg)"
      }
    }
  }, passedStyles), {
    "hide-triangle": triangle === "hide",
    "top-left-triangle": triangle === "top-left",
    "top-right-triangle": triangle === "top-right",
    "bottom-left-triangle": triangle === "bottom-left",
    "bottom-right-triangle": triangle === "bottom-right"
  });
  var handleChange = function handleChange2(hex, e) {
    return onChange({ hex, source: "hex" }, e);
  };
  return React__default.createElement(
    "div",
    { style: styles.card, className: "github-picker " + className },
    React__default.createElement("div", { style: styles.triangleShadow }),
    React__default.createElement("div", { style: styles.triangle }),
    map(colors, function(c) {
      return React__default.createElement(GithubSwatch$1, {
        color: c,
        key: c,
        onClick: handleChange,
        onSwatchHover
      });
    })
  );
};
Github.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  colors: PropTypes.arrayOf(PropTypes.string),
  triangle: PropTypes.oneOf(["hide", "top-left", "top-right", "bottom-left", "bottom-right"]),
  styles: PropTypes.object
};
Github.defaultProps = {
  width: 200,
  colors: ["#B80000", "#DB3E00", "#FCCB00", "#008B02", "#006B76", "#1273DE", "#004DCF", "#5300EB", "#EB9694", "#FAD0C3", "#FEF3BD", "#C1E1C5", "#BEDADC", "#C4DEF6", "#BED3F3", "#D4C4FB"],
  triangle: "top-left",
  styles: {}
};
ColorWrap(Github);
var SliderPointer$1 = function SliderPointer(_ref) {
  var direction = _ref.direction;
  var styles = _default$2({
    "default": {
      picker: {
        width: "18px",
        height: "18px",
        borderRadius: "50%",
        transform: "translate(-9px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    },
    "vertical": {
      picker: {
        transform: "translate(-3px, -9px)"
      }
    }
  }, { vertical: direction === "vertical" });
  return React__default.createElement("div", { style: styles.picker });
};
var _extends$5 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var HuePicker = function HuePicker2(_ref) {
  var width = _ref.width, height = _ref.height, onChange = _ref.onChange, hsl = _ref.hsl, direction = _ref.direction, pointer = _ref.pointer, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$2({
    "default": {
      picker: {
        position: "relative",
        width,
        height
      },
      hue: {
        radius: "2px"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data) {
    return onChange({ a: 1, h: data.h, l: 0.5, s: 1 });
  };
  return React__default.createElement(
    "div",
    { style: styles.picker, className: "hue-picker " + className },
    React__default.createElement(Hue, _extends$5({}, styles.hue, {
      hsl,
      pointer,
      onChange: handleChange,
      direction
    }))
  );
};
HuePicker.propTypes = {
  styles: PropTypes.object
};
HuePicker.defaultProps = {
  width: "316px",
  height: "16px",
  direction: "horizontal",
  pointer: SliderPointer$1,
  styles: {}
};
ColorWrap(HuePicker);
var Material = function Material2(_ref) {
  var onChange = _ref.onChange, hex = _ref.hex, rgb = _ref.rgb, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$2({
    "default": {
      material: {
        width: "98px",
        height: "98px",
        padding: "16px",
        fontFamily: "Roboto"
      },
      HEXwrap: {
        position: "relative"
      },
      HEXinput: {
        width: "100%",
        marginTop: "12px",
        fontSize: "15px",
        color: "#333",
        padding: "0px",
        border: "0px",
        borderBottom: "2px solid " + hex,
        outline: "none",
        height: "30px"
      },
      HEXlabel: {
        position: "absolute",
        top: "0px",
        left: "0px",
        fontSize: "11px",
        color: "#999999",
        textTransform: "capitalize"
      },
      Hex: {
        style: {}
      },
      RGBwrap: {
        position: "relative"
      },
      RGBinput: {
        width: "100%",
        marginTop: "12px",
        fontSize: "15px",
        color: "#333",
        padding: "0px",
        border: "0px",
        borderBottom: "1px solid #eee",
        outline: "none",
        height: "30px"
      },
      RGBlabel: {
        position: "absolute",
        top: "0px",
        left: "0px",
        fontSize: "11px",
        color: "#999999",
        textTransform: "capitalize"
      },
      split: {
        display: "flex",
        marginRight: "-10px",
        paddingTop: "11px"
      },
      third: {
        flex: "1",
        paddingRight: "10px"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data, e) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: "rgb"
      }, e);
    }
  };
  return React__default.createElement(
    Raised,
    { styles: passedStyles },
    React__default.createElement(
      "div",
      { style: styles.material, className: "material-picker " + className },
      React__default.createElement(EditableInput, {
        style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
        label: "hex",
        value: hex,
        onChange: handleChange
      }),
      React__default.createElement(
        "div",
        { style: styles.split, className: "flexbox-fix" },
        React__default.createElement(
          "div",
          { style: styles.third },
          React__default.createElement(EditableInput, {
            style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
            label: "r",
            value: rgb.r,
            onChange: handleChange
          })
        ),
        React__default.createElement(
          "div",
          { style: styles.third },
          React__default.createElement(EditableInput, {
            style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
            label: "g",
            value: rgb.g,
            onChange: handleChange
          })
        ),
        React__default.createElement(
          "div",
          { style: styles.third },
          React__default.createElement(EditableInput, {
            style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
            label: "b",
            value: rgb.b,
            onChange: handleChange
          })
        )
      )
    )
  );
};
ColorWrap(Material);
var PhotoshopPicker = function PhotoshopPicker2(_ref) {
  var onChange = _ref.onChange, rgb = _ref.rgb, hsv = _ref.hsv, hex = _ref.hex;
  var styles = _default$2({
    "default": {
      fields: {
        paddingTop: "5px",
        paddingBottom: "9px",
        width: "80px",
        position: "relative"
      },
      divider: {
        height: "5px"
      },
      RGBwrap: {
        position: "relative"
      },
      RGBinput: {
        marginLeft: "40%",
        width: "40%",
        height: "18px",
        border: "1px solid #888888",
        boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
        marginBottom: "5px",
        fontSize: "13px",
        paddingLeft: "3px",
        marginRight: "10px"
      },
      RGBlabel: {
        left: "0px",
        top: "0px",
        width: "34px",
        textTransform: "uppercase",
        fontSize: "13px",
        height: "18px",
        lineHeight: "22px",
        position: "absolute"
      },
      HEXwrap: {
        position: "relative"
      },
      HEXinput: {
        marginLeft: "20%",
        width: "80%",
        height: "18px",
        border: "1px solid #888888",
        boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
        marginBottom: "6px",
        fontSize: "13px",
        paddingLeft: "3px"
      },
      HEXlabel: {
        position: "absolute",
        top: "0px",
        left: "0px",
        width: "14px",
        textTransform: "uppercase",
        fontSize: "13px",
        height: "18px",
        lineHeight: "22px"
      },
      fieldSymbols: {
        position: "absolute",
        top: "5px",
        right: "-7px",
        fontSize: "13px"
      },
      symbol: {
        height: "20px",
        lineHeight: "22px",
        paddingBottom: "7px"
      }
    }
  });
  var handleChange = function handleChange2(data, e) {
    if (data["#"]) {
      isValidHex(data["#"]) && onChange({
        hex: data["#"],
        source: "hex"
      }, e);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: "rgb"
      }, e);
    } else if (data.h || data.s || data.v) {
      onChange({
        h: data.h || hsv.h,
        s: data.s || hsv.s,
        v: data.v || hsv.v,
        source: "hsv"
      }, e);
    }
  };
  return React__default.createElement(
    "div",
    { style: styles.fields },
    React__default.createElement(EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: "h",
      value: Math.round(hsv.h),
      onChange: handleChange
    }),
    React__default.createElement(EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: "s",
      value: Math.round(hsv.s * 100),
      onChange: handleChange
    }),
    React__default.createElement(EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: "v",
      value: Math.round(hsv.v * 100),
      onChange: handleChange
    }),
    React__default.createElement("div", { style: styles.divider }),
    React__default.createElement(EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: "r",
      value: rgb.r,
      onChange: handleChange
    }),
    React__default.createElement(EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: "g",
      value: rgb.g,
      onChange: handleChange
    }),
    React__default.createElement(EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: "b",
      value: rgb.b,
      onChange: handleChange
    }),
    React__default.createElement("div", { style: styles.divider }),
    React__default.createElement(EditableInput, {
      style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
      label: "#",
      value: hex.replace("#", ""),
      onChange: handleChange
    }),
    React__default.createElement(
      "div",
      { style: styles.fieldSymbols },
      React__default.createElement(
        "div",
        { style: styles.symbol },
        "\xB0"
      ),
      React__default.createElement(
        "div",
        { style: styles.symbol },
        "%"
      ),
      React__default.createElement(
        "div",
        { style: styles.symbol },
        "%"
      )
    )
  );
};
var PhotoshopPointerCircle$1 = function PhotoshopPointerCircle(_ref) {
  var hsl = _ref.hsl;
  var styles = _default$2({
    "default": {
      picker: {
        width: "12px",
        height: "12px",
        borderRadius: "6px",
        boxShadow: "inset 0 0 0 1px #fff",
        transform: "translate(-6px, -6px)"
      }
    },
    "black-outline": {
      picker: {
        boxShadow: "inset 0 0 0 1px #000"
      }
    }
  }, { "black-outline": hsl.l > 0.5 });
  return React__default.createElement("div", { style: styles.picker });
};
var PhotoshopPointerCircle2 = function PhotoshopPointerCircle3() {
  var styles = _default$2({
    "default": {
      triangle: {
        width: 0,
        height: 0,
        borderStyle: "solid",
        borderWidth: "4px 0 4px 6px",
        borderColor: "transparent transparent transparent #fff",
        position: "absolute",
        top: "1px",
        left: "1px"
      },
      triangleBorder: {
        width: 0,
        height: 0,
        borderStyle: "solid",
        borderWidth: "5px 0 5px 8px",
        borderColor: "transparent transparent transparent #555"
      },
      left: {
        Extend: "triangleBorder",
        transform: "translate(-13px, -4px)"
      },
      leftInside: {
        Extend: "triangle",
        transform: "translate(-8px, -5px)"
      },
      right: {
        Extend: "triangleBorder",
        transform: "translate(20px, -14px) rotate(180deg)"
      },
      rightInside: {
        Extend: "triangle",
        transform: "translate(-8px, -5px)"
      }
    }
  });
  return React__default.createElement(
    "div",
    { style: styles.pointer },
    React__default.createElement(
      "div",
      { style: styles.left },
      React__default.createElement("div", { style: styles.leftInside })
    ),
    React__default.createElement(
      "div",
      { style: styles.right },
      React__default.createElement("div", { style: styles.rightInside })
    )
  );
};
var PhotoshopButton = function PhotoshopButton2(_ref) {
  var onClick = _ref.onClick, label = _ref.label, children = _ref.children, active3 = _ref.active;
  var styles = _default$2({
    "default": {
      button: {
        backgroundImage: "linear-gradient(-180deg, #FFFFFF 0%, #E6E6E6 100%)",
        border: "1px solid #878787",
        borderRadius: "2px",
        height: "20px",
        boxShadow: "0 1px 0 0 #EAEAEA",
        fontSize: "14px",
        color: "#000",
        lineHeight: "20px",
        textAlign: "center",
        marginBottom: "10px",
        cursor: "pointer"
      }
    },
    "active": {
      button: {
        boxShadow: "0 0 0 1px #878787"
      }
    }
  }, { active: active3 });
  return React__default.createElement(
    "div",
    { style: styles.button, onClick },
    label || children
  );
};
var PhotoshopPreviews = function PhotoshopPreviews2(_ref) {
  var rgb = _ref.rgb, currentColor = _ref.currentColor;
  var styles = _default$2({
    "default": {
      swatches: {
        border: "1px solid #B3B3B3",
        borderBottom: "1px solid #F0F0F0",
        marginBottom: "2px",
        marginTop: "1px"
      },
      new: {
        height: "34px",
        background: "rgb(" + rgb.r + "," + rgb.g + ", " + rgb.b + ")",
        boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 1px 0 #000"
      },
      current: {
        height: "34px",
        background: currentColor,
        boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 -1px 0 #000"
      },
      label: {
        fontSize: "14px",
        color: "#000",
        textAlign: "center"
      }
    }
  });
  return React__default.createElement(
    "div",
    null,
    React__default.createElement(
      "div",
      { style: styles.label },
      "new"
    ),
    React__default.createElement(
      "div",
      { style: styles.swatches },
      React__default.createElement("div", { style: styles.new }),
      React__default.createElement("div", { style: styles.current })
    ),
    React__default.createElement(
      "div",
      { style: styles.label },
      "current"
    )
  );
};
var _createClass$1 = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Photoshop = function(_React$Component) {
  _inherits(Photoshop2, _React$Component);
  function Photoshop2(props) {
    _classCallCheck(this, Photoshop2);
    var _this = _possibleConstructorReturn(this, (Photoshop2.__proto__ || Object.getPrototypeOf(Photoshop2)).call(this));
    _this.state = {
      currentColor: props.hex
    };
    return _this;
  }
  _createClass$1(Photoshop2, [{
    key: "render",
    value: function render3() {
      var _props = this.props, _props$styles = _props.styles, passedStyles = _props$styles === void 0 ? {} : _props$styles, _props$className = _props.className, className = _props$className === void 0 ? "" : _props$className;
      var styles = _default$2(merge$2({
        "default": {
          picker: {
            background: "#DCDCDC",
            borderRadius: "4px",
            boxShadow: "0 0 0 1px rgba(0,0,0,.25), 0 8px 16px rgba(0,0,0,.15)",
            boxSizing: "initial",
            width: "513px"
          },
          head: {
            backgroundImage: "linear-gradient(-180deg, #F0F0F0 0%, #D4D4D4 100%)",
            borderBottom: "1px solid #B1B1B1",
            boxShadow: "inset 0 1px 0 0 rgba(255,255,255,.2), inset 0 -1px 0 0 rgba(0,0,0,.02)",
            height: "23px",
            lineHeight: "24px",
            borderRadius: "4px 4px 0 0",
            fontSize: "13px",
            color: "#4D4D4D",
            textAlign: "center"
          },
          body: {
            padding: "15px 15px 0",
            display: "flex"
          },
          saturation: {
            width: "256px",
            height: "256px",
            position: "relative",
            border: "2px solid #B3B3B3",
            borderBottom: "2px solid #F0F0F0",
            overflow: "hidden"
          },
          hue: {
            position: "relative",
            height: "256px",
            width: "19px",
            marginLeft: "10px",
            border: "2px solid #B3B3B3",
            borderBottom: "2px solid #F0F0F0"
          },
          controls: {
            width: "180px",
            marginLeft: "10px"
          },
          top: {
            display: "flex"
          },
          previews: {
            width: "60px"
          },
          actions: {
            flex: "1",
            marginLeft: "20px"
          }
        }
      }, passedStyles));
      return React__default.createElement(
        "div",
        { style: styles.picker, className: "photoshop-picker " + className },
        React__default.createElement(
          "div",
          { style: styles.head },
          this.props.header
        ),
        React__default.createElement(
          "div",
          { style: styles.body, className: "flexbox-fix" },
          React__default.createElement(
            "div",
            { style: styles.saturation },
            React__default.createElement(Saturation, {
              hsl: this.props.hsl,
              hsv: this.props.hsv,
              pointer: PhotoshopPointerCircle$1,
              onChange: this.props.onChange
            })
          ),
          React__default.createElement(
            "div",
            { style: styles.hue },
            React__default.createElement(Hue, {
              direction: "vertical",
              hsl: this.props.hsl,
              pointer: PhotoshopPointerCircle2,
              onChange: this.props.onChange
            })
          ),
          React__default.createElement(
            "div",
            { style: styles.controls },
            React__default.createElement(
              "div",
              { style: styles.top, className: "flexbox-fix" },
              React__default.createElement(
                "div",
                { style: styles.previews },
                React__default.createElement(PhotoshopPreviews, {
                  rgb: this.props.rgb,
                  currentColor: this.state.currentColor
                })
              ),
              React__default.createElement(
                "div",
                { style: styles.actions },
                React__default.createElement(PhotoshopButton, { label: "OK", onClick: this.props.onAccept, active: true }),
                React__default.createElement(PhotoshopButton, { label: "Cancel", onClick: this.props.onCancel }),
                React__default.createElement(PhotoshopPicker, {
                  onChange: this.props.onChange,
                  rgb: this.props.rgb,
                  hsv: this.props.hsv,
                  hex: this.props.hex
                })
              )
            )
          )
        )
      );
    }
  }]);
  return Photoshop2;
}(React__default.Component);
Photoshop.propTypes = {
  header: PropTypes.string,
  styles: PropTypes.object
};
Photoshop.defaultProps = {
  header: "Color Picker",
  styles: {}
};
ColorWrap(Photoshop);
var SketchFields = function SketchFields2(_ref) {
  var onChange = _ref.onChange, rgb = _ref.rgb, hsl = _ref.hsl, hex = _ref.hex, disableAlpha = _ref.disableAlpha;
  var styles = _default$2({
    "default": {
      fields: {
        display: "flex",
        paddingTop: "4px"
      },
      single: {
        flex: "1",
        paddingLeft: "6px"
      },
      alpha: {
        flex: "1",
        paddingLeft: "6px"
      },
      double: {
        flex: "2"
      },
      input: {
        width: "80%",
        padding: "4px 10% 3px",
        border: "none",
        boxShadow: "inset 0 0 0 1px #ccc",
        fontSize: "11px"
      },
      label: {
        display: "block",
        textAlign: "center",
        fontSize: "11px",
        color: "#222",
        paddingTop: "3px",
        paddingBottom: "4px",
        textTransform: "capitalize"
      }
    },
    "disableAlpha": {
      alpha: {
        display: "none"
      }
    }
  }, { disableAlpha });
  var handleChange = function handleChange2(data, e) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        a: rgb.a,
        source: "rgb"
      }, e);
    } else if (data.a) {
      if (data.a < 0) {
        data.a = 0;
      } else if (data.a > 100) {
        data.a = 100;
      }
      data.a /= 100;
      onChange({
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: data.a,
        source: "rgb"
      }, e);
    }
  };
  return React__default.createElement(
    "div",
    { style: styles.fields, className: "flexbox-fix" },
    React__default.createElement(
      "div",
      { style: styles.double },
      React__default.createElement(EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: "hex",
        value: hex.replace("#", ""),
        onChange: handleChange
      })
    ),
    React__default.createElement(
      "div",
      { style: styles.single },
      React__default.createElement(EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: "r",
        value: rgb.r,
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "255"
      })
    ),
    React__default.createElement(
      "div",
      { style: styles.single },
      React__default.createElement(EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: "g",
        value: rgb.g,
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "255"
      })
    ),
    React__default.createElement(
      "div",
      { style: styles.single },
      React__default.createElement(EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: "b",
        value: rgb.b,
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "255"
      })
    ),
    React__default.createElement(
      "div",
      { style: styles.alpha },
      React__default.createElement(EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: "a",
        value: Math.round(rgb.a * 100),
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "100"
      })
    )
  );
};
var _extends$4 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var SketchPresetColors = function SketchPresetColors2(_ref) {
  var colors = _ref.colors, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onSwatchHover = _ref.onSwatchHover;
  var styles = _default$2({
    "default": {
      colors: {
        margin: "0 -10px",
        padding: "10px 0 0 10px",
        borderTop: "1px solid #eee",
        display: "flex",
        flexWrap: "wrap",
        position: "relative"
      },
      swatchWrap: {
        width: "16px",
        height: "16px",
        margin: "0 10px 10px 0"
      },
      swatch: {
        borderRadius: "3px",
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15)"
      }
    },
    "no-presets": {
      colors: {
        display: "none"
      }
    }
  }, {
    "no-presets": !colors || !colors.length
  });
  var handleClick = function handleClick2(hex, e) {
    onClick({
      hex,
      source: "hex"
    }, e);
  };
  return React__default.createElement(
    "div",
    { style: styles.colors, className: "flexbox-fix" },
    colors.map(function(colorObjOrString) {
      var c = typeof colorObjOrString === "string" ? { color: colorObjOrString } : colorObjOrString;
      var key = "" + c.color + (c.title || "");
      return React__default.createElement(
        "div",
        { key, style: styles.swatchWrap },
        React__default.createElement(Swatch$1, _extends$4({}, c, {
          style: styles.swatch,
          onClick: handleClick,
          onHover: onSwatchHover,
          focusStyle: {
            boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), 0 0 4px " + c.color
          }
        }))
      );
    })
  );
};
SketchPresetColors.propTypes = {
  colors: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
    color: PropTypes.string,
    title: PropTypes.string
  })])).isRequired
};
var _extends$3 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var Sketch = function Sketch2(_ref) {
  var width = _ref.width, rgb = _ref.rgb, hex = _ref.hex, hsv = _ref.hsv, hsl = _ref.hsl, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, disableAlpha = _ref.disableAlpha, presetColors = _ref.presetColors, renderers = _ref.renderers, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$2({
    "default": _extends$3({
      picker: {
        width,
        padding: "10px 10px 0",
        boxSizing: "initial",
        background: "#fff",
        borderRadius: "4px",
        boxShadow: "0 0 0 1px rgba(0,0,0,.15), 0 8px 16px rgba(0,0,0,.15)"
      },
      saturation: {
        width: "100%",
        paddingBottom: "75%",
        position: "relative",
        overflow: "hidden"
      },
      Saturation: {
        radius: "3px",
        shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      },
      controls: {
        display: "flex"
      },
      sliders: {
        padding: "4px 0",
        flex: "1"
      },
      color: {
        width: "24px",
        height: "24px",
        position: "relative",
        marginTop: "4px",
        marginLeft: "4px",
        borderRadius: "3px"
      },
      activeColor: {
        absolute: "0px 0px 0px 0px",
        borderRadius: "2px",
        background: "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + rgb.a + ")",
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      },
      hue: {
        position: "relative",
        height: "10px",
        overflow: "hidden"
      },
      Hue: {
        radius: "2px",
        shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      },
      alpha: {
        position: "relative",
        height: "10px",
        marginTop: "4px",
        overflow: "hidden"
      },
      Alpha: {
        radius: "2px",
        shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      }
    }, passedStyles),
    "disableAlpha": {
      color: {
        height: "10px"
      },
      hue: {
        height: "10px"
      },
      alpha: {
        display: "none"
      }
    }
  }, passedStyles), { disableAlpha });
  return React__default.createElement(
    "div",
    { style: styles.picker, className: "sketch-picker " + className },
    React__default.createElement(
      "div",
      { style: styles.saturation },
      React__default.createElement(Saturation, {
        style: styles.Saturation,
        hsl,
        hsv,
        onChange
      })
    ),
    React__default.createElement(
      "div",
      { style: styles.controls, className: "flexbox-fix" },
      React__default.createElement(
        "div",
        { style: styles.sliders },
        React__default.createElement(
          "div",
          { style: styles.hue },
          React__default.createElement(Hue, {
            style: styles.Hue,
            hsl,
            onChange
          })
        ),
        React__default.createElement(
          "div",
          { style: styles.alpha },
          React__default.createElement(Alpha, {
            style: styles.Alpha,
            rgb,
            hsl,
            renderers,
            onChange
          })
        )
      ),
      React__default.createElement(
        "div",
        { style: styles.color },
        React__default.createElement(Checkboard, null),
        React__default.createElement("div", { style: styles.activeColor })
      )
    ),
    React__default.createElement(SketchFields, {
      rgb,
      hsl,
      hex,
      onChange,
      disableAlpha
    }),
    React__default.createElement(SketchPresetColors, {
      colors: presetColors,
      onClick: onChange,
      onSwatchHover
    })
  );
};
Sketch.propTypes = {
  disableAlpha: PropTypes.bool,
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  styles: PropTypes.object
};
Sketch.defaultProps = {
  disableAlpha: false,
  width: 200,
  styles: {},
  presetColors: ["#D0021B", "#F5A623", "#F8E71C", "#8B572A", "#7ED321", "#417505", "#BD10E0", "#9013FE", "#4A90E2", "#50E3C2", "#B8E986", "#000000", "#4A4A4A", "#9B9B9B", "#FFFFFF"]
};
var SketchPicker = ColorWrap(Sketch);
var SliderSwatch = function SliderSwatch2(_ref) {
  var hsl = _ref.hsl, offset2 = _ref.offset, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, active3 = _ref.active, first = _ref.first, last = _ref.last;
  var styles = _default$2({
    "default": {
      swatch: {
        height: "12px",
        background: "hsl(" + hsl.h + ", 50%, " + offset2 * 100 + "%)",
        cursor: "pointer"
      }
    },
    "first": {
      swatch: {
        borderRadius: "2px 0 0 2px"
      }
    },
    "last": {
      swatch: {
        borderRadius: "0 2px 2px 0"
      }
    },
    "active": {
      swatch: {
        transform: "scaleY(1.8)",
        borderRadius: "3.6px/2px"
      }
    }
  }, { active: active3, first, last });
  var handleClick = function handleClick2(e) {
    return onClick({
      h: hsl.h,
      s: 0.5,
      l: offset2,
      source: "hsl"
    }, e);
  };
  return React__default.createElement("div", { style: styles.swatch, onClick: handleClick });
};
var SliderSwatches = function SliderSwatches2(_ref) {
  var onClick = _ref.onClick, hsl = _ref.hsl;
  var styles = _default$2({
    "default": {
      swatches: {
        marginTop: "20px"
      },
      swatch: {
        boxSizing: "border-box",
        width: "20%",
        paddingRight: "1px",
        float: "left"
      },
      clear: {
        clear: "both"
      }
    }
  });
  var epsilon = 0.1;
  return React__default.createElement(
    "div",
    { style: styles.swatches },
    React__default.createElement(
      "div",
      { style: styles.swatch },
      React__default.createElement(SliderSwatch, {
        hsl,
        offset: ".80",
        active: Math.abs(hsl.l - 0.8) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick,
        first: true
      })
    ),
    React__default.createElement(
      "div",
      { style: styles.swatch },
      React__default.createElement(SliderSwatch, {
        hsl,
        offset: ".65",
        active: Math.abs(hsl.l - 0.65) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick
      })
    ),
    React__default.createElement(
      "div",
      { style: styles.swatch },
      React__default.createElement(SliderSwatch, {
        hsl,
        offset: ".50",
        active: Math.abs(hsl.l - 0.5) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick
      })
    ),
    React__default.createElement(
      "div",
      { style: styles.swatch },
      React__default.createElement(SliderSwatch, {
        hsl,
        offset: ".35",
        active: Math.abs(hsl.l - 0.35) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick
      })
    ),
    React__default.createElement(
      "div",
      { style: styles.swatch },
      React__default.createElement(SliderSwatch, {
        hsl,
        offset: ".20",
        active: Math.abs(hsl.l - 0.2) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick,
        last: true
      })
    ),
    React__default.createElement("div", { style: styles.clear })
  );
};
var SliderPointer2 = function SliderPointer3() {
  var styles = _default$2({
    "default": {
      picker: {
        width: "14px",
        height: "14px",
        borderRadius: "6px",
        transform: "translate(-7px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    }
  });
  return React__default.createElement("div", { style: styles.picker });
};
var Slider = function Slider2(_ref) {
  var hsl = _ref.hsl, onChange = _ref.onChange, pointer = _ref.pointer, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$2({
    "default": {
      hue: {
        height: "12px",
        position: "relative"
      },
      Hue: {
        radius: "2px"
      }
    }
  }, passedStyles));
  return React__default.createElement(
    "div",
    { style: styles.wrap || {}, className: "slider-picker " + className },
    React__default.createElement(
      "div",
      { style: styles.hue },
      React__default.createElement(Hue, {
        style: styles.Hue,
        hsl,
        pointer,
        onChange
      })
    ),
    React__default.createElement(
      "div",
      { style: styles.swatches },
      React__default.createElement(SliderSwatches, { hsl, onClick: onChange })
    )
  );
};
Slider.propTypes = {
  styles: PropTypes.object
};
Slider.defaultProps = {
  pointer: SliderPointer2,
  styles: {}
};
ColorWrap(Slider);
var CheckIcon = {};
Object.defineProperty(CheckIcon, "__esModule", {
  value: true
});
var _extends$2 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _react = React__default;
var _react2 = _interopRequireDefault(_react);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _objectWithoutProperties$1(obj, keys2) {
  var target = {};
  for (var i in obj) {
    if (keys2.indexOf(i) >= 0)
      continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i))
      continue;
    target[i] = obj[i];
  }
  return target;
}
var DEFAULT_SIZE = 24;
var _default = CheckIcon.default = function(_ref) {
  var _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "currentColor" : _ref$fill, _ref$width = _ref.width, width = _ref$width === void 0 ? DEFAULT_SIZE : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? DEFAULT_SIZE : _ref$height, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, props = _objectWithoutProperties$1(_ref, ["fill", "width", "height", "style"]);
  return _react2.default.createElement(
    "svg",
    _extends$2({
      viewBox: "0 0 " + DEFAULT_SIZE + " " + DEFAULT_SIZE,
      style: _extends$2({ fill, width, height }, style)
    }, props),
    _react2.default.createElement("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" })
  );
};
var SwatchesColor = function SwatchesColor2(_ref) {
  var color = _ref.color, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onSwatchHover = _ref.onSwatchHover, first = _ref.first, last = _ref.last, active3 = _ref.active;
  var styles = _default$2({
    "default": {
      color: {
        width: "40px",
        height: "24px",
        cursor: "pointer",
        background: color,
        marginBottom: "1px"
      },
      check: {
        color: getContrastingColor(color),
        marginLeft: "8px",
        display: "none"
      }
    },
    "first": {
      color: {
        overflow: "hidden",
        borderRadius: "2px 2px 0 0"
      }
    },
    "last": {
      color: {
        overflow: "hidden",
        borderRadius: "0 0 2px 2px"
      }
    },
    "active": {
      check: {
        display: "block"
      }
    },
    "color-#FFFFFF": {
      color: {
        boxShadow: "inset 0 0 0 1px #ddd"
      },
      check: {
        color: "#333"
      }
    },
    "transparent": {
      check: {
        color: "#333"
      }
    }
  }, {
    first,
    last,
    active: active3,
    "color-#FFFFFF": color === "#FFFFFF",
    "transparent": color === "transparent"
  });
  return React__default.createElement(
    Swatch$1,
    {
      color,
      style: styles.color,
      onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: "0 0 4px " + color }
    },
    React__default.createElement(
      "div",
      { style: styles.check },
      React__default.createElement(_default, null)
    )
  );
};
var SwatchesGroup = function SwatchesGroup2(_ref) {
  var onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover, group = _ref.group, active3 = _ref.active;
  var styles = _default$2({
    "default": {
      group: {
        paddingBottom: "10px",
        width: "40px",
        float: "left",
        marginRight: "10px"
      }
    }
  });
  return React__default.createElement(
    "div",
    { style: styles.group },
    map(group, function(color, i) {
      return React__default.createElement(SwatchesColor, {
        key: color,
        color,
        active: color.toLowerCase() === active3,
        first: i === 0,
        last: i === group.length - 1,
        onClick,
        onSwatchHover
      });
    })
  );
};
var Swatches = function Swatches2(_ref) {
  var width = _ref.width, height = _ref.height, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors = _ref.colors, hex = _ref.hex, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$2({
    "default": {
      picker: {
        width,
        height
      },
      overflow: {
        height,
        overflowY: "scroll"
      },
      body: {
        padding: "16px 0 6px 16px"
      },
      clear: {
        clear: "both"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data, e) {
    return onChange({ hex: data, source: "hex" }, e);
  };
  return React__default.createElement(
    "div",
    { style: styles.picker, className: "swatches-picker " + className },
    React__default.createElement(
      Raised,
      null,
      React__default.createElement(
        "div",
        { style: styles.overflow },
        React__default.createElement(
          "div",
          { style: styles.body },
          map(colors, function(group) {
            return React__default.createElement(SwatchesGroup, {
              key: group.toString(),
              group,
              active: hex,
              onClick: handleChange,
              onSwatchHover
            });
          }),
          React__default.createElement("div", { style: styles.clear })
        )
      )
    )
  );
};
Swatches.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  colors: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),
  styles: PropTypes.object
};
Swatches.defaultProps = {
  width: 320,
  height: 240,
  colors: [[red["900"], red["700"], red["500"], red["300"], red["100"]], [pink["900"], pink["700"], pink["500"], pink["300"], pink["100"]], [purple["900"], purple["700"], purple["500"], purple["300"], purple["100"]], [deepPurple["900"], deepPurple["700"], deepPurple["500"], deepPurple["300"], deepPurple["100"]], [indigo["900"], indigo["700"], indigo["500"], indigo["300"], indigo["100"]], [blue["900"], blue["700"], blue["500"], blue["300"], blue["100"]], [lightBlue["900"], lightBlue["700"], lightBlue["500"], lightBlue["300"], lightBlue["100"]], [cyan["900"], cyan["700"], cyan["500"], cyan["300"], cyan["100"]], [teal["900"], teal["700"], teal["500"], teal["300"], teal["100"]], ["#194D33", green["700"], green["500"], green["300"], green["100"]], [lightGreen["900"], lightGreen["700"], lightGreen["500"], lightGreen["300"], lightGreen["100"]], [lime["900"], lime["700"], lime["500"], lime["300"], lime["100"]], [yellow["900"], yellow["700"], yellow["500"], yellow["300"], yellow["100"]], [amber["900"], amber["700"], amber["500"], amber["300"], amber["100"]], [orange["900"], orange["700"], orange["500"], orange["300"], orange["100"]], [deepOrange["900"], deepOrange["700"], deepOrange["500"], deepOrange["300"], deepOrange["100"]], [brown["900"], brown["700"], brown["500"], brown["300"], brown["100"]], [blueGrey["900"], blueGrey["700"], blueGrey["500"], blueGrey["300"], blueGrey["100"]], ["#000000", "#525252", "#969696", "#D9D9D9", "#FFFFFF"]],
  styles: {}
};
ColorWrap(Swatches);
var Twitter = function Twitter2(_ref) {
  var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, hex = _ref.hex, colors = _ref.colors, width = _ref.width, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$2({
    "default": {
      card: {
        width,
        background: "#fff",
        border: "0 solid rgba(0,0,0,0.25)",
        boxShadow: "0 1px 4px rgba(0,0,0,0.25)",
        borderRadius: "4px",
        position: "relative"
      },
      body: {
        padding: "15px 9px 9px 15px"
      },
      label: {
        fontSize: "18px",
        color: "#fff"
      },
      triangle: {
        width: "0px",
        height: "0px",
        borderStyle: "solid",
        borderWidth: "0 9px 10px 9px",
        borderColor: "transparent transparent #fff transparent",
        position: "absolute"
      },
      triangleShadow: {
        width: "0px",
        height: "0px",
        borderStyle: "solid",
        borderWidth: "0 9px 10px 9px",
        borderColor: "transparent transparent rgba(0,0,0,.1) transparent",
        position: "absolute"
      },
      hash: {
        background: "#F0F0F0",
        height: "30px",
        width: "30px",
        borderRadius: "4px 0 0 4px",
        float: "left",
        color: "#98A1A4",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      },
      input: {
        width: "100px",
        fontSize: "14px",
        color: "#666",
        border: "0px",
        outline: "none",
        height: "28px",
        boxShadow: "inset 0 0 0 1px #F0F0F0",
        boxSizing: "content-box",
        borderRadius: "0 4px 4px 0",
        float: "left",
        paddingLeft: "8px"
      },
      swatch: {
        width: "30px",
        height: "30px",
        float: "left",
        borderRadius: "4px",
        margin: "0 6px 6px 0"
      },
      clear: {
        clear: "both"
      }
    },
    "hide-triangle": {
      triangle: {
        display: "none"
      },
      triangleShadow: {
        display: "none"
      }
    },
    "top-left-triangle": {
      triangle: {
        top: "-10px",
        left: "12px"
      },
      triangleShadow: {
        top: "-11px",
        left: "12px"
      }
    },
    "top-right-triangle": {
      triangle: {
        top: "-10px",
        right: "12px"
      },
      triangleShadow: {
        top: "-11px",
        right: "12px"
      }
    }
  }, passedStyles), {
    "hide-triangle": triangle === "hide",
    "top-left-triangle": triangle === "top-left",
    "top-right-triangle": triangle === "top-right"
  });
  var handleChange = function handleChange2(hexcode, e) {
    isValidHex(hexcode) && onChange({
      hex: hexcode,
      source: "hex"
    }, e);
  };
  return React__default.createElement(
    "div",
    { style: styles.card, className: "twitter-picker " + className },
    React__default.createElement("div", { style: styles.triangleShadow }),
    React__default.createElement("div", { style: styles.triangle }),
    React__default.createElement(
      "div",
      { style: styles.body },
      map(colors, function(c, i) {
        return React__default.createElement(Swatch$1, {
          key: i,
          color: c,
          hex: c,
          style: styles.swatch,
          onClick: handleChange,
          onHover: onSwatchHover,
          focusStyle: {
            boxShadow: "0 0 4px " + c
          }
        });
      }),
      React__default.createElement(
        "div",
        { style: styles.hash },
        "#"
      ),
      React__default.createElement(EditableInput, {
        label: null,
        style: { input: styles.input },
        value: hex.replace("#", ""),
        onChange: handleChange
      }),
      React__default.createElement("div", { style: styles.clear })
    )
  );
};
Twitter.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  triangle: PropTypes.oneOf(["hide", "top-left", "top-right"]),
  colors: PropTypes.arrayOf(PropTypes.string),
  styles: PropTypes.object
};
Twitter.defaultProps = {
  width: 276,
  colors: ["#FF6900", "#FCB900", "#7BDCB5", "#00D084", "#8ED1FC", "#0693E3", "#ABB8C3", "#EB144C", "#F78DA7", "#9900EF"],
  triangle: "top-left",
  styles: {}
};
ColorWrap(Twitter);
var GooglePointerCircle = function GooglePointerCircle2(props) {
  var styles = _default$2({
    "default": {
      picker: {
        width: "20px",
        height: "20px",
        borderRadius: "22px",
        border: "2px #fff solid",
        transform: "translate(-12px, -13px)",
        background: "hsl(" + Math.round(props.hsl.h) + ", " + Math.round(props.hsl.s * 100) + "%, " + Math.round(props.hsl.l * 100) + "%)"
      }
    }
  });
  return React__default.createElement("div", { style: styles.picker });
};
GooglePointerCircle.propTypes = {
  hsl: PropTypes.shape({
    h: PropTypes.number,
    s: PropTypes.number,
    l: PropTypes.number,
    a: PropTypes.number
  })
};
GooglePointerCircle.defaultProps = {
  hsl: { a: 1, h: 249.94, l: 0.2, s: 0.5 }
};
var GooglePointer = function GooglePointer2(props) {
  var styles = _default$2({
    "default": {
      picker: {
        width: "20px",
        height: "20px",
        borderRadius: "22px",
        transform: "translate(-10px, -7px)",
        background: "hsl(" + Math.round(props.hsl.h) + ", 100%, 50%)",
        border: "2px white solid"
      }
    }
  });
  return React__default.createElement("div", { style: styles.picker });
};
GooglePointer.propTypes = {
  hsl: PropTypes.shape({
    h: PropTypes.number,
    s: PropTypes.number,
    l: PropTypes.number,
    a: PropTypes.number
  })
};
GooglePointer.defaultProps = {
  hsl: { a: 1, h: 249.94, l: 0.2, s: 0.5 }
};
var GoogleFields = function GoogleFields2(_ref) {
  var onChange = _ref.onChange, rgb = _ref.rgb, hsl = _ref.hsl, hex = _ref.hex, hsv = _ref.hsv;
  var handleChange = function handleChange2(data, e) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e);
    } else if (data.rgb) {
      var values = data.rgb.split(",");
      isvalidColorString(data.rgb, "rgb") && onChange({
        r: values[0],
        g: values[1],
        b: values[2],
        a: 1,
        source: "rgb"
      }, e);
    } else if (data.hsv) {
      var _values = data.hsv.split(",");
      if (isvalidColorString(data.hsv, "hsv")) {
        _values[2] = _values[2].replace("%", "");
        _values[1] = _values[1].replace("%", "");
        _values[0] = _values[0].replace("\xB0", "");
        if (_values[1] == 1) {
          _values[1] = 0.01;
        } else if (_values[2] == 1) {
          _values[2] = 0.01;
        }
        onChange({
          h: Number(_values[0]),
          s: Number(_values[1]),
          v: Number(_values[2]),
          source: "hsv"
        }, e);
      }
    } else if (data.hsl) {
      var _values2 = data.hsl.split(",");
      if (isvalidColorString(data.hsl, "hsl")) {
        _values2[2] = _values2[2].replace("%", "");
        _values2[1] = _values2[1].replace("%", "");
        _values2[0] = _values2[0].replace("\xB0", "");
        if (hsvValue[1] == 1) {
          hsvValue[1] = 0.01;
        } else if (hsvValue[2] == 1) {
          hsvValue[2] = 0.01;
        }
        onChange({
          h: Number(_values2[0]),
          s: Number(_values2[1]),
          v: Number(_values2[2]),
          source: "hsl"
        }, e);
      }
    }
  };
  var styles = _default$2({
    "default": {
      wrap: {
        display: "flex",
        height: "100px",
        marginTop: "4px"
      },
      fields: {
        width: "100%"
      },
      column: {
        paddingTop: "10px",
        display: "flex",
        justifyContent: "space-between"
      },
      double: {
        padding: "0px 4.4px",
        boxSizing: "border-box"
      },
      input: {
        width: "100%",
        height: "38px",
        boxSizing: "border-box",
        padding: "4px 10% 3px",
        textAlign: "center",
        border: "1px solid #dadce0",
        fontSize: "11px",
        textTransform: "lowercase",
        borderRadius: "5px",
        outline: "none",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      input2: {
        height: "38px",
        width: "100%",
        border: "1px solid #dadce0",
        boxSizing: "border-box",
        fontSize: "11px",
        textTransform: "lowercase",
        borderRadius: "5px",
        outline: "none",
        paddingLeft: "10px",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      label: {
        textAlign: "center",
        fontSize: "12px",
        background: "#fff",
        position: "absolute",
        textTransform: "uppercase",
        color: "#3c4043",
        width: "35px",
        top: "-6px",
        left: "0",
        right: "0",
        marginLeft: "auto",
        marginRight: "auto",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      label2: {
        left: "10px",
        textAlign: "center",
        fontSize: "12px",
        background: "#fff",
        position: "absolute",
        textTransform: "uppercase",
        color: "#3c4043",
        width: "32px",
        top: "-6px",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      single: {
        flexGrow: "1",
        margin: "0px 4.4px"
      }
    }
  });
  var rgbValue = rgb.r + ", " + rgb.g + ", " + rgb.b;
  var hslValue = Math.round(hsl.h) + "\xB0, " + Math.round(hsl.s * 100) + "%, " + Math.round(hsl.l * 100) + "%";
  var hsvValue = Math.round(hsv.h) + "\xB0, " + Math.round(hsv.s * 100) + "%, " + Math.round(hsv.v * 100) + "%";
  return React__default.createElement(
    "div",
    { style: styles.wrap, className: "flexbox-fix" },
    React__default.createElement(
      "div",
      { style: styles.fields },
      React__default.createElement(
        "div",
        { style: styles.double },
        React__default.createElement(EditableInput, {
          style: { input: styles.input, label: styles.label },
          label: "hex",
          value: hex,
          onChange: handleChange
        })
      ),
      React__default.createElement(
        "div",
        { style: styles.column },
        React__default.createElement(
          "div",
          { style: styles.single },
          React__default.createElement(EditableInput, {
            style: { input: styles.input2, label: styles.label2 },
            label: "rgb",
            value: rgbValue,
            onChange: handleChange
          })
        ),
        React__default.createElement(
          "div",
          { style: styles.single },
          React__default.createElement(EditableInput, {
            style: { input: styles.input2, label: styles.label2 },
            label: "hsv",
            value: hsvValue,
            onChange: handleChange
          })
        ),
        React__default.createElement(
          "div",
          { style: styles.single },
          React__default.createElement(EditableInput, {
            style: { input: styles.input2, label: styles.label2 },
            label: "hsl",
            value: hslValue,
            onChange: handleChange
          })
        )
      )
    )
  );
};
var Google = function Google2(_ref) {
  var width = _ref.width, onChange = _ref.onChange, rgb = _ref.rgb, hsl = _ref.hsl, hsv = _ref.hsv, hex = _ref.hex, header = _ref.header, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$2({
    "default": {
      picker: {
        width,
        background: "#fff",
        border: "1px solid #dfe1e5",
        boxSizing: "initial",
        display: "flex",
        flexWrap: "wrap",
        borderRadius: "8px 8px 0px 0px"
      },
      head: {
        height: "57px",
        width: "100%",
        paddingTop: "16px",
        paddingBottom: "16px",
        paddingLeft: "16px",
        fontSize: "20px",
        boxSizing: "border-box",
        fontFamily: "Roboto-Regular,HelveticaNeue,Arial,sans-serif"
      },
      saturation: {
        width: "70%",
        padding: "0px",
        position: "relative",
        overflow: "hidden"
      },
      swatch: {
        width: "30%",
        height: "228px",
        padding: "0px",
        background: "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", 1)",
        position: "relative",
        overflow: "hidden"
      },
      body: {
        margin: "auto",
        width: "95%"
      },
      controls: {
        display: "flex",
        boxSizing: "border-box",
        height: "52px",
        paddingTop: "22px"
      },
      color: {
        width: "32px"
      },
      hue: {
        height: "8px",
        position: "relative",
        margin: "0px 16px 0px 16px",
        width: "100%"
      },
      Hue: {
        radius: "2px"
      }
    }
  }, passedStyles));
  return React__default.createElement(
    "div",
    { style: styles.picker, className: "google-picker " + className },
    React__default.createElement(
      "div",
      { style: styles.head },
      header
    ),
    React__default.createElement("div", { style: styles.swatch }),
    React__default.createElement(
      "div",
      { style: styles.saturation },
      React__default.createElement(Saturation, {
        hsl,
        hsv,
        pointer: GooglePointerCircle,
        onChange
      })
    ),
    React__default.createElement(
      "div",
      { style: styles.body },
      React__default.createElement(
        "div",
        { style: styles.controls, className: "flexbox-fix" },
        React__default.createElement(
          "div",
          { style: styles.hue },
          React__default.createElement(Hue, {
            style: styles.Hue,
            hsl,
            radius: "4px",
            pointer: GooglePointer,
            onChange
          })
        )
      ),
      React__default.createElement(GoogleFields, {
        rgb,
        hsl,
        hex,
        hsv,
        onChange
      })
    )
  );
};
Google.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  styles: PropTypes.object,
  header: PropTypes.string
};
Google.defaultProps = {
  width: 652,
  styles: {},
  header: "Color picker"
};
ColorWrap(Google);
var colorPicker = "";
var ColorPicker = function ColorPicker2(props) {
  var _props$pickerType = props.pickerType, pickerType = _props$pickerType === void 0 ? "sketch" : _props$pickerType, _props$color = props.color, color = _props$color === void 0 ? "#fff" : _props$color, _props$onChange = props.onChange, onChange = _props$onChange === void 0 ? function() {
  } : _props$onChange, _props$onClickOutside = props.onClickOutside, onClickOutside = _props$onClickOutside === void 0 ? function() {
  } : _props$onClickOutside;
  var pickers = {
    sketch: ColorPickerSketch,
    compact: ColorPickerCompact
  };
  var colorPickerRef = React__default.useRef(null);
  var Component2 = pickers[pickerType];
  UTILS$2.whenUserClickOutsideTheElement(colorPickerRef, onClickOutside);
  if (!Component2)
    return null;
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "rct-color-picker rct-color-picker-".concat(pickerType),
    ref: colorPickerRef
  }, /* @__PURE__ */ React__default.createElement(Component2, {
    color,
    onChange
  }));
};
var ColorPickerCompact = function ColorPickerCompact2(props) {
  var onChange = props.onChange;
  return /* @__PURE__ */ React__default.createElement(CompactPicker, {
    onChangeComplete: function onChangeComplete(color) {
      return onChange(color.hex);
    }
  });
};
var ColorPickerSketch = function ColorPickerSketch2(props) {
  var firstColor = props.color, onChange = props.onChange;
  var _React$useState = React__default.useState(firstColor), _React$useState2 = _slicedToArray(_React$useState, 2), color = _React$useState2[0], setColor = _React$useState2[1];
  return /* @__PURE__ */ React__default.createElement(SketchPicker, {
    color,
    onChangeComplete: function onChangeComplete(color2) {
      return onChange(color2.hex);
    },
    onChange: function onChange2(color2) {
      return setColor(color2.hex);
    },
    disableAlpha: true
  });
};
var popup = "";
function Popup(props) {
  var children = props.children, initiator = props.initiator, _props$style = props.style, style = _props$style === void 0 ? {} : _props$style, minWidth = props.minWidth, minHeight = props.minHeight, maxWidth = props.maxWidth, maxHeight = props.maxHeight, _props$extraClass = props.extraClass, extraClass = _props$extraClass === void 0 ? "" : _props$extraClass, _props$onOutsideClick = props.onOutsideClick, onOutsideClick = _props$onOutsideClick === void 0 ? function() {
  } : _props$onOutsideClick, _props$notResize = props.notResize, notResize = _props$notResize === void 0 ? false : _props$notResize, _props$answer = props.answer, answer = _props$answer === void 0 ? {} : _props$answer;
  var utilsCurrent = React__default.useRef(new Utils$2({
    props
  }));
  var utils2 = utilsCurrent.current;
  var popupRefCurrent = React__default.useRef(null);
  var randomClass = React__default.useRef("id".concat(UTILS$2.random16()));
  answer.randomClass = randomClass.current;
  answer.popupRefCurrent = popupRefCurrent;
  var checkOutsideClick = function checkOutsideClick2(e) {
    var _e$target;
    if ((_e$target = e.target) !== null && _e$target !== void 0 && _e$target.parentElement && popupRefCurrent.current && !popupRefCurrent.current.contains(e.target))
      onOutsideClick();
  };
  React__default.useEffect(function() {
    var removeCheckElementScroll = utils2.checkElementScroll(initiator);
    if (onOutsideClick) {
      setTimeout(function() {
        document.addEventListener("click", checkOutsideClick);
      }, 0);
    }
    utils2.recalcPosition();
    return function() {
      removeCheckElementScroll();
      if (onOutsideClick)
        document.removeEventListener("click", checkOutsideClick);
    };
  }, []);
  utils2.data = {
    popupRefCurrent
  };
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "rct-popup ".concat(randomClass.current, " ").concat(extraClass),
    style: _objectSpread2({
      minWidth: minWidth ? utils2.getVal(minWidth) : "unset",
      minHeight: minHeight ? utils2.getVal(minHeight) : "unset",
      maxWidth: maxWidth ? utils2.getVal(maxWidth) : "unset",
      maxHeight: maxHeight ? utils2.getVal(maxHeight) : "unset"
    }, style),
    ref: popupRefCurrent
  }, children, !notResize && /* @__PURE__ */ React__default.createElement(Corner, {
    utils: utils2
  }));
}
var createRoot;
var m = ReactDOM__default;
{
  createRoot = m.createRoot;
  m.hydrateRoot;
}
var callPopup = function callPopup2(props) {
  var externalPortal = props.portal;
  var appRoot = document.createElement("div");
  appRoot.className = "popup-root";
  var portal = externalPortal || document.querySelector("html");
  portal.appendChild(appRoot);
  var root2 = createRoot(appRoot);
  var removeComponent = function removeComponent2() {
    root2.unmount();
    appRoot.remove();
  };
  root2.render(/* @__PURE__ */ React__default.createElement(Popup, _extends$h({}, props, {
    removeComponent
  })));
  return {
    removeComponent
  };
};
var corner = "";
function Corner(props) {
  var utils2 = props.utils;
  var cornerRefCurrent = React__default.useRef(null);
  utils2.data.cornerRefCurrent = cornerRefCurrent;
  return /* @__PURE__ */ React__default.createElement("div", {
    className: utils2.positionToCornerClass(),
    ref: cornerRefCurrent,
    onMouseDown: utils2.cornerStart.bind(utils2)
  });
}
var Utils$2 = /* @__PURE__ */ function() {
  function Utils2(_ref) {
    var props = _ref.props;
    _classCallCheck$a(this, Utils2);
    this.props = _objectSpread2(_objectSpread2({}, props), {}, {
      answer: props !== null && props !== void 0 && props.answer ? props.answer : {}
    });
    this.position = {};
    this.localeStorageName = "popup_sizes";
    var popupSizes = localStorage.getItem(this.localeStorageName);
    this.popupSizes = popupSizes ? JSON.parse(popupSizes) : {};
    this.getPosition();
  }
  return _createClass$9(Utils2, [{
    key: "getPosition",
    value: function getPosition() {
      var _this$data;
      var _this$props = this.props, initiator = _this$props.initiator, minWidth = _this$props.minWidth, minHeight = _this$props.minHeight, id = _this$props.id, autoSize = _this$props.autoSize, fitToParent = _this$props.fitToParent;
      var _initiator$getBoundin = initiator.getBoundingClientRect(), width = _initiator$getBoundin.width, height = _initiator$getBoundin.height, left = _initiator$getBoundin.left, right = _initiator$getBoundin.right, top = _initiator$getBoundin.top, bottom = _initiator$getBoundin.bottom;
      var _this$position = this.position, oldWidth = _this$position.width, oldHeight = _this$position.height;
      if (!oldWidth && this.popupSizes[id]) {
        oldWidth = this.popupSizes[id].width;
        oldHeight = this.popupSizes[id].height;
      }
      var rightSpase = window.innerWidth - left;
      var bottomSpace = window.innerHeight - bottom;
      var popupWidth = oldWidth ? oldWidth : Math.max(width, minWidth);
      var popupHeight = oldHeight ? oldHeight : Math.max(height, minHeight);
      if (autoSize && (_this$data = this.data) !== null && _this$data !== void 0 && (_this$data = _this$data.popupRefCurrent) !== null && _this$data !== void 0 && _this$data.current) {
        var _this$data$popupRefCu = this.data.popupRefCurrent.current.getBoundingClientRect(), _width = _this$data$popupRefCu.width, _height = _this$data$popupRefCu.height;
        popupWidth = _width;
        popupHeight = _height;
      }
      var downDirection = bottomSpace > popupHeight + 20;
      var rightDirection = rightSpase > popupWidth + 20;
      this.props.answer.direction = {
        down: downDirection,
        up: !downDirection,
        right: rightDirection,
        left: !rightDirection
      };
      this.position = {
        downDirection,
        rightDirection,
        left: fitToParent ? left : rightDirection ? left : right - popupWidth,
        top: fitToParent ? top : downDirection ? bottom : top - popupHeight,
        width: fitToParent ? width : popupWidth,
        height: fitToParent ? height : popupHeight
      };
      return this.position;
    }
  }, {
    key: "getVal",
    value: function getVal(size2) {
      return isNaN(size2) ? size2 : "".concat(size2, "px");
    }
  }, {
    key: "positionToPopupCSS",
    value: function positionToPopupCSS() {
      var _this$props2 = this.props, minWidth = _this$props2.minWidth, minHeight = _this$props2.minHeight, maxWidth = _this$props2.maxWidth, maxHeight = _this$props2.maxHeight, autoSize = _this$props2.autoSize;
      var _this$position2 = this.position, left = _this$position2.left, top = _this$position2.top, width = _this$position2.width, height = _this$position2.height;
      var out = {
        "left": this.getVal(left),
        "top": this.getVal(top),
        "minWidth": this.getVal(minWidth),
        "minHeight": this.getVal(minHeight)
      };
      if (!autoSize) {
        out.width = this.getVal(width);
        out.height = this.getVal(height);
      }
      if (maxWidth)
        out["max-width"] = this.getVal(maxWidth);
      if (maxHeight)
        out["max-height"] = this.getVal(maxHeight);
      return out;
    }
  }, {
    key: "positionToCornerClass",
    value: function positionToCornerClass() {
      var _this$position3 = this.position, downDirection = _this$position3.downDirection, rightDirection = _this$position3.rightDirection;
      return "rct-popup-corner ".concat(downDirection ? "bottom" : "top", "-").concat(rightDirection ? "right" : "left");
    }
  }, {
    key: "recalcPosition",
    value: function recalcPosition() {
      var _this$data2 = this.data, popupRefCurrent = _this$data2.popupRefCurrent, cornerRefCurrent = _this$data2.cornerRefCurrent;
      this.position = this.getPosition();
      var css = this.positionToPopupCSS();
      for (var style in css) {
        var styleValue = css[style];
        popupRefCurrent.current.style[style] = styleValue;
      }
      if (!(cornerRefCurrent !== null && cornerRefCurrent !== void 0 && cornerRefCurrent.current))
        return;
      cornerRefCurrent.current.className = this.positionToCornerClass();
    }
  }, {
    key: "checkElementScroll",
    value: function checkElementScroll() {
      var _this = this;
      var initiator = this.props.initiator;
      if (!initiator) {
        return function() {
        };
      }
      var parentEl = initiator.parentElement;
      var scrolls = [];
      var scrollListener = function scrollListener2() {
        _this.recalcPosition();
      };
      while ((_parentEl = parentEl) !== null && _parentEl !== void 0 && _parentEl.tagName) {
        var _parentEl;
        var scroll = {
          parentEl
        };
        scroll.scrollListener = scrollListener;
        parentEl.addEventListener("scroll", scrollListener);
        scrolls.push(scroll);
        parentEl = parentEl.parentElement;
      }
      return function() {
        for (var _i = 0, _scrolls = scrolls; _i < _scrolls.length; _i++) {
          var item = _scrolls[_i];
          item.parentEl.removeEventListener("scroll", item.scrollListener);
        }
      };
    }
  }, {
    key: "cornerStart",
    value: function cornerStart(e) {
      var popupRefCurrent = this.data.popupRefCurrent;
      var _this$position4 = this.position, width = _this$position4.width, height = _this$position4.height, left = _this$position4.left, top = _this$position4.top;
      this.cornerStartPosition = {
        cursorX: e.clientX,
        cursorY: e.clientY,
        popupWidth: width,
        popupHeight: height,
        popupLeft: left,
        popupTop: top
      };
      popupRefCurrent.current.classList.add("move");
      document.onmouseup = this.cornerStop.bind(this);
      document.onmousemove = this.cornerMove.bind(this);
      document.getElementsByTagName("body")[0].style["user-select"] = "none";
    }
  }, {
    key: "cornerMove",
    value: function cornerMove(e) {
      var popupRefCurrent = this.data.popupRefCurrent;
      var _this$props3 = this.props, minWidth = _this$props3.minWidth, minHeight = _this$props3.minHeight;
      var _this$cornerStartPosi = this.cornerStartPosition, cursorX = _this$cornerStartPosi.cursorX, cursorY = _this$cornerStartPosi.cursorY, popupWidth = _this$cornerStartPosi.popupWidth, popupHeight = _this$cornerStartPosi.popupHeight, popupLeft = _this$cornerStartPosi.popupLeft, popupTop = _this$cornerStartPosi.popupTop;
      var _this$position5 = this.position, downDirection = _this$position5.downDirection, rightDirection = _this$position5.rightDirection;
      var maxDeltaX = popupWidth - minWidth;
      var maxDeltaY = popupHeight - minHeight;
      var deltaX = e.clientX - cursorX;
      var deltaY = e.clientY - cursorY;
      if (rightDirection && deltaX < 0 && deltaX < maxDeltaX * -1)
        deltaX = maxDeltaX * -1;
      if (!rightDirection && deltaX > 0 && deltaX > maxDeltaX)
        deltaX = maxDeltaX;
      if (downDirection && deltaY < 0 && deltaY < maxDeltaY * -1)
        deltaY = maxDeltaY * -1;
      if (!downDirection && deltaY > 0 && deltaY > maxDeltaY)
        deltaY = maxDeltaY;
      this.position = _objectSpread2(_objectSpread2({}, this.position), {}, {
        left: rightDirection ? popupLeft : popupLeft + deltaX,
        top: downDirection ? popupTop : popupTop + deltaY,
        width: rightDirection ? popupWidth + deltaX : popupWidth - deltaX,
        height: downDirection ? popupHeight + deltaY : popupHeight - deltaY
      });
      var css = this.positionToPopupCSS();
      for (var style in css) {
        var styleValue = css[style];
        popupRefCurrent.current.style[style] = styleValue;
      }
    }
  }, {
    key: "cornerStop",
    value: function cornerStop() {
      var popupRefCurrent = this.data.popupRefCurrent;
      var id = this.props.id;
      document.onmouseup = null;
      document.onmousemove = null;
      popupRefCurrent.current.classList.remove("move");
      document.getElementsByTagName("body")[0].style["user-select"] = "";
      this.recalcPosition();
      if (id) {
        var _this$position6 = this.position, width = _this$position6.width, height = _this$position6.height;
        this.popupSizes[id] = {
          width,
          height
        };
        localStorage.setItem(this.localeStorageName, JSON.stringify(this.popupSizes));
      }
    }
  }]);
}();
var listPicker = "";
function die(error) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  throw new Error(typeof error === "number" ? "[MobX] minified error nr: " + error + (args.length ? " " + args.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + error);
}
var mockGlobal = {};
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  return mockGlobal;
}
var assign = Object.assign;
var getDescriptor = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var objectPrototype = Object.prototype;
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var hasProxy = typeof Proxy !== "undefined";
var plainObjectString = /* @__PURE__ */ Object.toString();
function assertProxies() {
  if (!hasProxy) {
    die("Proxy not available");
  }
}
function once(func) {
  var invoked = false;
  return function() {
    if (invoked) {
      return;
    }
    invoked = true;
    return func.apply(this, arguments);
  };
}
var noop$1 = function noop() {
};
function isFunction$1(fn) {
  return typeof fn === "function";
}
function isStringish(value) {
  var t = typeof value;
  switch (t) {
    case "string":
    case "symbol":
    case "number":
      return true;
  }
  return false;
}
function isObject$2(value) {
  return value !== null && typeof value === "object";
}
function isPlainObject$2(value) {
  if (!isObject$2(value)) {
    return false;
  }
  var proto2 = Object.getPrototypeOf(value);
  if (proto2 == null) {
    return true;
  }
  var protoConstructor = Object.hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
  return typeof protoConstructor === "function" && protoConstructor.toString() === plainObjectString;
}
function isGenerator(obj) {
  var constructor = obj == null ? void 0 : obj.constructor;
  if (!constructor) {
    return false;
  }
  if ("GeneratorFunction" === constructor.name || "GeneratorFunction" === constructor.displayName) {
    return true;
  }
  return false;
}
function addHiddenProp(object2, propName, value) {
  defineProperty(object2, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value
  });
}
function addHiddenFinalProp(object2, propName, value) {
  defineProperty(object2, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value
  });
}
function createInstanceofPredicate(name, theClass) {
  var propName = "isMobX" + name;
  theClass.prototype[propName] = true;
  return function(x) {
    return isObject$2(x) && x[propName] === true;
  };
}
function isES6Map(thing) {
  return thing != null && Object.prototype.toString.call(thing) === "[object Map]";
}
function isPlainES6Map(thing) {
  var mapProto = Object.getPrototypeOf(thing);
  var objectProto2 = Object.getPrototypeOf(mapProto);
  var nullProto = Object.getPrototypeOf(objectProto2);
  return nullProto === null;
}
function isES6Set(thing) {
  return thing != null && Object.prototype.toString.call(thing) === "[object Set]";
}
var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
function getPlainObjectKeys(object2) {
  var keys2 = Object.keys(object2);
  if (!hasGetOwnPropertySymbols) {
    return keys2;
  }
  var symbols = Object.getOwnPropertySymbols(object2);
  if (!symbols.length) {
    return keys2;
  }
  return [].concat(keys2, symbols.filter(function(s) {
    return objectPrototype.propertyIsEnumerable.call(object2, s);
  }));
}
var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} : Object.getOwnPropertyNames;
function toPrimitive(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}
function hasProp(target, prop) {
  return objectPrototype.hasOwnProperty.call(target, prop);
}
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(target) {
  var res = {};
  ownKeys(target).forEach(function(key) {
    res[key] = getDescriptor(target, key);
  });
  return res;
};
function getFlag(flags, mask) {
  return !!(flags & mask);
}
function setFlag(flags, mask, newValue) {
  if (newValue) {
    flags |= mask;
  } else {
    flags &= ~mask;
  }
  return flags;
}
function _arrayLikeToArray(r2, a) {
  (null == a || a > r2.length) && (a = r2.length);
  for (var e = 0, n2 = Array(a); e < a; e++)
    n2[e] = r2[e];
  return n2;
}
function _defineProperties(e, r2) {
  for (var t = 0; t < r2.length; t++) {
    var o = r2[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r2, t) {
  return r2 && _defineProperties(e.prototype, r2), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _createForOfIteratorHelperLoose(r2, e) {
  var t = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (t)
    return (t = t.call(r2)).next.bind(t);
  if (Array.isArray(r2) || (t = _unsupportedIterableToArray(r2)) || e && r2 && "number" == typeof r2.length) {
    t && (r2 = t);
    var o = 0;
    return function() {
      return o >= r2.length ? {
        done: true
      } : {
        done: false,
        value: r2[o++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _extends$1() {
  return _extends$1 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r2 in t)
        ({}).hasOwnProperty.call(t, r2) && (n2[r2] = t[r2]);
    }
    return n2;
  }, _extends$1.apply(null, arguments);
}
function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}
function _toPrimitive(t, r2) {
  if ("object" != typeof t || !t)
    return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r2 || "default");
    if ("object" != typeof i)
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _unsupportedIterableToArray(r2, a) {
  if (r2) {
    if ("string" == typeof r2)
      return _arrayLikeToArray(r2, a);
    var t = {}.toString.call(r2).slice(8, -1);
    return "Object" === t && r2.constructor && (t = r2.constructor.name), "Map" === t || "Set" === t ? Array.from(r2) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r2, a) : void 0;
  }
}
var storedAnnotationsSymbol = /* @__PURE__ */ Symbol("mobx-stored-annotations");
function createDecoratorAnnotation(annotation) {
  function decorator(target, property2) {
    if (is20223Decorator(property2)) {
      return annotation.decorate_20223_(target, property2);
    } else {
      storeAnnotation(target, property2, annotation);
    }
  }
  return Object.assign(decorator, annotation);
}
function storeAnnotation(prototype2, key, annotation) {
  if (!hasProp(prototype2, storedAnnotationsSymbol)) {
    addHiddenProp(prototype2, storedAnnotationsSymbol, _extends$1({}, prototype2[storedAnnotationsSymbol]));
  }
  if (!isOverride(annotation)) {
    prototype2[storedAnnotationsSymbol][key] = annotation;
  }
}
function collectStoredAnnotations(target) {
  if (!hasProp(target, storedAnnotationsSymbol)) {
    addHiddenProp(target, storedAnnotationsSymbol, _extends$1({}, target[storedAnnotationsSymbol]));
  }
  return target[storedAnnotationsSymbol];
}
function is20223Decorator(context) {
  return typeof context == "object" && typeof context["kind"] == "string";
}
var $mobx = /* @__PURE__ */ Symbol("mobx administration");
var Atom = /* @__PURE__ */ function() {
  function Atom2(name_) {
    if (name_ === void 0) {
      name_ = "Atom";
    }
    this.name_ = void 0;
    this.flags_ = 0;
    this.observers_ = /* @__PURE__ */ new Set();
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    this.name_ = name_;
  }
  var _proto = Atom2.prototype;
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.reportObserved = function reportObserved$1() {
    return reportObserved(this);
  };
  _proto.reportChanged = function reportChanged() {
    startBatch();
    propagateChanged(this);
    endBatch();
  };
  _proto.toString = function toString4() {
    return this.name_;
  };
  return _createClass(Atom2, [{
    key: "isBeingObserved",
    get: function get5() {
      return getFlag(this.flags_, Atom2.isBeingObservedMask_);
    },
    set: function set5(newValue) {
      this.flags_ = setFlag(this.flags_, Atom2.isBeingObservedMask_, newValue);
    }
  }, {
    key: "isPendingUnobservation",
    get: function get5() {
      return getFlag(this.flags_, Atom2.isPendingUnobservationMask_);
    },
    set: function set5(newValue) {
      this.flags_ = setFlag(this.flags_, Atom2.isPendingUnobservationMask_, newValue);
    }
  }, {
    key: "diffValue",
    get: function get5() {
      return getFlag(this.flags_, Atom2.diffValueMask_) ? 1 : 0;
    },
    set: function set5(newValue) {
      this.flags_ = setFlag(this.flags_, Atom2.diffValueMask_, newValue === 1 ? true : false);
    }
  }]);
}();
Atom.isBeingObservedMask_ = 1;
Atom.isPendingUnobservationMask_ = 2;
Atom.diffValueMask_ = 4;
var isAtom = /* @__PURE__ */ createInstanceofPredicate("Atom", Atom);
function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop$1;
  }
  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop$1;
  }
  var atom = new Atom(name);
  if (onBecomeObservedHandler !== noop$1) {
    onBecomeObserved(atom, onBecomeObservedHandler);
  }
  if (onBecomeUnobservedHandler !== noop$1) {
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
  }
  return atom;
}
function identityComparer(a, b) {
  return a === b;
}
function structuralComparer(a, b) {
  return deepEqual$1(a, b);
}
function shallowComparer(a, b) {
  return deepEqual$1(a, b, 1);
}
function defaultComparer(a, b) {
  if (Object.is) {
    return Object.is(a, b);
  }
  return a === b ? a !== 0 || 1 / a === 1 / b : a !== a && b !== b;
}
var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  "default": defaultComparer,
  shallow: shallowComparer
};
function deepEnhancer(v, _, name) {
  if (isObservable(v)) {
    return v;
  }
  if (Array.isArray(v)) {
    return observable.array(v, {
      name
    });
  }
  if (isPlainObject$2(v)) {
    return observable.object(v, void 0, {
      name
    });
  }
  if (isES6Map(v)) {
    return observable.map(v, {
      name
    });
  }
  if (isES6Set(v)) {
    return observable.set(v, {
      name
    });
  }
  if (typeof v === "function" && !isAction(v) && !isFlow(v)) {
    if (isGenerator(v)) {
      return flow(v);
    } else {
      return autoAction(name, v);
    }
  }
  return v;
}
function shallowEnhancer(v, _, name) {
  if (v === void 0 || v === null) {
    return v;
  }
  if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) {
    return v;
  }
  if (Array.isArray(v)) {
    return observable.array(v, {
      name,
      deep: false
    });
  }
  if (isPlainObject$2(v)) {
    return observable.object(v, void 0, {
      name,
      deep: false
    });
  }
  if (isES6Map(v)) {
    return observable.map(v, {
      name,
      deep: false
    });
  }
  if (isES6Set(v)) {
    return observable.set(v, {
      name,
      deep: false
    });
  }
}
function referenceEnhancer(newValue) {
  return newValue;
}
function refStructEnhancer(v, oldValue) {
  if (deepEqual$1(v, oldValue)) {
    return oldValue;
  }
  return v;
}
var OVERRIDE = "override";
function isOverride(annotation) {
  return annotation.annotationType_ === OVERRIDE;
}
function createActionAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$1,
    extend_: extend_$1,
    decorate_20223_: decorate_20223_$1
  };
}
function make_$1(adm, key, descriptor, source) {
  var _this$options_;
  if ((_this$options_ = this.options_) != null && _this$options_.bound) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
  }
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if (isAction(descriptor.value)) {
    return 1;
  }
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
  defineProperty(source, key, actionDescriptor);
  return 2;
}
function extend_$1(adm, key, descriptor, proxyTrap) {
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
  return adm.defineProperty_(key, actionDescriptor, proxyTrap);
}
function decorate_20223_$1(mthd, context) {
  var kind = context.kind, name = context.name, addInitializer = context.addInitializer;
  var ann = this;
  var _createAction = function _createAction2(m2) {
    var _ann$options_$name, _ann$options_, _ann$options_$autoAct, _ann$options_2;
    return createAction((_ann$options_$name = (_ann$options_ = ann.options_) == null ? void 0 : _ann$options_.name) != null ? _ann$options_$name : name.toString(), m2, (_ann$options_$autoAct = (_ann$options_2 = ann.options_) == null ? void 0 : _ann$options_2.autoAction) != null ? _ann$options_$autoAct : false);
  };
  if (kind == "field") {
    return function(initMthd) {
      var _ann$options_3;
      var mthd2 = initMthd;
      if (!isAction(mthd2)) {
        mthd2 = _createAction(mthd2);
      }
      if ((_ann$options_3 = ann.options_) != null && _ann$options_3.bound) {
        mthd2 = mthd2.bind(this);
        mthd2.isMobxAction = true;
      }
      return mthd2;
    };
  }
  if (kind == "method") {
    var _this$options_2;
    if (!isAction(mthd)) {
      mthd = _createAction(mthd);
    }
    if ((_this$options_2 = this.options_) != null && _this$options_2.bound) {
      addInitializer(function() {
        var self2 = this;
        var bound = self2[name].bind(self2);
        bound.isMobxAction = true;
        self2[name] = bound;
      });
    }
    return mthd;
  }
  die("Cannot apply '" + ann.annotationType_ + "' to '" + String(name) + "' (kind: " + kind + "):" + ("\n'" + ann.annotationType_ + "' can only be used on properties with a function value."));
}
function assertActionDescriptor(adm, _ref, key, _ref2) {
  _ref.annotationType_;
  _ref2.value;
}
function createActionDescriptor(adm, annotation, key, descriptor, safeDescriptors) {
  var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertActionDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if ((_annotation$options_ = annotation.options_) != null && _annotation$options_.bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return {
    value: createAction(
      (_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(),
      value,
      (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false,
      (_annotation$options_4 = annotation.options_) != null && _annotation$options_4.bound ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : void 0
    ),
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    enumerable: false,
    writable: safeDescriptors ? false : true
  };
}
function createFlowAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$2,
    extend_: extend_$2,
    decorate_20223_: decorate_20223_$2
  };
}
function make_$2(adm, key, descriptor, source) {
  var _this$options_;
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if ((_this$options_ = this.options_) != null && _this$options_.bound && (!hasProp(adm.target_, key) || !isFlow(adm.target_[key]))) {
    if (this.extend_(adm, key, descriptor, false) === null) {
      return 0;
    }
  }
  if (isFlow(descriptor.value)) {
    return 1;
  }
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
  defineProperty(source, key, flowDescriptor);
  return 2;
}
function extend_$2(adm, key, descriptor, proxyTrap) {
  var _this$options_2;
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
  return adm.defineProperty_(key, flowDescriptor, proxyTrap);
}
function decorate_20223_$2(mthd, context) {
  var _this$options_3;
  var name = context.name, addInitializer = context.addInitializer;
  if (!isFlow(mthd)) {
    mthd = flow(mthd);
  }
  if ((_this$options_3 = this.options_) != null && _this$options_3.bound) {
    addInitializer(function() {
      var self2 = this;
      var bound = self2[name].bind(self2);
      bound.isMobXFlow = true;
      self2[name] = bound;
    });
  }
  return mthd;
}
function assertFlowDescriptor(adm, _ref, key, _ref2) {
  _ref.annotationType_;
  _ref2.value;
}
function createFlowDescriptor(adm, annotation, key, descriptor, bound, safeDescriptors) {
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertFlowDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if (!isFlow(value)) {
    value = flow(value);
  }
  if (bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
    value.isMobXFlow = true;
  }
  return {
    value,
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    enumerable: false,
    writable: safeDescriptors ? false : true
  };
}
function createComputedAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$3,
    extend_: extend_$3,
    decorate_20223_: decorate_20223_$3
  };
}
function make_$3(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$3(adm, key, descriptor, proxyTrap) {
  assertComputedDescriptor(adm, this, key, descriptor);
  return adm.defineComputedProperty_(key, _extends$1({}, this.options_, {
    get: descriptor.get,
    set: descriptor.set
  }), proxyTrap);
}
function decorate_20223_$3(get5, context) {
  var ann = this;
  var key = context.name, addInitializer = context.addInitializer;
  addInitializer(function() {
    var adm = asObservableObject(this)[$mobx];
    var options = _extends$1({}, ann.options_, {
      get: get5,
      context: this
    });
    options.name || (options.name = "ObservableObject." + key.toString());
    adm.values_.set(key, new ComputedValue(options));
  });
  return function() {
    return this[$mobx].getObservablePropValue_(key);
  };
}
function assertComputedDescriptor(adm, _ref, key, _ref2) {
  _ref.annotationType_;
  _ref2.get;
}
function createObservableAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$4,
    extend_: extend_$4,
    decorate_20223_: decorate_20223_$4
  };
}
function make_$4(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$4(adm, key, descriptor, proxyTrap) {
  var _this$options_$enhanc, _this$options_;
  assertObservableDescriptor(adm, this);
  return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
}
function decorate_20223_$4(desc, context) {
  var ann = this;
  var kind = context.kind, name = context.name;
  var initializedObjects = /* @__PURE__ */ new WeakSet();
  function initializeObservable(target, value) {
    var _ann$options_$enhance, _ann$options_;
    var adm = asObservableObject(target)[$mobx];
    var observable2 = new ObservableValue(value, (_ann$options_$enhance = (_ann$options_ = ann.options_) == null ? void 0 : _ann$options_.enhancer) != null ? _ann$options_$enhance : deepEnhancer, "ObservableObject." + name.toString(), false);
    adm.values_.set(name, observable2);
    initializedObjects.add(target);
  }
  if (kind == "accessor") {
    return {
      get: function get5() {
        if (!initializedObjects.has(this)) {
          initializeObservable(this, desc.get.call(this));
        }
        return this[$mobx].getObservablePropValue_(name);
      },
      set: function set5(value) {
        if (!initializedObjects.has(this)) {
          initializeObservable(this, value);
        }
        return this[$mobx].setObservablePropValue_(name, value);
      },
      init: function init(value) {
        if (!initializedObjects.has(this)) {
          initializeObservable(this, value);
        }
        return value;
      }
    };
  }
  return;
}
function assertObservableDescriptor(adm, _ref, key, descriptor) {
  _ref.annotationType_;
}
var AUTO = "true";
var autoAnnotation = /* @__PURE__ */ createAutoAnnotation();
function createAutoAnnotation(options) {
  return {
    annotationType_: AUTO,
    options_: options,
    make_: make_$5,
    extend_: extend_$5,
    decorate_20223_: decorate_20223_$5
  };
}
function make_$5(adm, key, descriptor, source) {
  var _this$options_3, _this$options_4;
  if (descriptor.get) {
    return computed.make_(adm, key, descriptor, source);
  }
  if (descriptor.set) {
    var set5 = createAction(key.toString(), descriptor.set);
    if (source === adm.target_) {
      return adm.defineProperty_(key, {
        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
        set: set5
      }) === null ? 0 : 2;
    }
    defineProperty(source, key, {
      configurable: true,
      set: set5
    });
    return 2;
  }
  if (source !== adm.target_ && typeof descriptor.value === "function") {
    var _this$options_2;
    if (isGenerator(descriptor.value)) {
      var _this$options_;
      var flowAnnotation2 = (_this$options_ = this.options_) != null && _this$options_.autoBind ? flow.bound : flow;
      return flowAnnotation2.make_(adm, key, descriptor, source);
    }
    var actionAnnotation2 = (_this$options_2 = this.options_) != null && _this$options_2.autoBind ? autoAction.bound : autoAction;
    return actionAnnotation2.make_(adm, key, descriptor, source);
  }
  var observableAnnotation2 = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable;
  if (typeof descriptor.value === "function" && (_this$options_4 = this.options_) != null && _this$options_4.autoBind) {
    var _adm$proxy_;
    descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return observableAnnotation2.make_(adm, key, descriptor, source);
}
function extend_$5(adm, key, descriptor, proxyTrap) {
  var _this$options_5, _this$options_6;
  if (descriptor.get) {
    return computed.extend_(adm, key, descriptor, proxyTrap);
  }
  if (descriptor.set) {
    return adm.defineProperty_(key, {
      configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
      set: createAction(key.toString(), descriptor.set)
    }, proxyTrap);
  }
  if (typeof descriptor.value === "function" && (_this$options_5 = this.options_) != null && _this$options_5.autoBind) {
    var _adm$proxy_2;
    descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
  }
  var observableAnnotation2 = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;
  return observableAnnotation2.extend_(adm, key, descriptor, proxyTrap);
}
function decorate_20223_$5(desc, context) {
  die("'" + this.annotationType_ + "' cannot be used as a decorator");
}
var OBSERVABLE = "observable";
var OBSERVABLE_REF = "observable.ref";
var OBSERVABLE_SHALLOW = "observable.shallow";
var OBSERVABLE_STRUCT = "observable.struct";
var defaultCreateObservableOptions = {
  deep: true,
  name: void 0,
  defaultDecorator: void 0,
  proxy: true
};
Object.freeze(defaultCreateObservableOptions);
function asCreateObservableOptions(thing) {
  return thing || defaultCreateObservableOptions;
}
var observableAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE);
var observableRefAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_REF, {
  enhancer: referenceEnhancer
});
var observableShallowAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_SHALLOW, {
  enhancer: shallowEnhancer
});
var observableStructAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_STRUCT, {
  enhancer: refStructEnhancer
});
var observableDecoratorAnnotation = /* @__PURE__ */ createDecoratorAnnotation(observableAnnotation);
function getEnhancerFromOptions(options) {
  return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);
}
function getAnnotationFromOptions(options) {
  var _options$defaultDecor;
  return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : void 0;
}
function getEnhancerFromAnnotation(annotation) {
  var _annotation$options_$, _annotation$options_;
  return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
}
function createObservable(v, arg2, arg3) {
  if (is20223Decorator(arg2)) {
    return observableAnnotation.decorate_20223_(v, arg2);
  }
  if (isStringish(arg2)) {
    storeAnnotation(v, arg2, observableAnnotation);
    return;
  }
  if (isObservable(v)) {
    return v;
  }
  if (isPlainObject$2(v)) {
    return observable.object(v, arg2, arg3);
  }
  if (Array.isArray(v)) {
    return observable.array(v, arg2);
  }
  if (isES6Map(v)) {
    return observable.map(v, arg2);
  }
  if (isES6Set(v)) {
    return observable.set(v, arg2);
  }
  if (typeof v === "object" && v !== null) {
    return v;
  }
  return observable.box(v, arg2);
}
assign(createObservable, observableDecoratorAnnotation);
var observableFactories = {
  box: function box(value, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
  },
  array: function array(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);
  },
  map: function map2(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
  },
  set: function set(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
  },
  object: function object(props, decorators, options) {
    return initObservable(function() {
      return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);
    });
  },
  ref: /* @__PURE__ */ createDecoratorAnnotation(observableRefAnnotation),
  shallow: /* @__PURE__ */ createDecoratorAnnotation(observableShallowAnnotation),
  deep: observableDecoratorAnnotation,
  struct: /* @__PURE__ */ createDecoratorAnnotation(observableStructAnnotation)
};
var observable = /* @__PURE__ */ assign(createObservable, observableFactories);
var COMPUTED = "computed";
var COMPUTED_STRUCT = "computed.struct";
var computedAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED);
var computedStructAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED_STRUCT, {
  equals: comparer.structural
});
var computed = function computed2(arg1, arg2) {
  if (is20223Decorator(arg2)) {
    return computedAnnotation.decorate_20223_(arg1, arg2);
  }
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, computedAnnotation);
  }
  if (isPlainObject$2(arg1)) {
    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
  }
  var opts = isPlainObject$2(arg2) ? arg2 : {};
  opts.get = arg1;
  opts.name || (opts.name = arg1.name || "");
  return new ComputedValue(opts);
};
Object.assign(computed, computedAnnotation);
computed.struct = /* @__PURE__ */ createDecoratorAnnotation(computedStructAnnotation);
var _getDescriptor$config, _getDescriptor;
var currentActionId = 0;
var nextActionId = 1;
var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /* @__PURE__ */ getDescriptor(function() {
}, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false;
var tmpNameDescriptor = {
  value: "action",
  configurable: true,
  writable: false,
  enumerable: false
};
function createAction(actionName, fn, autoAction2, ref) {
  if (autoAction2 === void 0) {
    autoAction2 = false;
  }
  function res() {
    return executeAction(actionName, autoAction2, fn, ref || this, arguments);
  }
  res.isMobxAction = true;
  res.toString = function() {
    return fn.toString();
  };
  if (isFunctionNameConfigurable) {
    tmpNameDescriptor.value = actionName;
    defineProperty(res, "name", tmpNameDescriptor);
  }
  return res;
}
function executeAction(actionName, canRunAsDerivation, fn, scope2, args) {
  var runInfo = _startAction(actionName, canRunAsDerivation);
  try {
    return fn.apply(scope2, args);
  } catch (err) {
    runInfo.error_ = err;
    throw err;
  } finally {
    _endAction(runInfo);
  }
}
function _startAction(actionName, canRunAsDerivation, scope2, args) {
  var notifySpy_ = false;
  var startTime_ = 0;
  var prevDerivation_ = globalState.trackingDerivation;
  var runAsAction = !canRunAsDerivation || !prevDerivation_;
  startBatch();
  var prevAllowStateChanges_ = globalState.allowStateChanges;
  if (runAsAction) {
    untrackedStart();
    prevAllowStateChanges_ = allowStateChangesStart(true);
  }
  var prevAllowStateReads_ = allowStateReadsStart(true);
  var runInfo = {
    runAsAction_: runAsAction,
    prevDerivation_,
    prevAllowStateChanges_,
    prevAllowStateReads_,
    notifySpy_,
    startTime_,
    actionId_: nextActionId++,
    parentActionId_: currentActionId
  };
  currentActionId = runInfo.actionId_;
  return runInfo;
}
function _endAction(runInfo) {
  if (currentActionId !== runInfo.actionId_) {
    die(30);
  }
  currentActionId = runInfo.parentActionId_;
  if (runInfo.error_ !== void 0) {
    globalState.suppressReactionErrors = true;
  }
  allowStateChangesEnd(runInfo.prevAllowStateChanges_);
  allowStateReadsEnd(runInfo.prevAllowStateReads_);
  endBatch();
  if (runInfo.runAsAction_) {
    untrackedEnd(runInfo.prevDerivation_);
  }
  globalState.suppressReactionErrors = false;
}
function allowStateChanges(allowStateChanges2, func) {
  var prev = allowStateChangesStart(allowStateChanges2);
  try {
    return func();
  } finally {
    allowStateChangesEnd(prev);
  }
}
function allowStateChangesStart(allowStateChanges2) {
  var prev = globalState.allowStateChanges;
  globalState.allowStateChanges = allowStateChanges2;
  return prev;
}
function allowStateChangesEnd(prev) {
  globalState.allowStateChanges = prev;
}
var ObservableValue = /* @__PURE__ */ function(_Atom) {
  function ObservableValue2(value, enhancer, name_, notifySpy, equals) {
    var _this;
    if (name_ === void 0) {
      name_ = "ObservableValue";
    }
    if (equals === void 0) {
      equals = comparer["default"];
    }
    _this = _Atom.call(this, name_) || this;
    _this.enhancer = void 0;
    _this.name_ = void 0;
    _this.equals = void 0;
    _this.hasUnreportedChange_ = false;
    _this.interceptors_ = void 0;
    _this.changeListeners_ = void 0;
    _this.value_ = void 0;
    _this.dehancer = void 0;
    _this.enhancer = enhancer;
    _this.name_ = name_;
    _this.equals = equals;
    _this.value_ = enhancer(value, void 0, name_);
    return _this;
  }
  _inheritsLoose(ObservableValue2, _Atom);
  var _proto = ObservableValue2.prototype;
  _proto.dehanceValue = function dehanceValue(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.set = function set5(newValue) {
    this.value_;
    newValue = this.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      this.setNewValue_(newValue);
    }
  };
  _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this,
        type: UPDATE,
        newValue
      });
      if (!change) {
        return globalState.UNCHANGED;
      }
      newValue = change.newValue;
    }
    newValue = this.enhancer(newValue, this.value_, this.name_);
    return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
  };
  _proto.setNewValue_ = function setNewValue_(newValue) {
    var oldValue = this.value_;
    this.value_ = newValue;
    this.reportChanged();
    if (hasListeners(this)) {
      notifyListeners(this, {
        type: UPDATE,
        object: this,
        newValue,
        oldValue
      });
    }
  };
  _proto.get = function get5() {
    this.reportObserved();
    return this.dehanceValue(this.value_);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately) {
      listener({
        observableKind: "value",
        debugObjectName: this.name_,
        object: this,
        type: UPDATE,
        newValue: this.value_,
        oldValue: void 0
      });
    }
    return registerListener(this, listener);
  };
  _proto.raw = function raw() {
    return this.value_;
  };
  _proto.toJSON = function toJSON4() {
    return this.get();
  };
  _proto.toString = function toString4() {
    return this.name_ + "[" + this.value_ + "]";
  };
  _proto.valueOf = function valueOf2() {
    return toPrimitive(this.get());
  };
  _proto[Symbol.toPrimitive] = function() {
    return this.valueOf();
  };
  return ObservableValue2;
}(Atom);
var isObservableValue = /* @__PURE__ */ createInstanceofPredicate("ObservableValue", ObservableValue);
var ComputedValue = /* @__PURE__ */ function() {
  function ComputedValue2(options) {
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.observing_ = [];
    this.newObserving_ = null;
    this.observers_ = /* @__PURE__ */ new Set();
    this.runId_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    this.unboundDepsCount_ = 0;
    this.value_ = new CaughtException(null);
    this.name_ = void 0;
    this.triggeredBy_ = void 0;
    this.flags_ = 0;
    this.derivation = void 0;
    this.setter_ = void 0;
    this.isTracing_ = TraceMode.NONE;
    this.scope_ = void 0;
    this.equals_ = void 0;
    this.requiresReaction_ = void 0;
    this.keepAlive_ = void 0;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    if (!options.get) {
      die(31);
    }
    this.derivation = options.get;
    this.name_ = options.name || "ComputedValue";
    if (options.set) {
      this.setter_ = createAction("ComputedValue-setter", options.set);
    }
    this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer["default"]);
    this.scope_ = options.context;
    this.requiresReaction_ = options.requiresReaction;
    this.keepAlive_ = !!options.keepAlive;
  }
  var _proto = ComputedValue2.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    propagateMaybeChanged(this);
  };
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.get = function get5() {
    if (this.isComputing) {
      die(32, this.name_, this.derivation);
    }
    if (globalState.inBatch === 0 && this.observers_.size === 0 && !this.keepAlive_) {
      if (shouldCompute(this)) {
        this.warnAboutUntrackedRead_();
        startBatch();
        this.value_ = this.computeValue_(false);
        endBatch();
      }
    } else {
      reportObserved(this);
      if (shouldCompute(this)) {
        var prevTrackingContext = globalState.trackingContext;
        if (this.keepAlive_ && !prevTrackingContext) {
          globalState.trackingContext = this;
        }
        if (this.trackAndCompute()) {
          propagateChangeConfirmed(this);
        }
        globalState.trackingContext = prevTrackingContext;
      }
    }
    var result = this.value_;
    if (isCaughtException(result)) {
      throw result.cause;
    }
    return result;
  };
  _proto.set = function set5(value) {
    if (this.setter_) {
      if (this.isRunningSetter) {
        die(33, this.name_);
      }
      this.isRunningSetter = true;
      try {
        this.setter_.call(this.scope_, value);
      } finally {
        this.isRunningSetter = false;
      }
    } else {
      die(34, this.name_);
    }
  };
  _proto.trackAndCompute = function trackAndCompute() {
    var oldValue = this.value_;
    var wasSuspended = this.dependenciesState_ === IDerivationState_.NOT_TRACKING_;
    var newValue = this.computeValue_(true);
    var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);
    if (changed) {
      this.value_ = newValue;
    }
    return changed;
  };
  _proto.computeValue_ = function computeValue_(track) {
    this.isComputing = true;
    var prev = allowStateChangesStart(false);
    var res;
    if (track) {
      res = trackDerivedFunction(this, this.derivation, this.scope_);
    } else {
      if (globalState.disableErrorBoundaries === true) {
        res = this.derivation.call(this.scope_);
      } else {
        try {
          res = this.derivation.call(this.scope_);
        } catch (e) {
          res = new CaughtException(e);
        }
      }
    }
    allowStateChangesEnd(prev);
    this.isComputing = false;
    return res;
  };
  _proto.suspend_ = function suspend_() {
    if (!this.keepAlive_) {
      clearObserving(this);
      this.value_ = void 0;
    }
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    var _this = this;
    var firstTime = true;
    var prevValue = void 0;
    return autorun(function() {
      var newValue = _this.get();
      if (!firstTime || fireImmediately) {
        var prevU = untrackedStart();
        listener({
          observableKind: "computed",
          debugObjectName: _this.name_,
          type: UPDATE,
          object: _this,
          newValue,
          oldValue: prevValue
        });
        untrackedEnd(prevU);
      }
      firstTime = false;
      prevValue = newValue;
    });
  };
  _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {
    {
      return;
    }
  };
  _proto.toString = function toString4() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  };
  _proto.valueOf = function valueOf2() {
    return toPrimitive(this.get());
  };
  _proto[Symbol.toPrimitive] = function() {
    return this.valueOf();
  };
  return _createClass(ComputedValue2, [{
    key: "isComputing",
    get: function get5() {
      return getFlag(this.flags_, ComputedValue2.isComputingMask_);
    },
    set: function set5(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue2.isComputingMask_, newValue);
    }
  }, {
    key: "isRunningSetter",
    get: function get5() {
      return getFlag(this.flags_, ComputedValue2.isRunningSetterMask_);
    },
    set: function set5(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue2.isRunningSetterMask_, newValue);
    }
  }, {
    key: "isBeingObserved",
    get: function get5() {
      return getFlag(this.flags_, ComputedValue2.isBeingObservedMask_);
    },
    set: function set5(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue2.isBeingObservedMask_, newValue);
    }
  }, {
    key: "isPendingUnobservation",
    get: function get5() {
      return getFlag(this.flags_, ComputedValue2.isPendingUnobservationMask_);
    },
    set: function set5(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue2.isPendingUnobservationMask_, newValue);
    }
  }, {
    key: "diffValue",
    get: function get5() {
      return getFlag(this.flags_, ComputedValue2.diffValueMask_) ? 1 : 0;
    },
    set: function set5(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue2.diffValueMask_, newValue === 1 ? true : false);
    }
  }]);
}();
ComputedValue.isComputingMask_ = 1;
ComputedValue.isRunningSetterMask_ = 2;
ComputedValue.isBeingObservedMask_ = 4;
ComputedValue.isPendingUnobservationMask_ = 8;
ComputedValue.diffValueMask_ = 16;
var isComputedValue = /* @__PURE__ */ createInstanceofPredicate("ComputedValue", ComputedValue);
var IDerivationState_;
(function(IDerivationState_2) {
  IDerivationState_2[IDerivationState_2["NOT_TRACKING_"] = -1] = "NOT_TRACKING_";
  IDerivationState_2[IDerivationState_2["UP_TO_DATE_"] = 0] = "UP_TO_DATE_";
  IDerivationState_2[IDerivationState_2["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_";
  IDerivationState_2[IDerivationState_2["STALE_"] = 2] = "STALE_";
})(IDerivationState_ || (IDerivationState_ = {}));
var TraceMode;
(function(TraceMode2) {
  TraceMode2[TraceMode2["NONE"] = 0] = "NONE";
  TraceMode2[TraceMode2["LOG"] = 1] = "LOG";
  TraceMode2[TraceMode2["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));
var CaughtException = function CaughtException2(cause) {
  this.cause = void 0;
  this.cause = cause;
};
function isCaughtException(e) {
  return e instanceof CaughtException;
}
function shouldCompute(derivation) {
  switch (derivation.dependenciesState_) {
    case IDerivationState_.UP_TO_DATE_:
      return false;
    case IDerivationState_.NOT_TRACKING_:
    case IDerivationState_.STALE_:
      return true;
    case IDerivationState_.POSSIBLY_STALE_: {
      var prevAllowStateReads = allowStateReadsStart(true);
      var prevUntracked = untrackedStart();
      var obs = derivation.observing_, l2 = obs.length;
      for (var i = 0; i < l2; i++) {
        var obj = obs[i];
        if (isComputedValue(obj)) {
          if (globalState.disableErrorBoundaries) {
            obj.get();
          } else {
            try {
              obj.get();
            } catch (e) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
          if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
            untrackedEnd(prevUntracked);
            allowStateReadsEnd(prevAllowStateReads);
            return true;
          }
        }
      }
      changeDependenciesStateTo0(derivation);
      untrackedEnd(prevUntracked);
      allowStateReadsEnd(prevAllowStateReads);
      return false;
    }
  }
}
function checkIfStateModificationsAreAllowed(atom) {
  {
    return;
  }
}
function trackDerivedFunction(derivation, f2, context) {
  var prevAllowStateReads = allowStateReadsStart(true);
  changeDependenciesStateTo0(derivation);
  derivation.newObserving_ = new Array(
    derivation.runId_ === 0 ? 100 : derivation.observing_.length
  );
  derivation.unboundDepsCount_ = 0;
  derivation.runId_ = ++globalState.runId;
  var prevTracking = globalState.trackingDerivation;
  globalState.trackingDerivation = derivation;
  globalState.inBatch++;
  var result;
  if (globalState.disableErrorBoundaries === true) {
    result = f2.call(context);
  } else {
    try {
      result = f2.call(context);
    } catch (e) {
      result = new CaughtException(e);
    }
  }
  globalState.inBatch--;
  globalState.trackingDerivation = prevTracking;
  bindDependencies(derivation);
  allowStateReadsEnd(prevAllowStateReads);
  return result;
}
function bindDependencies(derivation) {
  var prevObserving = derivation.observing_;
  var observing = derivation.observing_ = derivation.newObserving_;
  var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;
  var i0 = 0, l2 = derivation.unboundDepsCount_;
  for (var i = 0; i < l2; i++) {
    var dep = observing[i];
    if (dep.diffValue === 0) {
      dep.diffValue = 1;
      if (i0 !== i) {
        observing[i0] = dep;
      }
      i0++;
    }
    if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState_;
    }
  }
  observing.length = i0;
  derivation.newObserving_ = null;
  l2 = prevObserving.length;
  while (l2--) {
    var _dep = prevObserving[l2];
    if (_dep.diffValue === 0) {
      removeObserver(_dep, derivation);
    }
    _dep.diffValue = 0;
  }
  while (i0--) {
    var _dep2 = observing[i0];
    if (_dep2.diffValue === 1) {
      _dep2.diffValue = 0;
      addObserver(_dep2, derivation);
    }
  }
  if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
    derivation.dependenciesState_ = lowestNewObservingDerivationState;
    derivation.onBecomeStale_();
  }
}
function clearObserving(derivation) {
  var obs = derivation.observing_;
  derivation.observing_ = [];
  var i = obs.length;
  while (i--) {
    removeObserver(obs[i], derivation);
  }
  derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
}
function untracked(action2) {
  var prev = untrackedStart();
  try {
    return action2();
  } finally {
    untrackedEnd(prev);
  }
}
function untrackedStart() {
  var prev = globalState.trackingDerivation;
  globalState.trackingDerivation = null;
  return prev;
}
function untrackedEnd(prev) {
  globalState.trackingDerivation = prev;
}
function allowStateReadsStart(allowStateReads) {
  var prev = globalState.allowStateReads;
  globalState.allowStateReads = allowStateReads;
  return prev;
}
function allowStateReadsEnd(prev) {
  globalState.allowStateReads = prev;
}
function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
    return;
  }
  derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
  var obs = derivation.observing_;
  var i = obs.length;
  while (i--) {
    obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }
}
var MobXGlobals = function MobXGlobals2() {
  this.version = 6;
  this.UNCHANGED = {};
  this.trackingDerivation = null;
  this.trackingContext = null;
  this.runId = 0;
  this.mobxGuid = 0;
  this.inBatch = 0;
  this.pendingUnobservations = [];
  this.pendingReactions = [];
  this.isRunningReactions = false;
  this.allowStateChanges = false;
  this.allowStateReads = true;
  this.enforceActions = true;
  this.spyListeners = [];
  this.globalReactionErrorHandlers = [];
  this.computedRequiresReaction = false;
  this.reactionRequiresObservable = false;
  this.observableRequiresReaction = false;
  this.disableErrorBoundaries = false;
  this.suppressReactionErrors = false;
  this.useProxies = true;
  this.verifyProxies = false;
  this.safeDescriptors = true;
};
var canMergeGlobalState = true;
var isolateCalled = false;
var globalState = /* @__PURE__ */ function() {
  var global2 = /* @__PURE__ */ getGlobal();
  if (global2.__mobxInstanceCount > 0 && !global2.__mobxGlobals) {
    canMergeGlobalState = false;
  }
  if (global2.__mobxGlobals && global2.__mobxGlobals.version !== new MobXGlobals().version) {
    canMergeGlobalState = false;
  }
  if (!canMergeGlobalState) {
    setTimeout(function() {
      if (!isolateCalled) {
        die(35);
      }
    }, 1);
    return new MobXGlobals();
  } else if (global2.__mobxGlobals) {
    global2.__mobxInstanceCount += 1;
    if (!global2.__mobxGlobals.UNCHANGED) {
      global2.__mobxGlobals.UNCHANGED = {};
    }
    return global2.__mobxGlobals;
  } else {
    global2.__mobxInstanceCount = 1;
    return global2.__mobxGlobals = /* @__PURE__ */ new MobXGlobals();
  }
}();
function isolateGlobalState() {
  if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) {
    die(36);
  }
  isolateCalled = true;
  if (canMergeGlobalState) {
    var global2 = getGlobal();
    if (--global2.__mobxInstanceCount === 0) {
      global2.__mobxGlobals = void 0;
    }
    globalState = new MobXGlobals();
  }
}
function addObserver(observable2, node) {
  observable2.observers_.add(node);
  if (observable2.lowestObserverState_ > node.dependenciesState_) {
    observable2.lowestObserverState_ = node.dependenciesState_;
  }
}
function removeObserver(observable2, node) {
  observable2.observers_["delete"](node);
  if (observable2.observers_.size === 0) {
    queueForUnobservation(observable2);
  }
}
function queueForUnobservation(observable2) {
  if (observable2.isPendingUnobservation === false) {
    observable2.isPendingUnobservation = true;
    globalState.pendingUnobservations.push(observable2);
  }
}
function startBatch() {
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions();
    var list = globalState.pendingUnobservations;
    for (var i = 0; i < list.length; i++) {
      var observable2 = list[i];
      observable2.isPendingUnobservation = false;
      if (observable2.observers_.size === 0) {
        if (observable2.isBeingObserved) {
          observable2.isBeingObserved = false;
          observable2.onBUO();
        }
        if (observable2 instanceof ComputedValue) {
          observable2.suspend_();
        }
      }
    }
    globalState.pendingUnobservations = [];
  }
}
function reportObserved(observable2) {
  var derivation = globalState.trackingDerivation;
  if (derivation !== null) {
    if (derivation.runId_ !== observable2.lastAccessedBy_) {
      observable2.lastAccessedBy_ = derivation.runId_;
      derivation.newObserving_[derivation.unboundDepsCount_++] = observable2;
      if (!observable2.isBeingObserved && globalState.trackingContext) {
        observable2.isBeingObserved = true;
        observable2.onBO();
      }
    }
    return observable2.isBeingObserved;
  } else if (observable2.observers_.size === 0 && globalState.inBatch > 0) {
    queueForUnobservation(observable2);
  }
  return false;
}
function propagateChanged(observable2) {
  if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.STALE_;
  observable2.observers_.forEach(function(d) {
    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d.onBecomeStale_();
    }
    d.dependenciesState_ = IDerivationState_.STALE_;
  });
}
function propagateChangeConfirmed(observable2) {
  if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.STALE_;
  observable2.observers_.forEach(function(d) {
    if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
      d.dependenciesState_ = IDerivationState_.STALE_;
    } else if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      observable2.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    }
  });
}
function propagateMaybeChanged(observable2) {
  if (observable2.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
  observable2.observers_.forEach(function(d) {
    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
      d.onBecomeStale_();
    }
  });
}
var Reaction = /* @__PURE__ */ function() {
  function Reaction2(name_, onInvalidate_, errorHandler_, requiresObservable_) {
    if (name_ === void 0) {
      name_ = "Reaction";
    }
    this.name_ = void 0;
    this.onInvalidate_ = void 0;
    this.errorHandler_ = void 0;
    this.requiresObservable_ = void 0;
    this.observing_ = [];
    this.newObserving_ = [];
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.runId_ = 0;
    this.unboundDepsCount_ = 0;
    this.flags_ = 0;
    this.isTracing_ = TraceMode.NONE;
    this.name_ = name_;
    this.onInvalidate_ = onInvalidate_;
    this.errorHandler_ = errorHandler_;
    this.requiresObservable_ = requiresObservable_;
  }
  var _proto = Reaction2.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    this.schedule_();
  };
  _proto.schedule_ = function schedule_() {
    if (!this.isScheduled) {
      this.isScheduled = true;
      globalState.pendingReactions.push(this);
      runReactions();
    }
  };
  _proto.runReaction_ = function runReaction_() {
    if (!this.isDisposed) {
      startBatch();
      this.isScheduled = false;
      var prev = globalState.trackingContext;
      globalState.trackingContext = this;
      if (shouldCompute(this)) {
        this.isTrackPending = true;
        try {
          this.onInvalidate_();
          if (false)
            ;
        } catch (e) {
          this.reportExceptionInDerivation_(e);
        }
      }
      globalState.trackingContext = prev;
      endBatch();
    }
  };
  _proto.track = function track(fn) {
    if (this.isDisposed) {
      return;
    }
    startBatch();
    this.isRunning = true;
    var prevReaction = globalState.trackingContext;
    globalState.trackingContext = this;
    var result = trackDerivedFunction(this, fn, void 0);
    globalState.trackingContext = prevReaction;
    this.isRunning = false;
    this.isTrackPending = false;
    if (this.isDisposed) {
      clearObserving(this);
    }
    if (isCaughtException(result)) {
      this.reportExceptionInDerivation_(result.cause);
    }
    endBatch();
  };
  _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
    var _this = this;
    if (this.errorHandler_) {
      this.errorHandler_(error, this);
      return;
    }
    if (globalState.disableErrorBoundaries) {
      throw error;
    }
    var message2 = "[mobx] uncaught error in '" + this + "'";
    if (!globalState.suppressReactionErrors) {
      console.error(message2, error);
    }
    globalState.globalReactionErrorHandlers.forEach(function(f2) {
      return f2(error, _this);
    });
  };
  _proto.dispose = function dispose() {
    if (!this.isDisposed) {
      this.isDisposed = true;
      if (!this.isRunning) {
        startBatch();
        clearObserving(this);
        endBatch();
      }
    }
  };
  _proto.getDisposer_ = function getDisposer_(abortSignal) {
    var _this2 = this;
    var dispose = function dispose2() {
      _this2.dispose();
      abortSignal == null || abortSignal.removeEventListener == null || abortSignal.removeEventListener("abort", dispose2);
    };
    abortSignal == null || abortSignal.addEventListener == null || abortSignal.addEventListener("abort", dispose);
    dispose[$mobx] = this;
    return dispose;
  };
  _proto.toString = function toString4() {
    return "Reaction[" + this.name_ + "]";
  };
  _proto.trace = function trace$1(enterBreakPoint) {
  };
  return _createClass(Reaction2, [{
    key: "isDisposed",
    get: function get5() {
      return getFlag(this.flags_, Reaction2.isDisposedMask_);
    },
    set: function set5(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction2.isDisposedMask_, newValue);
    }
  }, {
    key: "isScheduled",
    get: function get5() {
      return getFlag(this.flags_, Reaction2.isScheduledMask_);
    },
    set: function set5(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction2.isScheduledMask_, newValue);
    }
  }, {
    key: "isTrackPending",
    get: function get5() {
      return getFlag(this.flags_, Reaction2.isTrackPendingMask_);
    },
    set: function set5(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction2.isTrackPendingMask_, newValue);
    }
  }, {
    key: "isRunning",
    get: function get5() {
      return getFlag(this.flags_, Reaction2.isRunningMask_);
    },
    set: function set5(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction2.isRunningMask_, newValue);
    }
  }, {
    key: "diffValue",
    get: function get5() {
      return getFlag(this.flags_, Reaction2.diffValueMask_) ? 1 : 0;
    },
    set: function set5(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction2.diffValueMask_, newValue === 1 ? true : false);
    }
  }]);
}();
Reaction.isDisposedMask_ = 1;
Reaction.isScheduledMask_ = 2;
Reaction.isTrackPendingMask_ = 4;
Reaction.isRunningMask_ = 8;
Reaction.diffValueMask_ = 16;
var MAX_REACTION_ITERATIONS = 100;
var reactionScheduler = function reactionScheduler2(f2) {
  return f2();
};
function runReactions() {
  if (globalState.inBatch > 0 || globalState.isRunningReactions) {
    return;
  }
  reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
  globalState.isRunningReactions = true;
  var allReactions = globalState.pendingReactions;
  var iterations = 0;
  while (allReactions.length > 0) {
    if (++iterations === MAX_REACTION_ITERATIONS) {
      console.error("[mobx] cycle in reaction: " + allReactions[0]);
      allReactions.splice(0);
    }
    var remainingReactions = allReactions.splice(0);
    for (var i = 0, l2 = remainingReactions.length; i < l2; i++) {
      remainingReactions[i].runReaction_();
    }
  }
  globalState.isRunningReactions = false;
}
var isReaction = /* @__PURE__ */ createInstanceofPredicate("Reaction", Reaction);
function setReactionScheduler(fn) {
  var baseScheduler = reactionScheduler;
  reactionScheduler = function reactionScheduler3(f2) {
    return fn(function() {
      return baseScheduler(f2);
    });
  };
}
function isSpyEnabled() {
  return false;
}
function spyReport(event) {
  {
    return;
  }
}
function spyReportStart(event) {
  {
    return;
  }
}
function spyReportEnd(change) {
  {
    return;
  }
}
function spy(listener) {
  {
    console.warn("[mobx.spy] Is a no-op in production builds");
    return function() {
    };
  }
}
var ACTION = "action";
var ACTION_BOUND = "action.bound";
var AUTOACTION = "autoAction";
var AUTOACTION_BOUND = "autoAction.bound";
var DEFAULT_ACTION_NAME = "<unnamed action>";
var actionAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION);
var actionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION_BOUND, {
  bound: true
});
var autoActionAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION, {
  autoAction: true
});
var autoActionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION_BOUND, {
  autoAction: true,
  bound: true
});
function createActionFactory(autoAction2) {
  var res = function action2(arg1, arg2) {
    if (isFunction$1(arg1)) {
      return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction2);
    }
    if (isFunction$1(arg2)) {
      return createAction(arg1, arg2, autoAction2);
    }
    if (is20223Decorator(arg2)) {
      return (autoAction2 ? autoActionAnnotation : actionAnnotation).decorate_20223_(arg1, arg2);
    }
    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, autoAction2 ? autoActionAnnotation : actionAnnotation);
    }
    if (isStringish(arg1)) {
      return createDecoratorAnnotation(createActionAnnotation(autoAction2 ? AUTOACTION : ACTION, {
        name: arg1,
        autoAction: autoAction2
      }));
    }
  };
  return res;
}
var action = /* @__PURE__ */ createActionFactory(false);
Object.assign(action, actionAnnotation);
var autoAction = /* @__PURE__ */ createActionFactory(true);
Object.assign(autoAction, autoActionAnnotation);
action.bound = /* @__PURE__ */ createDecoratorAnnotation(actionBoundAnnotation);
autoAction.bound = /* @__PURE__ */ createDecoratorAnnotation(autoActionBoundAnnotation);
function isAction(thing) {
  return isFunction$1(thing) && thing.isMobxAction === true;
}
function autorun(view, opts) {
  var _opts$name, _opts, _opts2, _opts3;
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name : "Autorun";
  var runSync = !opts.scheduler && !opts.delay;
  var reaction2;
  if (runSync) {
    reaction2 = new Reaction(name, function() {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler = createSchedulerFromOptions(opts);
    var isScheduled = false;
    reaction2 = new Reaction(name, function() {
      if (!isScheduled) {
        isScheduled = true;
        scheduler(function() {
          isScheduled = false;
          if (!reaction2.isDisposed) {
            reaction2.track(reactionRunner);
          }
        });
      }
    }, opts.onError, opts.requiresObservable);
  }
  function reactionRunner() {
    view(reaction2);
  }
  if (!((_opts2 = opts) != null && (_opts2 = _opts2.signal) != null && _opts2.aborted)) {
    reaction2.schedule_();
  }
  return reaction2.getDisposer_((_opts3 = opts) == null ? void 0 : _opts3.signal);
}
var run = function run2(f2) {
  return f2();
};
function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function(f2) {
    return setTimeout(f2, opts.delay);
  } : run;
}
function reaction(expression, effect, opts) {
  var _opts$name2, _opts4, _opts5;
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  var name = (_opts$name2 = opts.name) != null ? _opts$name2 : "Reaction";
  var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);
  var runSync = !opts.scheduler && !opts.delay;
  var scheduler = createSchedulerFromOptions(opts);
  var firstTime = true;
  var isScheduled = false;
  var value;
  var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer["default"];
  var r2 = new Reaction(name, function() {
    if (firstTime || runSync) {
      reactionRunner();
    } else if (!isScheduled) {
      isScheduled = true;
      scheduler(reactionRunner);
    }
  }, opts.onError, opts.requiresObservable);
  function reactionRunner() {
    isScheduled = false;
    if (r2.isDisposed) {
      return;
    }
    var changed = false;
    var oldValue = value;
    r2.track(function() {
      var nextValue = allowStateChanges(false, function() {
        return expression(r2);
      });
      changed = firstTime || !equals(value, nextValue);
      value = nextValue;
    });
    if (firstTime && opts.fireImmediately) {
      effectAction(value, oldValue, r2);
    } else if (!firstTime && changed) {
      effectAction(value, oldValue, r2);
    }
    firstTime = false;
  }
  if (!((_opts4 = opts) != null && (_opts4 = _opts4.signal) != null && _opts4.aborted)) {
    r2.schedule_();
  }
  return r2.getDisposer_((_opts5 = opts) == null ? void 0 : _opts5.signal);
}
function wrapErrorHandler(errorHandler, baseFn) {
  return function() {
    try {
      return baseFn.apply(this, arguments);
    } catch (e) {
      errorHandler.call(this, e);
    }
  };
}
var ON_BECOME_OBSERVED = "onBO";
var ON_BECOME_UNOBSERVED = "onBUO";
function onBecomeObserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
}
function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
}
function interceptHook(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
  var cb = isFunction$1(arg3) ? arg3 : arg2;
  var listenersKey = hook + "L";
  if (atom[listenersKey]) {
    atom[listenersKey].add(cb);
  } else {
    atom[listenersKey] = /* @__PURE__ */ new Set([cb]);
  }
  return function() {
    var hookListeners = atom[listenersKey];
    if (hookListeners) {
      hookListeners["delete"](cb);
      if (hookListeners.size === 0) {
        delete atom[listenersKey];
      }
    }
  };
}
var NEVER = "never";
var ALWAYS = "always";
var OBSERVED = "observed";
function configure(options) {
  if (options.isolateGlobalState === true) {
    isolateGlobalState();
  }
  var useProxies = options.useProxies, enforceActions = options.enforceActions;
  if (useProxies !== void 0) {
    globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== "undefined";
  }
  if (useProxies === "ifavailable") {
    globalState.verifyProxies = true;
  }
  if (enforceActions !== void 0) {
    var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;
    globalState.enforceActions = ea;
    globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true;
  }
  ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function(key) {
    if (key in options) {
      globalState[key] = !!options[key];
    }
  });
  globalState.allowStateReads = !globalState.observableRequiresReaction;
  if (options.reactionScheduler) {
    setReactionScheduler(options.reactionScheduler);
  }
}
function extendObservable(target, properties, annotations, options) {
  var descriptors2 = getOwnPropertyDescriptors(properties);
  initObservable(function() {
    var adm = asObservableObject(target, options)[$mobx];
    ownKeys(descriptors2).forEach(function(key) {
      adm.extend_(
        key,
        descriptors2[key],
        !annotations ? true : key in annotations ? annotations[key] : true
      );
    });
  });
  return target;
}
function getDependencyTree(thing, property2) {
  return nodeToDependencyTree(getAtom(thing, property2));
}
function nodeToDependencyTree(node) {
  var result = {
    name: node.name_
  };
  if (node.observing_ && node.observing_.length > 0) {
    result.dependencies = unique(node.observing_).map(nodeToDependencyTree);
  }
  return result;
}
function unique(list) {
  return Array.from(new Set(list));
}
var generatorId = 0;
function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}
FlowCancellationError.prototype = /* @__PURE__ */ Object.create(Error.prototype);
var flowAnnotation = /* @__PURE__ */ createFlowAnnotation("flow");
var flowBoundAnnotation = /* @__PURE__ */ createFlowAnnotation("flow.bound", {
  bound: true
});
var flow = /* @__PURE__ */ Object.assign(function flow2(arg1, arg2) {
  if (is20223Decorator(arg2)) {
    return flowAnnotation.decorate_20223_(arg1, arg2);
  }
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, flowAnnotation);
  }
  var generator = arg1;
  var name = generator.name || "<unnamed flow>";
  var res = function res2() {
    var ctx = this;
    var args = arguments;
    var runId = ++generatorId;
    var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
    var rejector;
    var pendingPromise = void 0;
    var promise = new Promise(function(resolve, reject) {
      var stepId = 0;
      rejector = reject;
      function onFulfilled(res3) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res3);
        } catch (e) {
          return reject(e);
        }
        next(ret);
      }
      function onRejected(err) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
        } catch (e) {
          return reject(e);
        }
        next(ret);
      }
      function next(ret) {
        if (isFunction$1(ret == null ? void 0 : ret.then)) {
          ret.then(next, reject);
          return;
        }
        if (ret.done) {
          return resolve(ret.value);
        }
        pendingPromise = Promise.resolve(ret.value);
        return pendingPromise.then(onFulfilled, onRejected);
      }
      onFulfilled(void 0);
    });
    promise.cancel = action(name + " - runid: " + runId + " - cancel", function() {
      try {
        if (pendingPromise) {
          cancelPromise(pendingPromise);
        }
        var _res = gen["return"](void 0);
        var yieldedPromise = Promise.resolve(_res.value);
        yieldedPromise.then(noop$1, noop$1);
        cancelPromise(yieldedPromise);
        rejector(new FlowCancellationError());
      } catch (e) {
        rejector(e);
      }
    });
    return promise;
  };
  res.isMobXFlow = true;
  return res;
}, flowAnnotation);
flow.bound = /* @__PURE__ */ createDecoratorAnnotation(flowBoundAnnotation);
function cancelPromise(promise) {
  if (isFunction$1(promise.cancel)) {
    promise.cancel();
  }
}
function isFlow(fn) {
  return (fn == null ? void 0 : fn.isMobXFlow) === true;
}
function _isObservable(value, property2) {
  if (!value) {
    return false;
  }
  if (property2 !== void 0) {
    if (isObservableObject(value)) {
      return value[$mobx].values_.has(property2);
    }
    return false;
  }
  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
}
function isObservable(value) {
  return _isObservable(value);
}
function apiOwnKeys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].ownKeys_();
  }
  die(38);
}
function cache(map3, key, value) {
  map3.set(key, value);
  return value;
}
function toJSHelper(source, __alreadySeen) {
  if (source == null || typeof source !== "object" || source instanceof Date || !isObservable(source)) {
    return source;
  }
  if (isObservableValue(source) || isComputedValue(source)) {
    return toJSHelper(source.get(), __alreadySeen);
  }
  if (__alreadySeen.has(source)) {
    return __alreadySeen.get(source);
  }
  if (isObservableArray(source)) {
    var res = cache(__alreadySeen, source, new Array(source.length));
    source.forEach(function(value, idx) {
      res[idx] = toJSHelper(value, __alreadySeen);
    });
    return res;
  }
  if (isObservableSet(source)) {
    var _res = cache(__alreadySeen, source, /* @__PURE__ */ new Set());
    source.forEach(function(value) {
      _res.add(toJSHelper(value, __alreadySeen));
    });
    return _res;
  }
  if (isObservableMap(source)) {
    var _res2 = cache(__alreadySeen, source, /* @__PURE__ */ new Map());
    source.forEach(function(value, key) {
      _res2.set(key, toJSHelper(value, __alreadySeen));
    });
    return _res2;
  } else {
    var _res3 = cache(__alreadySeen, source, {});
    apiOwnKeys(source).forEach(function(key) {
      if (objectPrototype.propertyIsEnumerable.call(source, key)) {
        _res3[key] = toJSHelper(source[key], __alreadySeen);
      }
    });
    return _res3;
  }
}
function toJS(source, options) {
  return toJSHelper(source, /* @__PURE__ */ new Map());
}
function transaction(action2, thisArg) {
  if (thisArg === void 0) {
    thisArg = void 0;
  }
  startBatch();
  try {
    return action2.apply(thisArg);
  } finally {
    endBatch();
  }
}
function getAdm(target) {
  return target[$mobx];
}
var objectProxyTraps = {
  has: function has(target, name) {
    return getAdm(target).has_(name);
  },
  get: function get2(target, name) {
    return getAdm(target).get_(name);
  },
  set: function set2(target, name, value) {
    var _getAdm$set_;
    if (!isStringish(name)) {
      return false;
    }
    return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;
  },
  deleteProperty: function deleteProperty(target, name) {
    var _getAdm$delete_;
    if (!isStringish(name)) {
      return false;
    }
    return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;
  },
  defineProperty: function defineProperty2(target, name, descriptor) {
    var _getAdm$definePropert;
    return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;
  },
  ownKeys: function ownKeys2(target) {
    return getAdm(target).ownKeys_();
  },
  preventExtensions: function preventExtensions(target) {
    die(13);
  }
};
function asDynamicObservableObject(target, options) {
  var _target$$mobx, _target$$mobx$proxy_;
  assertProxies();
  target = asObservableObject(target, options);
  return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
}
function hasInterceptors(interceptable) {
  return interceptable.interceptors_ !== void 0 && interceptable.interceptors_.length > 0;
}
function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
  interceptors.push(handler);
  return once(function() {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1) {
      interceptors.splice(idx, 1);
    }
  });
}
function interceptChange(interceptable, change) {
  var prevU = untrackedStart();
  try {
    var interceptors = [].concat(interceptable.interceptors_ || []);
    for (var i = 0, l2 = interceptors.length; i < l2; i++) {
      change = interceptors[i](change);
      if (change && !change.type) {
        die(14);
      }
      if (!change) {
        break;
      }
    }
    return change;
  } finally {
    untrackedEnd(prevU);
  }
}
function hasListeners(listenable) {
  return listenable.changeListeners_ !== void 0 && listenable.changeListeners_.length > 0;
}
function registerListener(listenable, handler) {
  var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
  listeners.push(handler);
  return once(function() {
    var idx = listeners.indexOf(handler);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
  });
}
function notifyListeners(listenable, change) {
  var prevU = untrackedStart();
  var listeners = listenable.changeListeners_;
  if (!listeners) {
    return;
  }
  listeners = listeners.slice();
  for (var i = 0, l2 = listeners.length; i < l2; i++) {
    listeners[i](change);
  }
  untrackedEnd(prevU);
}
function makeObservable(target, annotations, options) {
  initObservable(function() {
    var _annotations;
    var adm = asObservableObject(target, options)[$mobx];
    if (false)
      ;
    (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target);
    ownKeys(annotations).forEach(function(key) {
      return adm.make_(key, annotations[key]);
    });
  });
  return target;
}
var SPLICE = "splice";
var UPDATE = "update";
var MAX_SPLICE_SIZE = 1e4;
var arrayTraps = {
  get: function get3(target, name) {
    var adm = target[$mobx];
    if (name === $mobx) {
      return adm;
    }
    if (name === "length") {
      return adm.getArrayLength_();
    }
    if (typeof name === "string" && !isNaN(name)) {
      return adm.get_(parseInt(name));
    }
    if (hasProp(arrayExtensions, name)) {
      return arrayExtensions[name];
    }
    return target[name];
  },
  set: function set3(target, name, value) {
    var adm = target[$mobx];
    if (name === "length") {
      adm.setArrayLength_(value);
    }
    if (typeof name === "symbol" || isNaN(name)) {
      target[name] = value;
    } else {
      adm.set_(parseInt(name), value);
    }
    return true;
  },
  preventExtensions: function preventExtensions2() {
    die(15);
  }
};
var ObservableArrayAdministration = /* @__PURE__ */ function() {
  function ObservableArrayAdministration2(name, enhancer, owned_, legacyMode_) {
    if (name === void 0) {
      name = "ObservableArray";
    }
    this.owned_ = void 0;
    this.legacyMode_ = void 0;
    this.atom_ = void 0;
    this.values_ = [];
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.enhancer_ = void 0;
    this.dehancer = void 0;
    this.proxy_ = void 0;
    this.lastKnownLength_ = 0;
    this.owned_ = owned_;
    this.legacyMode_ = legacyMode_;
    this.atom_ = new Atom(name);
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, "ObservableArray[..]");
    };
  }
  var _proto = ObservableArrayAdministration2.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.dehanceValues_ = function dehanceValues_(values) {
    if (this.dehancer !== void 0 && values.length > 0) {
      return values.map(this.dehancer);
    }
    return values;
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }
    if (fireImmediately) {
      listener({
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: "splice",
        index: 0,
        added: this.values_.slice(),
        addedCount: this.values_.length,
        removed: [],
        removedCount: 0
      });
    }
    return registerListener(this, listener);
  };
  _proto.getArrayLength_ = function getArrayLength_() {
    this.atom_.reportObserved();
    return this.values_.length;
  };
  _proto.setArrayLength_ = function setArrayLength_(newLength) {
    if (typeof newLength !== "number" || isNaN(newLength) || newLength < 0) {
      die("Out of range: " + newLength);
    }
    var currentLength = this.values_.length;
    if (newLength === currentLength) {
      return;
    } else if (newLength > currentLength) {
      var newItems = new Array(newLength - currentLength);
      for (var i = 0; i < newLength - currentLength; i++) {
        newItems[i] = void 0;
      }
      this.spliceWithArray_(currentLength, 0, newItems);
    } else {
      this.spliceWithArray_(newLength, currentLength - newLength);
    }
  };
  _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
    if (oldLength !== this.lastKnownLength_) {
      die(16);
    }
    this.lastKnownLength_ += delta;
    if (this.legacyMode_ && delta > 0) {
      reserveArrayBuffer(oldLength + delta + 1);
    }
  };
  _proto.spliceWithArray_ = function spliceWithArray_(index2, deleteCount, newItems) {
    var _this = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    var length = this.values_.length;
    if (index2 === void 0) {
      index2 = 0;
    } else if (index2 > length) {
      index2 = length;
    } else if (index2 < 0) {
      index2 = Math.max(0, length + index2);
    }
    if (arguments.length === 1) {
      deleteCount = length - index2;
    } else if (deleteCount === void 0 || deleteCount === null) {
      deleteCount = 0;
    } else {
      deleteCount = Math.max(0, Math.min(deleteCount, length - index2));
    }
    if (newItems === void 0) {
      newItems = EMPTY_ARRAY;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_,
        type: SPLICE,
        index: index2,
        removedCount: deleteCount,
        added: newItems
      });
      if (!change) {
        return EMPTY_ARRAY;
      }
      deleteCount = change.removedCount;
      newItems = change.added;
    }
    newItems = newItems.length === 0 ? newItems : newItems.map(function(v) {
      return _this.enhancer_(v, void 0);
    });
    if (this.legacyMode_ || false) {
      var lengthDelta = newItems.length - deleteCount;
      this.updateArrayLength_(length, lengthDelta);
    }
    var res = this.spliceItemsIntoValues_(index2, deleteCount, newItems);
    if (deleteCount !== 0 || newItems.length !== 0) {
      this.notifyArraySplice_(index2, newItems, res);
    }
    return this.dehanceValues_(res);
  };
  _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index2, deleteCount, newItems) {
    if (newItems.length < MAX_SPLICE_SIZE) {
      var _this$values_;
      return (_this$values_ = this.values_).splice.apply(_this$values_, [index2, deleteCount].concat(newItems));
    } else {
      var res = this.values_.slice(index2, index2 + deleteCount);
      var oldItems = this.values_.slice(index2 + deleteCount);
      this.values_.length += newItems.length - deleteCount;
      for (var i = 0; i < newItems.length; i++) {
        this.values_[index2 + i] = newItems[i];
      }
      for (var _i = 0; _i < oldItems.length; _i++) {
        this.values_[index2 + newItems.length + _i] = oldItems[_i];
      }
      return res;
    }
  };
  _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index2, newValue, oldValue) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      type: UPDATE,
      debugObjectName: this.atom_.name_,
      index: index2,
      newValue,
      oldValue
    } : null;
    this.atom_.reportChanged();
    if (notify) {
      notifyListeners(this, change);
    }
  };
  _proto.notifyArraySplice_ = function notifyArraySplice_(index2, added, removed) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: SPLICE,
      index: index2,
      removed,
      added,
      removedCount: removed.length,
      addedCount: added.length
    } : null;
    this.atom_.reportChanged();
    if (notify) {
      notifyListeners(this, change);
    }
  };
  _proto.get_ = function get_(index2) {
    if (this.legacyMode_ && index2 >= this.values_.length) {
      console.warn("[mobx] Out of bounds read: " + index2);
      return void 0;
    }
    this.atom_.reportObserved();
    return this.dehanceValue_(this.values_[index2]);
  };
  _proto.set_ = function set_(index2, newValue) {
    var values = this.values_;
    if (this.legacyMode_ && index2 > values.length) {
      die(17, index2, values.length);
    }
    if (index2 < values.length) {
      checkIfStateModificationsAreAllowed(this.atom_);
      var oldValue = values[index2];
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_,
          index: index2,
          newValue
        });
        if (!change) {
          return;
        }
        newValue = change.newValue;
      }
      newValue = this.enhancer_(newValue, oldValue);
      var changed = newValue !== oldValue;
      if (changed) {
        values[index2] = newValue;
        this.notifyArrayChildUpdate_(index2, newValue, oldValue);
      }
    } else {
      var newItems = new Array(index2 + 1 - values.length);
      for (var i = 0; i < newItems.length - 1; i++) {
        newItems[i] = void 0;
      }
      newItems[newItems.length - 1] = newValue;
      this.spliceWithArray_(values.length, 0, newItems);
    }
  };
  return ObservableArrayAdministration2;
}();
function createObservableArray(initialValues, enhancer, name, owned) {
  if (name === void 0) {
    name = "ObservableArray";
  }
  if (owned === void 0) {
    owned = false;
  }
  assertProxies();
  return initObservable(function() {
    var adm = new ObservableArrayAdministration(name, enhancer, owned, false);
    addHiddenFinalProp(adm.values_, $mobx, adm);
    var proxy = new Proxy(adm.values_, arrayTraps);
    adm.proxy_ = proxy;
    if (initialValues && initialValues.length) {
      adm.spliceWithArray_(0, 0, initialValues);
    }
    return proxy;
  });
}
var arrayExtensions = {
  clear: function clear() {
    return this.splice(0);
  },
  replace: function replace(newItems) {
    var adm = this[$mobx];
    return adm.spliceWithArray_(0, adm.values_.length, newItems);
  },
  toJSON: function toJSON2() {
    return this.slice();
  },
  splice: function splice2(index2, deleteCount) {
    for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      newItems[_key - 2] = arguments[_key];
    }
    var adm = this[$mobx];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return adm.spliceWithArray_(index2);
      case 2:
        return adm.spliceWithArray_(index2, deleteCount);
    }
    return adm.spliceWithArray_(index2, deleteCount, newItems);
  },
  spliceWithArray: function spliceWithArray(index2, deleteCount, newItems) {
    return this[$mobx].spliceWithArray_(index2, deleteCount, newItems);
  },
  push: function push() {
    var adm = this[$mobx];
    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }
    adm.spliceWithArray_(adm.values_.length, 0, items);
    return adm.values_.length;
  },
  pop: function pop() {
    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
  },
  shift: function shift() {
    return this.splice(0, 1)[0];
  },
  unshift: function unshift() {
    var adm = this[$mobx];
    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      items[_key3] = arguments[_key3];
    }
    adm.spliceWithArray_(0, 0, items);
    return adm.values_.length;
  },
  reverse: function reverse() {
    if (globalState.trackingDerivation) {
      die(37, "reverse");
    }
    this.replace(this.slice().reverse());
    return this;
  },
  sort: function sort() {
    if (globalState.trackingDerivation) {
      die(37, "sort");
    }
    var copy = this.slice();
    copy.sort.apply(copy, arguments);
    this.replace(copy);
    return this;
  },
  remove: function remove(value) {
    var adm = this[$mobx];
    var idx = adm.dehanceValues_(adm.values_).indexOf(value);
    if (idx > -1) {
      this.splice(idx, 1);
      return true;
    }
    return false;
  }
};
addArrayExtension("at", simpleFunc);
addArrayExtension("concat", simpleFunc);
addArrayExtension("flat", simpleFunc);
addArrayExtension("includes", simpleFunc);
addArrayExtension("indexOf", simpleFunc);
addArrayExtension("join", simpleFunc);
addArrayExtension("lastIndexOf", simpleFunc);
addArrayExtension("slice", simpleFunc);
addArrayExtension("toString", simpleFunc);
addArrayExtension("toLocaleString", simpleFunc);
addArrayExtension("toSorted", simpleFunc);
addArrayExtension("toSpliced", simpleFunc);
addArrayExtension("with", simpleFunc);
addArrayExtension("every", mapLikeFunc);
addArrayExtension("filter", mapLikeFunc);
addArrayExtension("find", mapLikeFunc);
addArrayExtension("findIndex", mapLikeFunc);
addArrayExtension("findLast", mapLikeFunc);
addArrayExtension("findLastIndex", mapLikeFunc);
addArrayExtension("flatMap", mapLikeFunc);
addArrayExtension("forEach", mapLikeFunc);
addArrayExtension("map", mapLikeFunc);
addArrayExtension("some", mapLikeFunc);
addArrayExtension("toReversed", mapLikeFunc);
addArrayExtension("reduce", reduceLikeFunc);
addArrayExtension("reduceRight", reduceLikeFunc);
function addArrayExtension(funcName, funcFactory) {
  if (typeof Array.prototype[funcName] === "function") {
    arrayExtensions[funcName] = funcFactory(funcName);
  }
}
function simpleFunc(funcName) {
  return function() {
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
function mapLikeFunc(funcName) {
  return function(callback, thisArg) {
    var _this2 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName](function(element, index2) {
      return callback.call(thisArg, element, index2, _this2);
    });
  };
}
function reduceLikeFunc(funcName) {
  return function() {
    var _this3 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    var callback = arguments[0];
    arguments[0] = function(accumulator, currentValue, index2) {
      return callback(accumulator, currentValue, index2, _this3);
    };
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
var isObservableArrayAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
  return isObject$2(thing) && isObservableArrayAdministration(thing[$mobx]);
}
var ObservableMapMarker = {};
var ADD = "add";
var DELETE = "delete";
var ObservableMap = /* @__PURE__ */ function() {
  function ObservableMap2(initialData, enhancer_, name_) {
    var _this = this;
    if (enhancer_ === void 0) {
      enhancer_ = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ = "ObservableMap";
    }
    this.enhancer_ = void 0;
    this.name_ = void 0;
    this[$mobx] = ObservableMapMarker;
    this.data_ = void 0;
    this.hasMap_ = void 0;
    this.keysAtom_ = void 0;
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = enhancer_;
    this.name_ = name_;
    if (!isFunction$1(Map)) {
      die(18);
    }
    initObservable(function() {
      _this.keysAtom_ = createAtom(false ? _this.name_ + ".keys()" : "ObservableMap.keys()");
      _this.data_ = /* @__PURE__ */ new Map();
      _this.hasMap_ = /* @__PURE__ */ new Map();
      if (initialData) {
        _this.merge(initialData);
      }
    });
  }
  var _proto = ObservableMap2.prototype;
  _proto.has_ = function has_(key) {
    return this.data_.has(key);
  };
  _proto.has = function has2(key) {
    var _this2 = this;
    if (!globalState.trackingDerivation) {
      return this.has_(key);
    }
    var entry = this.hasMap_.get(key);
    if (!entry) {
      var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer, "ObservableMap.key?", false);
      this.hasMap_.set(key, newEntry);
      onBecomeUnobserved(newEntry, function() {
        return _this2.hasMap_["delete"](key);
      });
    }
    return entry.get();
  };
  _proto.set = function set5(key, value) {
    var hasKey = this.has_(key);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: hasKey ? UPDATE : ADD,
        object: this,
        newValue: value,
        name: key
      });
      if (!change) {
        return this;
      }
      value = change.newValue;
    }
    if (hasKey) {
      this.updateValue_(key, value);
    } else {
      this.addValue_(key, value);
    }
    return this;
  };
  _proto["delete"] = function _delete(key) {
    var _this3 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        name: key
      });
      if (!change) {
        return false;
      }
    }
    if (this.has_(key)) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: this.data_.get(key).value_,
        name: key
      } : null;
      transaction(function() {
        var _this3$hasMap_$get;
        _this3.keysAtom_.reportChanged();
        (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null || _this3$hasMap_$get.setNewValue_(false);
        var observable2 = _this3.data_.get(key);
        observable2.setNewValue_(void 0);
        _this3.data_["delete"](key);
      });
      if (notify) {
        notifyListeners(this, _change);
      }
      return true;
    }
    return false;
  };
  _proto.updateValue_ = function updateValue_(key, newValue) {
    var observable2 = this.data_.get(key);
    newValue = observable2.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: UPDATE,
        object: this,
        oldValue: observable2.value_,
        name: key,
        newValue
      } : null;
      observable2.setNewValue_(newValue);
      if (notify) {
        notifyListeners(this, change);
      }
    }
  };
  _proto.addValue_ = function addValue_(key, newValue) {
    var _this4 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    transaction(function() {
      var _this4$hasMap_$get;
      var observable2 = new ObservableValue(newValue, _this4.enhancer_, "ObservableMap.key", false);
      _this4.data_.set(key, observable2);
      newValue = observable2.value_;
      (_this4$hasMap_$get = _this4.hasMap_.get(key)) == null || _this4$hasMap_$get.setNewValue_(true);
      _this4.keysAtom_.reportChanged();
    });
    var notifySpy = isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: ADD,
      object: this,
      name: key,
      newValue
    } : null;
    if (notify) {
      notifyListeners(this, change);
    }
  };
  _proto.get = function get5(key) {
    if (this.has(key)) {
      return this.dehanceValue_(this.data_.get(key).get());
    }
    return this.dehanceValue_(void 0);
  };
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.keys = function keys2() {
    this.keysAtom_.reportObserved();
    return this.data_.keys();
  };
  _proto.values = function values() {
    var self2 = this;
    var keys2 = this.keys();
    return makeIterableForMap({
      next: function next() {
        var _keys$next = keys2.next(), done = _keys$next.done, value = _keys$next.value;
        return {
          done,
          value: done ? void 0 : self2.get(value)
        };
      }
    });
  };
  _proto.entries = function entries() {
    var self2 = this;
    var keys2 = this.keys();
    return makeIterableForMap({
      next: function next() {
        var _keys$next2 = keys2.next(), done = _keys$next2.done, value = _keys$next2.value;
        return {
          done,
          value: done ? void 0 : [value, self2.get(value)]
        };
      }
    });
  };
  _proto[Symbol.iterator] = function() {
    return this.entries();
  };
  _proto.forEach = function forEach2(callback, thisArg) {
    for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done; ) {
      var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
      callback.call(thisArg, value, key, this);
    }
  };
  _proto.merge = function merge2(other) {
    var _this5 = this;
    if (isObservableMap(other)) {
      other = new Map(other);
    }
    transaction(function() {
      if (isPlainObject$2(other)) {
        getPlainObjectKeys(other).forEach(function(key) {
          return _this5.set(key, other[key]);
        });
      } else if (Array.isArray(other)) {
        other.forEach(function(_ref) {
          var key = _ref[0], value = _ref[1];
          return _this5.set(key, value);
        });
      } else if (isES6Map(other)) {
        if (!isPlainES6Map(other)) {
          die(19, other);
        }
        other.forEach(function(value, key) {
          return _this5.set(key, value);
        });
      } else if (other !== null && other !== void 0) {
        die(20, other);
      }
    });
    return this;
  };
  _proto.clear = function clear2() {
    var _this6 = this;
    transaction(function() {
      untracked(function() {
        for (var _iterator2 = _createForOfIteratorHelperLoose(_this6.keys()), _step2; !(_step2 = _iterator2()).done; ) {
          var key = _step2.value;
          _this6["delete"](key);
        }
      });
    });
  };
  _proto.replace = function replace2(values) {
    var _this7 = this;
    transaction(function() {
      var replacementMap = convertToMap(values);
      var orderedData = /* @__PURE__ */ new Map();
      var keysReportChangedCalled = false;
      for (var _iterator3 = _createForOfIteratorHelperLoose(_this7.data_.keys()), _step3; !(_step3 = _iterator3()).done; ) {
        var key = _step3.value;
        if (!replacementMap.has(key)) {
          var deleted = _this7["delete"](key);
          if (deleted) {
            keysReportChangedCalled = true;
          } else {
            var value = _this7.data_.get(key);
            orderedData.set(key, value);
          }
        }
      }
      for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done; ) {
        var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];
        var keyExisted = _this7.data_.has(_key);
        _this7.set(_key, _value);
        if (_this7.data_.has(_key)) {
          var _value2 = _this7.data_.get(_key);
          orderedData.set(_key, _value2);
          if (!keyExisted) {
            keysReportChangedCalled = true;
          }
        }
      }
      if (!keysReportChangedCalled) {
        if (_this7.data_.size !== orderedData.size) {
          _this7.keysAtom_.reportChanged();
        } else {
          var iter1 = _this7.data_.keys();
          var iter2 = orderedData.keys();
          var next1 = iter1.next();
          var next2 = iter2.next();
          while (!next1.done) {
            if (next1.value !== next2.value) {
              _this7.keysAtom_.reportChanged();
              break;
            }
            next1 = iter1.next();
            next2 = iter2.next();
          }
        }
      }
      _this7.data_ = orderedData;
    });
    return this;
  };
  _proto.toString = function toString4() {
    return "[object ObservableMap]";
  };
  _proto.toJSON = function toJSON4() {
    return Array.from(this);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  return _createClass(ObservableMap2, [{
    key: "size",
    get: function get5() {
      this.keysAtom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get5() {
      return "Map";
    }
  }]);
}();
var isObservableMap = /* @__PURE__ */ createInstanceofPredicate("ObservableMap", ObservableMap);
function makeIterableForMap(iterator) {
  iterator[Symbol.toStringTag] = "MapIterator";
  return makeIterable(iterator);
}
function convertToMap(dataStructure) {
  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
    return dataStructure;
  } else if (Array.isArray(dataStructure)) {
    return new Map(dataStructure);
  } else if (isPlainObject$2(dataStructure)) {
    var map3 = /* @__PURE__ */ new Map();
    for (var key in dataStructure) {
      map3.set(key, dataStructure[key]);
    }
    return map3;
  } else {
    return die(21, dataStructure);
  }
}
var ObservableSetMarker = {};
var ObservableSet = /* @__PURE__ */ function() {
  function ObservableSet2(initialData, enhancer, name_) {
    var _this = this;
    if (enhancer === void 0) {
      enhancer = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ = "ObservableSet";
    }
    this.name_ = void 0;
    this[$mobx] = ObservableSetMarker;
    this.data_ = /* @__PURE__ */ new Set();
    this.atom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = void 0;
    this.name_ = name_;
    if (!isFunction$1(Set)) {
      die(22);
    }
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, name_);
    };
    initObservable(function() {
      _this.atom_ = createAtom(_this.name_);
      if (initialData) {
        _this.replace(initialData);
      }
    });
  }
  var _proto = ObservableSet2.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.clear = function clear2() {
    var _this2 = this;
    transaction(function() {
      untracked(function() {
        for (var _iterator = _createForOfIteratorHelperLoose(_this2.data_.values()), _step; !(_step = _iterator()).done; ) {
          var value = _step.value;
          _this2["delete"](value);
        }
      });
    });
  };
  _proto.forEach = function forEach2(callbackFn, thisArg) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done; ) {
      var value = _step2.value;
      callbackFn.call(thisArg, value, value, this);
    }
  };
  _proto.add = function add2(value) {
    var _this3 = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: ADD,
        object: this,
        newValue: value
      });
      if (!change) {
        return this;
      }
    }
    if (!this.has(value)) {
      transaction(function() {
        _this3.data_.add(_this3.enhancer_(value, void 0));
        _this3.atom_.reportChanged();
      });
      var notifySpy = false;
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        newValue: value
      } : null;
      if (notify) {
        notifyListeners(this, _change);
      }
    }
    return this;
  };
  _proto["delete"] = function _delete(value) {
    var _this4 = this;
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        oldValue: value
      });
      if (!change) {
        return false;
      }
    }
    if (this.has(value)) {
      var notifySpy = false;
      var notify = hasListeners(this);
      var _change2 = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: value
      } : null;
      transaction(function() {
        _this4.atom_.reportChanged();
        _this4.data_["delete"](value);
      });
      if (notify) {
        notifyListeners(this, _change2);
      }
      return true;
    }
    return false;
  };
  _proto.has = function has2(value) {
    this.atom_.reportObserved();
    return this.data_.has(this.dehanceValue_(value));
  };
  _proto.entries = function entries() {
    var nextIndex = 0;
    var keys2 = Array.from(this.keys());
    var values = Array.from(this.values());
    return makeIterableForSet({
      next: function next() {
        var index2 = nextIndex;
        nextIndex += 1;
        return index2 < values.length ? {
          value: [keys2[index2], values[index2]],
          done: false
        } : {
          value: void 0,
          done: true
        };
      }
    });
  };
  _proto.keys = function keys2() {
    return this.values();
  };
  _proto.values = function values() {
    this.atom_.reportObserved();
    var self2 = this;
    var nextIndex = 0;
    var observableValues = Array.from(this.data_.values());
    return makeIterableForSet({
      next: function next() {
        return nextIndex < observableValues.length ? {
          value: self2.dehanceValue_(observableValues[nextIndex++]),
          done: false
        } : {
          value: void 0,
          done: true
        };
      }
    });
  };
  _proto.intersection = function intersection2(otherSet) {
    if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
      return otherSet.intersection(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.intersection(otherSet);
    }
  };
  _proto.union = function union2(otherSet) {
    if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
      return otherSet.union(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.union(otherSet);
    }
  };
  _proto.difference = function difference(otherSet) {
    return new Set(this).difference(otherSet);
  };
  _proto.symmetricDifference = function symmetricDifference(otherSet) {
    if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
      return otherSet.symmetricDifference(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.symmetricDifference(otherSet);
    }
  };
  _proto.isSubsetOf = function isSubsetOf(otherSet) {
    return new Set(this).isSubsetOf(otherSet);
  };
  _proto.isSupersetOf = function isSupersetOf(otherSet) {
    return new Set(this).isSupersetOf(otherSet);
  };
  _proto.isDisjointFrom = function isDisjointFrom(otherSet) {
    if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
      return otherSet.isDisjointFrom(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.isDisjointFrom(otherSet);
    }
  };
  _proto.replace = function replace2(other) {
    var _this5 = this;
    if (isObservableSet(other)) {
      other = new Set(other);
    }
    transaction(function() {
      if (Array.isArray(other)) {
        _this5.clear();
        other.forEach(function(value) {
          return _this5.add(value);
        });
      } else if (isES6Set(other)) {
        _this5.clear();
        other.forEach(function(value) {
          return _this5.add(value);
        });
      } else if (other !== null && other !== void 0) {
        die("Cannot initialize set from " + other);
      }
    });
    return this;
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.toJSON = function toJSON4() {
    return Array.from(this);
  };
  _proto.toString = function toString4() {
    return "[object ObservableSet]";
  };
  _proto[Symbol.iterator] = function() {
    return this.values();
  };
  return _createClass(ObservableSet2, [{
    key: "size",
    get: function get5() {
      this.atom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get5() {
      return "Set";
    }
  }]);
}();
var isObservableSet = /* @__PURE__ */ createInstanceofPredicate("ObservableSet", ObservableSet);
function makeIterableForSet(iterator) {
  iterator[Symbol.toStringTag] = "SetIterator";
  return makeIterable(iterator);
}
var descriptorCache = /* @__PURE__ */ Object.create(null);
var REMOVE = "remove";
var ObservableObjectAdministration = /* @__PURE__ */ function() {
  function ObservableObjectAdministration2(target_, values_, name_, defaultAnnotation_) {
    if (values_ === void 0) {
      values_ = /* @__PURE__ */ new Map();
    }
    if (defaultAnnotation_ === void 0) {
      defaultAnnotation_ = autoAnnotation;
    }
    this.target_ = void 0;
    this.values_ = void 0;
    this.name_ = void 0;
    this.defaultAnnotation_ = void 0;
    this.keysAtom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.proxy_ = void 0;
    this.isPlainObject_ = void 0;
    this.appliedAnnotations_ = void 0;
    this.pendingKeys_ = void 0;
    this.target_ = target_;
    this.values_ = values_;
    this.name_ = name_;
    this.defaultAnnotation_ = defaultAnnotation_;
    this.keysAtom_ = new Atom("ObservableObject.keys");
    this.isPlainObject_ = isPlainObject$2(this.target_);
  }
  var _proto = ObservableObjectAdministration2.prototype;
  _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
    return this.values_.get(key).get();
  };
  _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
    var observable2 = this.values_.get(key);
    if (observable2 instanceof ComputedValue) {
      observable2.set(newValue);
      return true;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: UPDATE,
        object: this.proxy_ || this.target_,
        name: key,
        newValue
      });
      if (!change) {
        return null;
      }
      newValue = change.newValue;
    }
    newValue = observable2.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notify = hasListeners(this);
      var notifySpy = false;
      var _change = notify || notifySpy ? {
        type: UPDATE,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: observable2.value_,
        name: key,
        newValue
      } : null;
      observable2.setNewValue_(newValue);
      if (notify) {
        notifyListeners(this, _change);
      }
    }
    return true;
  };
  _proto.get_ = function get_(key) {
    if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
      this.has_(key);
    }
    return this.target_[key];
  };
  _proto.set_ = function set_(key, value, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (hasProp(this.target_, key)) {
      if (this.values_.has(key)) {
        return this.setObservablePropValue_(key, value);
      } else if (proxyTrap) {
        return Reflect.set(this.target_, key, value);
      } else {
        this.target_[key] = value;
        return true;
      }
    } else {
      return this.extend_(key, {
        value,
        enumerable: true,
        writable: true,
        configurable: true
      }, this.defaultAnnotation_, proxyTrap);
    }
  };
  _proto.has_ = function has_(key) {
    if (!globalState.trackingDerivation) {
      return key in this.target_;
    }
    this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
    var entry = this.pendingKeys_.get(key);
    if (!entry) {
      entry = new ObservableValue(key in this.target_, referenceEnhancer, "ObservableObject.key?", false);
      this.pendingKeys_.set(key, entry);
    }
    return entry.get();
  };
  _proto.make_ = function make_(key, annotation) {
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return;
    }
    if (!(key in this.target_)) {
      var _this$target_$storedA;
      if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) != null && _this$target_$storedA[key]) {
        return;
      } else {
        die(1, annotation.annotationType_, this.name_ + "." + key.toString());
      }
    }
    var source = this.target_;
    while (source && source !== objectPrototype) {
      var descriptor = getDescriptor(source, key);
      if (descriptor) {
        var outcome = annotation.make_(this, key, descriptor, source);
        if (outcome === 0) {
          return;
        }
        if (outcome === 1) {
          break;
        }
      }
      source = Object.getPrototypeOf(source);
    }
    recordAnnotationApplied(this, annotation, key);
  };
  _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return this.defineProperty_(key, descriptor, proxyTrap);
    }
    var outcome = annotation.extend_(this, key, descriptor, proxyTrap);
    if (outcome) {
      recordAnnotationApplied(this, annotation, key);
    }
    return outcome;
  };
  _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: descriptor.value
        });
        if (!change) {
          return null;
        }
        var newValue = change.newValue;
        if (descriptor.value !== newValue) {
          descriptor = _extends$1({}, descriptor, {
            value: newValue
          });
        }
      }
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      this.notifyPropertyAddition_(key, descriptor.value);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: value
        });
        if (!change) {
          return null;
        }
        value = change.newValue;
      }
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: true,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      var observable2 = new ObservableValue(value, enhancer, false ? this.name_ + "." + key.toString() : "ObservableObject.key", false);
      this.values_.set(key, observable2);
      this.notifyPropertyAddition_(key, observable2.value_);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: void 0
        });
        if (!change) {
          return null;
        }
      }
      options.name || (options.name = false ? this.name_ + "." + key.toString() : "ObservableObject.key");
      options.context = this.proxy_ || this.target_;
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: false,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      this.values_.set(key, new ComputedValue(options));
      this.notifyPropertyAddition_(key, void 0);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.delete_ = function delete_(key, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    if (!hasProp(this.target_, key)) {
      return true;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_ || this.target_,
        name: key,
        type: REMOVE
      });
      if (!change) {
        return null;
      }
    }
    try {
      var _this$pendingKeys_;
      startBatch();
      var notify = hasListeners(this);
      var notifySpy = false;
      var observable2 = this.values_.get(key);
      var value = void 0;
      if (!observable2 && (notify || notifySpy)) {
        var _getDescriptor2;
        value = (_getDescriptor2 = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor2.value;
      }
      if (proxyTrap) {
        if (!Reflect.deleteProperty(this.target_, key)) {
          return false;
        }
      } else {
        delete this.target_[key];
      }
      if (false)
        ;
      if (observable2) {
        this.values_["delete"](key);
        if (observable2 instanceof ObservableValue) {
          value = observable2.value_;
        }
        propagateChanged(observable2);
      }
      this.keysAtom_.reportChanged();
      (_this$pendingKeys_ = this.pendingKeys_) == null || (_this$pendingKeys_ = _this$pendingKeys_.get(key)) == null || _this$pendingKeys_.set(key in this.target_);
      if (notify || notifySpy) {
        var _change2 = {
          type: REMOVE,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: value,
          name: key
        };
        if (false)
          ;
        if (notify) {
          notifyListeners(this, _change2);
        }
        if (false)
          ;
      }
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.observe_ = function observe_(callback, fireImmediately) {
    return registerListener(this, callback);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
    var _this$pendingKeys_2;
    var notify = hasListeners(this);
    var notifySpy = false;
    if (notify || notifySpy) {
      var change = notify || notifySpy ? {
        type: ADD,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: value
      } : null;
      if (notify) {
        notifyListeners(this, change);
      }
    }
    (_this$pendingKeys_2 = this.pendingKeys_) == null || (_this$pendingKeys_2 = _this$pendingKeys_2.get(key)) == null || _this$pendingKeys_2.set(true);
    this.keysAtom_.reportChanged();
  };
  _proto.ownKeys_ = function ownKeys_() {
    this.keysAtom_.reportObserved();
    return ownKeys(this.target_);
  };
  _proto.keys_ = function keys_() {
    this.keysAtom_.reportObserved();
    return Object.keys(this.target_);
  };
  return ObservableObjectAdministration2;
}();
function asObservableObject(target, options) {
  var _options$name;
  if (hasProp(target, $mobx)) {
    return target;
  }
  var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name : "ObservableObject";
  var adm = new ObservableObjectAdministration(target, /* @__PURE__ */ new Map(), String(name), getAnnotationFromOptions(options));
  addHiddenProp(target, $mobx, adm);
  return target;
}
var isObservableObjectAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
function getCachedObservablePropDescriptor(key) {
  return descriptorCache[key] || (descriptorCache[key] = {
    get: function get5() {
      return this[$mobx].getObservablePropValue_(key);
    },
    set: function set5(value) {
      return this[$mobx].setObservablePropValue_(key, value);
    }
  });
}
function isObservableObject(thing) {
  if (isObject$2(thing)) {
    return isObservableObjectAdministration(thing[$mobx]);
  }
  return false;
}
function recordAnnotationApplied(adm, annotation, key) {
  var _adm$target_$storedAn;
  (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null || delete _adm$target_$storedAn[key];
}
var ENTRY_0 = /* @__PURE__ */ createArrayEntryDescriptor(0);
var safariPrototypeSetterInheritanceBug = /* @__PURE__ */ function() {
  var v = false;
  var p2 = {};
  Object.defineProperty(p2, "0", {
    set: function set5() {
      v = true;
    }
  });
  Object.create(p2)["0"] = 1;
  return v === false;
}();
var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
var StubArray = function StubArray2() {
};
function inherit(ctor, proto2) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ctor.prototype, proto2);
  } else if (ctor.prototype.__proto__ !== void 0) {
    ctor.prototype.__proto__ = proto2;
  } else {
    ctor.prototype = proto2;
  }
}
inherit(StubArray, Array.prototype);
var LegacyObservableArray = /* @__PURE__ */ function(_StubArray) {
  function LegacyObservableArray2(initialValues, enhancer, name, owned) {
    var _this;
    if (name === void 0) {
      name = "ObservableArray";
    }
    if (owned === void 0) {
      owned = false;
    }
    _this = _StubArray.call(this) || this;
    initObservable(function() {
      var adm = new ObservableArrayAdministration(name, enhancer, owned, true);
      adm.proxy_ = _this;
      addHiddenFinalProp(_this, $mobx, adm);
      if (initialValues && initialValues.length) {
        _this.spliceWithArray(0, 0, initialValues);
      }
      if (safariPrototypeSetterInheritanceBug) {
        Object.defineProperty(_this, "0", ENTRY_0);
      }
    });
    return _this;
  }
  _inheritsLoose(LegacyObservableArray2, _StubArray);
  var _proto = LegacyObservableArray2.prototype;
  _proto.concat = function concat() {
    this[$mobx].atom_.reportObserved();
    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }
    return Array.prototype.concat.apply(
      this.slice(),
      arrays.map(function(a) {
        return isObservableArray(a) ? a.slice() : a;
      })
    );
  };
  _proto[Symbol.iterator] = function() {
    var self2 = this;
    var nextIndex = 0;
    return makeIterable({
      next: function next() {
        return nextIndex < self2.length ? {
          value: self2[nextIndex++],
          done: false
        } : {
          done: true,
          value: void 0
        };
      }
    });
  };
  return _createClass(LegacyObservableArray2, [{
    key: "length",
    get: function get5() {
      return this[$mobx].getArrayLength_();
    },
    set: function set5(newLength) {
      this[$mobx].setArrayLength_(newLength);
    }
  }, {
    key: Symbol.toStringTag,
    get: function get5() {
      return "Array";
    }
  }]);
}(StubArray);
Object.entries(arrayExtensions).forEach(function(_ref) {
  var prop = _ref[0], fn = _ref[1];
  if (prop !== "concat") {
    addHiddenProp(LegacyObservableArray.prototype, prop, fn);
  }
});
function createArrayEntryDescriptor(index2) {
  return {
    enumerable: false,
    configurable: true,
    get: function get5() {
      return this[$mobx].get_(index2);
    },
    set: function set5(value) {
      this[$mobx].set_(index2, value);
    }
  };
}
function createArrayBufferItem(index2) {
  defineProperty(LegacyObservableArray.prototype, "" + index2, createArrayEntryDescriptor(index2));
}
function reserveArrayBuffer(max2) {
  if (max2 > OBSERVABLE_ARRAY_BUFFER_SIZE) {
    for (var index2 = OBSERVABLE_ARRAY_BUFFER_SIZE; index2 < max2 + 100; index2++) {
      createArrayBufferItem(index2);
    }
    OBSERVABLE_ARRAY_BUFFER_SIZE = max2;
  }
}
reserveArrayBuffer(1e3);
function createLegacyArray(initialValues, enhancer, name) {
  return new LegacyObservableArray(initialValues, enhancer, name);
}
function getAtom(thing, property2) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray(thing)) {
      if (property2 !== void 0) {
        die(23);
      }
      return thing[$mobx].atom_;
    }
    if (isObservableSet(thing)) {
      return thing.atom_;
    }
    if (isObservableMap(thing)) {
      if (property2 === void 0) {
        return thing.keysAtom_;
      }
      var observable2 = thing.data_.get(property2) || thing.hasMap_.get(property2);
      if (!observable2) {
        die(25, property2, getDebugName(thing));
      }
      return observable2;
    }
    if (isObservableObject(thing)) {
      if (!property2) {
        return die(26);
      }
      var _observable = thing[$mobx].values_.get(property2);
      if (!_observable) {
        die(27, property2, getDebugName(thing));
      }
      return _observable;
    }
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
  } else if (isFunction$1(thing)) {
    if (isReaction(thing[$mobx])) {
      return thing[$mobx];
    }
  }
  die(28);
}
function getAdministration(thing, property2) {
  if (!thing) {
    die(29);
  }
  if (property2 !== void 0) {
    return getAdministration(getAtom(thing, property2));
  }
  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
    return thing;
  }
  if (isObservableMap(thing) || isObservableSet(thing)) {
    return thing;
  }
  if (thing[$mobx]) {
    return thing[$mobx];
  }
  die(24, thing);
}
function getDebugName(thing, property2) {
  var named;
  if (property2 !== void 0) {
    named = getAtom(thing, property2);
  } else if (isAction(thing)) {
    return thing.name;
  } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
    named = getAdministration(thing);
  } else {
    named = getAtom(thing);
  }
  return named.name_;
}
function initObservable(cb) {
  var derivation = untrackedStart();
  var allowStateChanges2 = allowStateChangesStart(true);
  startBatch();
  try {
    return cb();
  } finally {
    endBatch();
    allowStateChangesEnd(allowStateChanges2);
    untrackedEnd(derivation);
  }
}
var toString$1 = objectPrototype.toString;
function deepEqual$1(a, b, depth) {
  if (depth === void 0) {
    depth = -1;
  }
  return eq(a, b, depth);
}
function eq(a, b, depth, aStack, bStack) {
  if (a === b) {
    return a !== 0 || 1 / a === 1 / b;
  }
  if (a == null || b == null) {
    return false;
  }
  if (a !== a) {
    return b !== b;
  }
  var type = typeof a;
  if (type !== "function" && type !== "object" && typeof b != "object") {
    return false;
  }
  var className = toString$1.call(a);
  if (className !== toString$1.call(b)) {
    return false;
  }
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a === "" + b;
    case "[object Number]":
      if (+a !== +a) {
        return +b !== +b;
      }
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case "[object Date]":
    case "[object Boolean]":
      return +a === +b;
    case "[object Symbol]":
      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);
    case "[object Map]":
    case "[object Set]":
      if (depth >= 0) {
        depth++;
      }
      break;
  }
  a = unwrap(a);
  b = unwrap(b);
  var areArrays = className === "[object Array]";
  if (!areArrays) {
    if (typeof a != "object" || typeof b != "object") {
      return false;
    }
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor && isFunction$1(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) {
      return false;
    }
  }
  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a) {
      return bStack[length] === b;
    }
  }
  aStack.push(a);
  bStack.push(b);
  if (areArrays) {
    length = a.length;
    if (length !== b.length) {
      return false;
    }
    while (length--) {
      if (!eq(a[length], b[length], depth - 1, aStack, bStack)) {
        return false;
      }
    }
  } else {
    var keys2 = Object.keys(a);
    var key;
    length = keys2.length;
    if (Object.keys(b).length !== length) {
      return false;
    }
    while (length--) {
      key = keys2[length];
      if (!(hasProp(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack))) {
        return false;
      }
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function unwrap(a) {
  if (isObservableArray(a)) {
    return a.slice();
  }
  if (isES6Map(a) || isObservableMap(a)) {
    return Array.from(a.entries());
  }
  if (isES6Set(a) || isObservableSet(a)) {
    return Array.from(a.entries());
  }
  return a;
}
var _getGlobal$Iterator;
var maybeIteratorPrototype = ((_getGlobal$Iterator = getGlobal().Iterator) == null ? void 0 : _getGlobal$Iterator.prototype) || {};
function makeIterable(iterator) {
  iterator[Symbol.iterator] = getSelf;
  return Object.assign(Object.create(maybeIteratorPrototype), iterator);
}
function getSelf() {
  return this;
}
["Symbol", "Map", "Set"].forEach(function(m2) {
  var g = getGlobal();
  if (typeof g[m2] === "undefined") {
    die("MobX requires global '" + m2 + "' to be available or polyfilled");
  }
});
if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy,
    extras: {
      getDebugName
    },
    $mobx
  });
}
var useCurrentState = function useCurrentState2(initValue, dataIsObj) {
  var currentValue = React__default.useRef(initValue);
  var _React$useState = React__default.useState(initValue), _React$useState2 = _slicedToArray(_React$useState, 2), value = _React$useState2[0], setValue_ = _React$useState2[1];
  var setValue = function setValue2(newValue) {
    var rebuildValue = dataIsObj ? _objectSpread2(_objectSpread2({}, currentValue.current), newValue) : newValue;
    currentValue.current = rebuildValue;
    setValue_(rebuildValue);
  };
  return [value, currentValue, setValue];
};
var CONFIG_API = {
  baseURL: window.location.origin,
  listBlockLength: 1e3,
  simpleList: false
};
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString: toString2 } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache2) => (thing) => {
  const str = toString2.call(thing);
  return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject$1 = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject$1 = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate$1 = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$1(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l2 = obj.length; i < l2; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys2.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys2[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey$1(obj, key) {
  key = key.toLowerCase();
  const keys2 = Object.keys(obj);
  let i = keys2.length;
  let _key;
  while (i-- > 0) {
    _key = keys2[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue2 = (val, key) => {
    const targetKey = caseless && findKey$1(result, key) || key;
    if (isPlainObject$1(result[targetKey]) && isPlainObject$1(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject$1(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l2 = arguments.length; i < l2; i++) {
    arguments[i] && forEach(arguments[i], assignValue2);
  }
  return result;
}
const extend2 = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop2 = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size2--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject$1(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject$1(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token2, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token2) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token2, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
const asap$1 = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject: isObject$1,
  isPlainObject: isPlainObject$1,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate: isDate$1,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend: extend2,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop2,
  toFiniteNumber,
  findKey: findKey$1,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap: asap$1
};
function AxiosError(message2, code, config, request2, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message2;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request2 && (this.request = request2);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON3() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request2, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request2, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var httpAdapter = null;
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
function removeBrackets(key) {
  return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token2, i) {
    token2 = removeBrackets(token2);
    return !dots && i ? "[" + token2 + "]" : token2;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$1.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils$1.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils$1.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index2) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils$1.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils$1.forEach(value, function each(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$1.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match5) {
    return charMap[match5];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString3(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
var InterceptorManager$1 = InterceptorManager;
var transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
var FormData$1 = typeof FormData !== "undefined" ? FormData : null;
var Blob$1 = typeof Blob !== "undefined" ? Blob : null;
var platform$2 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
var utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  hasStandardBrowserEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" }));
var platform$1 = {
  ...utils,
  ...platform$2
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform$1.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform$1.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match5) => {
    return match5[0] === "[]" ? "" : match5[1] || match5[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys2 = Object.keys(arr);
  let i;
  const len = keys2.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys2[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index2) {
    let name = path[index2++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path.length;
    name = !name && utils$1.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index2);
    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data);
    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$1.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform$1.classes.FormData,
    Blob: platform$1.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults$1 = defaults;
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens2 = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match5;
  while (match5 = tokensRE.exec(str)) {
    tokens2[match5[1]] = match5[2];
  }
  return tokens2;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils$1.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$1.isString(value))
    return;
  if (utils$1.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils$1.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$1.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys2 = Object.keys(this);
    let i = keys2.length;
    let deleted = false;
    while (i--) {
      const key = keys2[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed3 = new this(first);
    targets.forEach((target) => computed3.set(target));
    return computed3;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders);
var AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils$1.forEach(fns, function transform2(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message2, config, request2) {
  AxiosError.call(this, message2 == null ? "canceled" : message2, AxiosError.ERR_CANCELED, config, request2);
  this.name = "CanceledError";
}
utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
function parseProtocol(url2) {
  const match5 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match5 && match5[1] || "";
}
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push2(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now2;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now2 = Date.now()) => {
    timestamp = now2;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now2 = Date.now();
    const passed = now2 - timestamp;
    if (passed >= threshold) {
      invoke(args, now2);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
var isURLSameOrigin = platform$1.hasStandardBrowserEnv ? function standardBrowserEnv() {
  const msie = platform$1.navigator && /(msie|trident)/i.test(platform$1.navigator.userAgent);
  const urlParsingNode = document.createElement("a");
  let originURL;
  function resolveURL(url2) {
    let href = url2;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin2(requestURL) {
    const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv() {
  return function isURLSameOrigin2() {
    return true;
  };
}();
var cookies = platform$1.hasStandardBrowserEnv ? {
  write(name, value, expires, path, domain, secure) {
    const cookie = [name + "=" + encodeURIComponent(value)];
    utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
    utils$1.isString(path) && cookie.push("path=" + path);
    utils$1.isString(domain) && cookie.push("domain=" + domain);
    secure === true && cookie.push("secure");
    document.cookie = cookie.join("; ");
  },
  read(name) {
    const match5 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
    return match5 ? decodeURIComponent(match5[3]) : null;
  },
  remove(name) {
    this.write(name, "", Date.now() - 864e5);
  }
} : {
  write() {
  },
  read() {
    return null;
  },
  remove() {
  }
};
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({ caseless }, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
var resolveConfig = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders$1.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils$1.isFormData(data)) {
    if (platform$1.hasStandardBrowserEnv || platform$1.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens2] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens2].join("; "));
    }
  }
  if (platform$1.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request2 = new XMLHttpRequest();
    request2.open(_config.method.toUpperCase(), _config.url, true);
    request2.timeout = _config.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config,
        request: request2
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request2
      ));
      request2 = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request2.setRequestHeader(key, val);
      });
    }
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request2.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request2.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request2.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request2.upload.addEventListener("progress", uploadThrottled);
      request2.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request2) : cancel);
        request2.abort();
        request2 = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform$1.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request2.send(requestData || null);
  });
};
const composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils$1.asap(unsubscribe);
    return signal;
  }
};
var composeSignals$1 = composeSignals;
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform$1.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
      throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils$1.isBlob(body)) {
    return body.size;
  }
  if (utils$1.isSpecCompliantForm(body)) {
    const _request = new Request(platform$1.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils$1.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers, body) => {
  const length = utils$1.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
var fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url: url2,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request2;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url2, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request2 = new Request(url2, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request2);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders$1.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request: request2
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request2),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError.from(err, err && err.code, config, request2);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
var adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const VERSION = "1.7.7";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version, message2) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys2 = Object.keys(options);
  let i = keys2.length;
  while (i-- > 0) {
    const opt = keys2[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
var validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url2, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token2 = this;
    this.promise.then((cancel) => {
      if (!token2._listeners)
        return;
      let i = token2._listeners.length;
      while (i-- > 0) {
        token2._listeners[i](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token2.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token2.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message2, config, request2) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError(message2, config, request2);
      resolvePromise(token2.reason);
    });
  }
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  static source() {
    let cancel;
    const token2 = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token: token2,
      cancel
    };
  }
}
var CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);
  utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils$1.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
var axios$1 = axios;
var _excluded = ["url", "headers"];
var JSON_HEADERS = {
  "Accept": "application/json, text/javascript, */*; q=0.01",
  "Content-Type": "application/json"
};
axios$1.defaults.withCredentials = true;
axios$1.defaults.xsrfCookieName = "csrftoken";
axios$1.defaults.xsrfHeaderName = "X-CSRFToken";
var Api = /* @__PURE__ */ function() {
  function Api2() {
    _classCallCheck$a(this, Api2);
  }
  return _createClass$9(Api2, [{
    key: "fetch",
    value: function fetch2(options) {
      return axios$1.request(_objectSpread2(_objectSpread2({}, options), {}, {
        baseURL: CONFIG_API.baseURL,
        headers: _objectSpread2(_objectSpread2({}, JSON_HEADERS), options.headers)
      }));
    }
  }, {
    key: "get",
    value: function get5(_ref) {
      var props = _extends$h({}, (_objectDestructuringEmpty(_ref), _ref));
      var _props$url = props.url, url2 = _props$url === void 0 ? "" : _props$url, _props$headers = props.headers, headers = _props$headers === void 0 ? {} : _props$headers, options = _objectWithoutProperties$3(props, _excluded);
      return this.fetch(_objectSpread2({
        url: url2,
        method: "GET",
        headers
      }, options));
    }
  }, {
    key: "post",
    value: function post(_ref2) {
      var _ref2$url = _ref2.url, url2 = _ref2$url === void 0 ? "" : _ref2$url, _ref2$body = _ref2.body, body = _ref2$body === void 0 ? {} : _ref2$body, form = _ref2.form, _ref2$headers = _ref2.headers, headers = _ref2$headers === void 0 ? {} : _ref2$headers;
      return this.fetch({
        url: url2,
        method: "POST",
        data: form ? form : JSON.stringify(body),
        headers
      });
    }
  }, {
    key: "put",
    value: function put(_ref3) {
      var _ref3$url = _ref3.url, url2 = _ref3$url === void 0 ? "" : _ref3$url, _ref3$body = _ref3.body, body = _ref3$body === void 0 ? {} : _ref3$body, _ref3$headers = _ref3.headers, headers = _ref3$headers === void 0 ? {} : _ref3$headers;
      return this.fetch({
        url: url2,
        method: "PUT",
        data: JSON.stringify(body),
        headers
      });
    }
  }, {
    key: "delete",
    value: function _delete(_ref4) {
      var _ref4$url = _ref4.url, url2 = _ref4$url === void 0 ? "" : _ref4$url, _ref4$body = _ref4.body, body = _ref4$body === void 0 ? {} : _ref4$body, _ref4$headers = _ref4.headers, headers = _ref4$headers === void 0 ? {} : _ref4$headers;
      return this.fetch({
        url: url2,
        method: "DELETE",
        data: JSON.stringify(body),
        headers
      });
    }
  }, {
    key: "toStr",
    value: function toStr(body) {
      var restBody = "";
      for (var key in body) {
        restBody += "".concat(key, "=").concat(body[key], "&");
      }
      return restBody.substring(0, restBody.length - 1);
    }
  }]);
}();
var api = new Api();
var Request$1 = /* @__PURE__ */ function() {
  function Request2() {
    _classCallCheck$a(this, Request2);
  }
  return _createClass$9(Request2, [{
    key: "get",
    value: function get5(_ref) {
      var props = _extends$h({}, (_objectDestructuringEmpty(_ref), _ref));
      var url2 = props.url, getParams = props.getParams, success = props.success, error = props.error, dataConverter = props.dataConverter;
      return api.get({
        url: url2 + UTILS$2.getParamsToString(getParams)
      }).then(function(_data) {
        var data = dataConverter ? dataConverter(_data.data) : _data.data;
        if (success) {
          success(data);
        }
        return data;
      })["catch"](function(data) {
        if (error) {
          error(data.message);
        }
        return data.message;
      });
    }
  }, {
    key: "post",
    value: function post(_ref2) {
      var props = _extends$h({}, (_objectDestructuringEmpty(_ref2), _ref2));
      return this.post_put_delete(_objectSpread2(_objectSpread2({}, props), {}, {
        method: "post"
      }));
    }
  }, {
    key: "put",
    value: function put(_ref3) {
      var props = _extends$h({}, (_objectDestructuringEmpty(_ref3), _ref3));
      return this.post_put_delete(_objectSpread2(_objectSpread2({}, props), {}, {
        method: "put"
      }));
    }
  }, {
    key: "delete",
    value: function _delete(_ref4) {
      var props = _extends$h({}, (_objectDestructuringEmpty(_ref4), _ref4));
      return this.post_put_delete(_objectSpread2(_objectSpread2({}, props), {}, {
        method: "delete"
      }));
    }
  }, {
    key: "post_put_delete",
    value: function post_put_delete(_ref5) {
      var props = _extends$h({}, (_objectDestructuringEmpty(_ref5), _ref5));
      var url2 = props.url, body = props.body, form = props.form, headers = props.headers, success = props.success, error = props.error, method = props.method, dataConverter = props.dataConverter;
      return api[method]({
        url: url2,
        body,
        form,
        headers
      }).then(function(_data) {
        var data = dataConverter ? dataConverter(_data.data) : _data.data;
        if (success) {
          success(data);
        }
        return {
          response: _data,
          data
        };
      })["catch"](function(data) {
        if (error) {
          error(data);
        }
        var message2 = data.message;
        return {
          response: data,
          message: message2
        };
      });
    }
  }]);
}();
var request = new Request$1();
var Store = /* @__PURE__ */ _createClass$9(
  function Store2() {
    var _this = this;
    _classCallCheck$a(this, Store2);
    _defineProperty$7(this, "createStore", function(name, data) {
      _this[name] = data;
      makeObservable(_this, _defineProperty$7({}, name, observable));
    });
    _defineProperty$7(this, "getStore", function() {
      return _this;
    });
    _defineProperty$7(this, "getState", function(addr) {
      var _this$getAddress = _this.getAddress(addr), objName = _this$getAddress.objName, index2 = _this$getAddress.index;
      return objName[index2];
    });
    _defineProperty$7(this, "setState", function(addr, data) {
      var _this$getAddress2 = _this.getAddress(addr), objName = _this$getAddress2.objName, index2 = _this$getAddress2.index;
      objName[index2] = data;
    });
    _defineProperty$7(this, "updateState", function(addr, data) {
      var _this$getAddress3 = _this.getAddress(addr), objName = _this$getAddress3.objName, index2 = _this$getAddress3.index;
      var oldData = objName[index2] || {};
      var newData = _objectSpread2(_objectSpread2({}, oldData), data);
      objName[index2] = newData;
    });
    _defineProperty$7(this, "getAddress", function(addr) {
      var address = _this;
      var indexes = addr.split(".");
      var length = indexes.length - 1;
      var index2;
      for (var i in indexes) {
        index2 = indexes[i];
        if (i < length) {
          if (address[index2] === void 0) {
            address[index2] = {};
          }
          address = address[index2];
        }
      }
      return {
        objName: address,
        index: index2
      };
    });
  }
);
var Store$1 = new Store();
var setPicker = "";
var SetPicker = function SetPicker2(_ref) {
  var _pages$current;
  var props = _extends$h({}, (_objectDestructuringEmpty(_ref), _ref));
  var options = props.options, setPickerConnector = props.setPickerConnector;
  props.removeComponent;
  var componentCallback = props.componentCallback, componentReturn = props.componentReturn;
  var listName = options.listName, request2 = options.request, finalList = options.finalList;
  options.unavailableItemsList;
  var _options$singleChoice = options.singleChoiceOnly, singleChoiceOnly = _options$singleChoice === void 0 ? true : _options$singleChoice;
  options.title;
  var _options$selectable = options.selectable, selectable = _options$selectable === void 0 ? true : _options$selectable, _options$selectedList = options.selectedList, externalSelectedList = _options$selectedList === void 0 ? [] : _options$selectedList, _options$strHeight = options.strHeight, strHeight = _options$strHeight === void 0 ? CONFIG_SETPICKER.lineHeight : _options$strHeight, callbackOnReadyComponentDOM = options.callbackOnReadyComponentDOM, listBlockLength = options.listBlockLength, hideSearchBar = options.hideSearchBar;
  options.hideCountersBar;
  options.ItemViewName;
  if (!listName)
    console.error("!!! \u0412\u041D\u0418\u041C\u0410\u041D\u0418\u0415 !!! \u041D\u0435 \u043D\u0430\u0437\u043D\u0430\u0447\u0435\u043D\u043E \u0443\u043D\u0438\u043A\u0430\u043B\u044C\u043D\u043E\u0435 \u0438\u043C\u044F \u0441\u043F\u0438\u0441\u043A\u0430 \u0434\u043B\u044F \u0441\u0435\u0442\u043F\u0438\u043A\u0435\u0440\u0430 - \u0432\u043E\u0437\u043C\u043E\u0436\u043D\u0430 \u043F\u0443\u0442\u0430\u043D\u0438\u0446\u0430 \u0432 \u0434\u0430\u043D\u043D\u044B\u0445!!!");
  var utilsCurrent = React__default.useRef(new Utils$1({
    finalList
  }));
  var utils2 = utilsCurrent.current;
  if (listBlockLength)
    CONFIG_API.listBlockLength = listBlockLength;
  var operationCodes = CONFIG_SETPICKER.operationCodes;
  var pages = React__default.useRef(toJS(Store$1.getState(CONSTANTS_SETPICKER.pagesData(listName))));
  console.log("--------- PAGES ------>", pages);
  var changeTimeoutId = React__default.useRef(null);
  var requestedPages = React__default.useRef({});
  var scrollData = React__default.useRef({});
  var counterRequest = React__default.useRef({});
  var _React$useState = React__default.useState(void 0), _React$useState2 = _slicedToArray(_React$useState, 2), showSelectedList = _React$useState2[0], _setShowSelectedList = _React$useState2[1];
  var setShowSelectedList = function setShowSelectedList2(onOff, withSearch) {
    utils2.showSelectedListMode = onOff ? withSearch ? "search" : "full" : false;
    if (onOff) {
      var _list = withSearch ? currentSelected.current.searchSelectedList : currentSelected.current.selectedList;
      utils2.goToSelectedListMode({
        listName,
        list: _list
      });
    } else {
      utils2.goFromSelectedListMode({
        listName
      });
    }
    _setShowSelectedList(utils2.showSelectedListMode);
  };
  var _React$useState3 = React__default.useState(0), _React$useState4 = _slicedToArray(_React$useState3, 2), resetScrollbar = _React$useState4[0], setResetScrollbar = _React$useState4[1];
  var resetScroll = function resetScroll2() {
    return setResetScrollbar(resetScrollbar + 1);
  };
  var _useCurrentState = useCurrentState([]), _useCurrentState2 = _slicedToArray(_useCurrentState, 3), list = _useCurrentState2[0], currentList = _useCurrentState2[1], setList = _useCurrentState2[2];
  var _React$useState5 = React__default.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), actionsMode = _React$useState6[0], _setActionsMode = _React$useState6[1];
  var setActionsMode = function setActionsMode2(mode) {
    return _setActionsMode(mode === actionsMode ? null : mode);
  };
  var blocksLoading = React__default.useRef(0);
  var blockLoadingStart = function blockLoadingStart2() {
    blocksLoading.current++;
    utils2.spinner(listName, true);
  };
  var blockLoadingStop = function blockLoadingStop2() {
    blocksLoading.current = Math.max(blocksLoading.current - 1, 0);
    if (!blocksLoading.current) {
      utils2.spinner(listName, false);
    }
  };
  var _useCurrentState3 = useCurrentState(void 0), _useCurrentState4 = _slicedToArray(_useCurrentState3, 3), searchContext = _useCurrentState4[0], currentSearchContext = _useCurrentState4[1], _setSearchContext = _useCurrentState4[2];
  var getSearchSelectedList = function getSearchSelectedList2(list2) {
    if (!(currentSearchContext !== null && currentSearchContext !== void 0 && currentSearchContext.current))
      return list2;
    var context = currentSearchContext.current.toLowerCase();
    return list2.filter(function(item) {
      return ~item.toLowerCase().indexOf(context);
    });
  };
  var _useCurrentState5 = useCurrentState({
    selectedList: externalSelectedList,
    searchSelectedList: getSearchSelectedList(externalSelectedList),
    show: !!(pages !== null && pages !== void 0 && (_pages$current = pages.current) !== null && _pages$current !== void 0 && _pages$current._mainOptions)
  }), _useCurrentState6 = _slicedToArray(_useCurrentState5, 3), selected = _useCurrentState6[0], currentSelected = _useCurrentState6[1], _setSelected = _useCurrentState6[2];
  var selectedIds = React__default.useRef(null);
  var showSelectedCounts = function showSelectedCounts2() {
    return _setSelected(_objectSpread2(_objectSpread2({}, currentSelected.current), {}, {
      show: true
    }));
  };
  var hideSelectedCounts = function hideSelectedCounts2() {
    return _setSelected(_objectSpread2(_objectSpread2({}, currentSelected.current), {}, {
      show: false
    }));
  };
  var setSelectedTimeoutId = React__default.useRef(0);
  var setSelected = function setSelected2(_selected) {
    var selected2 = _selected || currentSelected.current;
    var selectedList = selected2.selectedList;
    var newSelected = {
      selectedList,
      searchSelectedList: getSearchSelectedList(selectedList),
      show: selected2.show === void 0 ? currentSelected.current.show : selected2.show
    };
    currentSelected.current = newSelected;
    if (setSelectedTimeoutId.current) {
      clearTimeout(setSelectedTimeoutId.current);
    }
    setSelectedTimeoutId.current = setTimeout(function() {
      setSelectedTimeoutId.current = 0;
      _setSelected(newSelected);
    }, 0);
  };
  var setSearchContext = function setSearchContext2(data) {
    _setSearchContext(data);
    componentCallback({
      code: CONFIG_SETPICKER.operationCodes.changeSearchContext,
      value: data
    });
    setSelected();
  };
  var checkUnloadedPages = function checkUnloadedPages2() {
    setTimeout(function() {
      endOfScroll({
        subList: scrollData.current.current.subList
      });
    }, 10);
  };
  var _componentCallback = function _componentCallback2(data) {
    componentCallback(_objectSpread2(_objectSpread2({}, data), {}, {
      common: {
        searchContext: currentSearchContext.current,
        pages: pages.current
      }
    }));
  };
  var onClickToLineCheckbox = function onClickToLineCheckbox2(item, checked) {
    var id = item.id;
    if (!selectable)
      return;
    var isSelected = singleChoiceOnly ? true : checked;
    var selectedList = selected.selectedList;
    if (singleChoiceOnly) {
      selectedList = [id];
    } else {
      selectedList = isSelected ? UTILS$2.idArrayIncrease(selectedList, id) : UTILS$2.idArrayDecrease(selectedList, id);
    }
    setSelected({
      selectedList
    });
    _componentCallback({
      code: operationCodes.itemSelect,
      item: _objectSpread2(_objectSpread2({}, item), {}, {
        id
      }),
      isSelected,
      selectedList
    });
  };
  var getBlock = function getBlock2(_ref2) {
    var props2 = _extends$h({}, (_objectDestructuringEmpty(_ref2), _ref2));
    var page = props2.page, trace = props2.trace;
    if (isNaN(page)) {
      console.error("getBlock error --- page = ".concat(page, " (trace: ").concat(trace, ")"));
      return;
    }
    var pagesIndex = utils2.getPagesIndex(currentSearchContext.current);
    var pageIndex = utils2.getPageIndex(pagesIndex, page);
    if (requestedPages[pageIndex]) {
      return;
    }
    requestedPages[pageIndex] = CONFIG_SETPICKER.loadingText;
    blockLoadingStart();
    var resetRequestedPage = function resetRequestedPage2() {
      return requestedPages[pageIndex] = null;
    };
    var promise = utils2.requestGetPage({
      listName,
      request: request2,
      searchContext: currentSearchContext.current,
      page,
      pages: pages.current,
      callbackForGetBlock: function callbackForGetBlock() {
        blockLoadingStop();
        showSelectedCounts();
      }
    });
    if (promise !== null && promise !== void 0 && promise.then) {
      promise.then(resetRequestedPage);
    }
  };
  React__default.useEffect(function() {
    setTimeout(function() {
      if (currentSearchContext.current) {
        setActionsMode(CONFIG_SETPICKER.actionModes.search);
      }
    }, 0);
    var removeReaction = reaction(function() {
      return Store$1.getState(CONSTANTS_SETPICKER.pagesData(listName));
    }, function(_data) {
      var data = toJS(_data);
      var currentPages = pages.current;
      var newPageIndex = data._change.pageIndex;
      pages.current = data;
      if (currentPages[newPageIndex] && !data._change.forceReBuild) {
        return;
      }
      if (changeTimeoutId.current) {
        clearTimeout(changeTimeoutId.current);
      }
      changeTimeoutId.current = setTimeout(function() {
        changeTimeoutId.current = null;
        reBuildList();
        setSelected();
        checkUnloadedPages();
      }, 0);
    });
    startNewList();
    setSelected();
    showSelectedCounts();
    setPickerConnector.setSelected = function(arr) {
      return setSelected({
        selectedList: arr,
        show: currentSelected.current.show
      });
    };
    setPickerConnector.showSpinner = function(onOff) {
      utils2.spinner(listName, onOff);
      if (!onOff) {
        showSelectedCounts();
      }
    };
    setPickerConnector.selectedInfo = function(data) {
      selectedIds.current = data;
      setSelected();
      showSelectedCounts();
    };
    componentReturn.getMainStates = function() {
      return {
        searchContext: currentSearchContext.current
      };
    };
    if (callbackOnReadyComponentDOM) {
      callbackOnReadyComponentDOM();
    }
    return function() {
      removeReaction();
    };
  }, []);
  var startNewList = function startNewList2() {
    var pagesIndex = utils2.getPagesIndex(currentSearchContext.current, 0);
    var pageIndex = utils2.getPageIndex(pagesIndex, 0);
    if (pages.current[pageIndex]) {
      reBuildList();
    } else {
      getBlock({
        page: 0,
        trace: "startNewList"
      });
    }
  };
  var onChangeSearh = function onChangeSearh2(search) {
    var _pages$current2;
    resetScroll();
    setList([{
      i: 0,
      p: 0,
      l: 0
    }]);
    startNewList();
    if (search) {
      var sessionOptionsIndex = CONSTANTS_SETPICKER.sessionOptionsIndex(listName);
      Store$1.updateState(sessionOptionsIndex, search);
    }
    var pagesIndex = utils2.getPagesIndex(search.searchContext, 0);
    var _mainOptions = (_pages$current2 = pages.current) === null || _pages$current2 === void 0 ? void 0 : _pages$current2._mainOptions;
    if (_mainOptions && _mainOptions[pagesIndex]) {
      var newList = _objectSpread2({}, toJS(Store$1.getState(CONSTANTS_SETPICKER.pagesData(listName))));
      newList._mainOptions = _objectSpread2(_objectSpread2({}, _mainOptions), {}, {
        totalCount: void 0
      }, _mainOptions[pagesIndex]);
      Store$1.setState(CONSTANTS_SETPICKER.pagesData(listName), newList);
    }
  };
  React__default.useEffect(function() {
    if (searchContext === void 0) {
      var sessionOptionsIndex = CONSTANTS_SETPICKER.sessionOptionsIndex(listName);
      var prevSessionData = toJS(Store$1.getState(sessionOptionsIndex));
      setSearchContext((prevSessionData === null || prevSessionData === void 0 ? void 0 : prevSessionData.searchContext) || "");
      return;
    }
    onChangeSearh({
      searchContext
    });
  }, [searchContext]);
  React__default.useEffect(function() {
    if (showSelectedList === void 0)
      return;
    resetScroll();
    reBuildList();
  }, [showSelectedList]);
  var buildParentID = function buildParentID2(_ref3) {
    var _parentID = _ref3.parentID;
    var parentID = _parentID || 0;
    var pagesIndex = utils2.getPagesIndex(currentSearchContext.current);
    var rootOptions = pages.current._rootsOptions[pagesIndex];
    var childrenElements = rootOptions ? rootOptions.childrenItems : 0;
    var childrenPages = rootOptions.pagesCounts.length;
    var out = [];
    for (var page = 0; page < childrenPages; page++) {
      var pageIndex = utils2.getPageIndex(pagesIndex, page);
      var pageItems = pages.current[pageIndex];
      if (pageItems !== null && pageItems !== void 0 && pageItems.length) {
        for (var index2 in pageItems) {
          var item = pageItems[index2];
          out.push(_objectSpread2(_objectSpread2({}, item), {}, {
            pagesIndex,
            pageIndex,
            page,
            index: Number(index2),
            searchContext: currentSearchContext.current
          }));
        }
      } else {
        var length = Math.min(childrenElements - CONFIG_API.listBlockLength * page, CONFIG_API.listBlockLength);
        for (var i = 0; i < length; i++) {
          out.push({
            i: parentID,
            p: page
          });
        }
      }
    }
    return out;
  };
  var reBuildList = function reBuildList2() {
    var rootContent = buildParentID({
      parentID: 0
    });
    setList(rootContent);
  };
  var endOfScroll = function endOfScroll2(_ref4) {
    var subListTo = _ref4.subListTo, subList = _ref4.subList;
    var getPageIndex = function getPageIndex2(context, parent, page2) {
      var pagesIndex = utils2.getPagesIndex(context, parent);
      return utils2.getPageIndex(pagesIndex, page2);
    };
    var searchContext2 = currentSearchContext.current;
    var prePageIndex = getPageIndex(searchContext2, 0, 0);
    var _iterator = _createForOfIteratorHelper(subList), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var item = _step.value;
        if (!item.id) {
          var parentID = item.i, page = item.p;
          var pageIndex = getPageIndex(searchContext2, parentID, page);
          if (pageIndex !== prePageIndex) {
            getBlock({
              parentID,
              page,
              trace: "endOfScroll-1"
            });
          }
          prePageIndex = pageIndex;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _toJS = toJS(Store$1.getState(CONSTANTS_SETPICKER.pagesData(listName))), _mainOptions = _toJS._mainOptions;
    if (subListTo && !(_mainOptions !== null && _mainOptions !== void 0 && _mainOptions.isFinalTotalCount) && subListTo >= (_mainOptions === null || _mainOptions === void 0 ? void 0 : _mainOptions.totalItems)) {
      getBlock({
        parentID: 0,
        page: subList[subList.length - 1].page + 1,
        trace: "endOfScroll-2"
      });
    }
  };
  var componentData = _objectSpread2(_objectSpread2({}, props), {}, {
    utils: utils2,
    ItemView: SetPickerItemView,
    listName,
    endOfScroll,
    setSearchContext,
    onClickToLineCheckbox,
    options,
    list,
    currentList,
    strHeight,
    resetScrollbar,
    scrollData,
    request: request2,
    counterRequest,
    showSelectedCounts,
    hideSelectedCounts,
    componentCallback: _componentCallback,
    loadingText: CONFIG_SETPICKER.loadingText,
    wheelTimeout: CONFIG_SETPICKER.wheelTimeout,
    searchTimeout: CONFIG_SETPICKER.searchTimeout,
    pages: pages.current,
    searchContext: currentSearchContext.current,
    selected,
    setSelected,
    actionsMode,
    setActionsMode,
    showSelectedList,
    setShowSelectedList
  });
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, !hideSearchBar && /* @__PURE__ */ React__default.createElement(SetPickerActions, componentData), /* @__PURE__ */ React__default.createElement(SetPickerSmartList, componentData));
};
var SetPickerActions = function SetPickerActions2(_ref) {
  var props = _extends$h({}, (_objectDestructuringEmpty(_ref), _ref));
  var options = props.options, showSelectedList = props.showSelectedList;
  var title = options.title, componentContent = options.componentContent, hideCountersBar = options.hideCountersBar;
  var showButtons = !((componentContent === null || componentContent === void 0 ? void 0 : componentContent.actions) === false);
  var showTitle = !!title;
  if (!showButtons && !showTitle) {
    return null;
  }
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "clearfix inline-set-header set-picker-actions".concat(showSelectedList ? " is-hidden" : "")
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "search-wrapper"
  }, showButtons && !hideCountersBar && /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(SetPickerActionsPanelSearch, props)), /* @__PURE__ */ React__default.createElement("div", {
    className: "d-flex justify-content-between"
  }, /* @__PURE__ */ React__default.createElement("div", null, title), showButtons && /* @__PURE__ */ React__default.createElement(SetPickerActionsButtons, props))));
};
var SetPickerActionsButtons = function SetPickerActionsButtons2(_ref) {
  var props = _extends$h({}, (_objectDestructuringEmpty(_ref), _ref));
  var actionsMode = props.actionsMode, setActionsMode = props.setActionsMode, options = props.options;
  var componentContent = options.componentContent;
  var _CONFIG_SETPICKER$act = CONFIG_SETPICKER.actionModes, search = _CONFIG_SETPICKER$act.search, addLine = _CONFIG_SETPICKER$act.addLine, edit = _CONFIG_SETPICKER$act.edit;
  var buttons = React__default.useRef([
    {
      name: search,
      className: "b-search",
      icon: "fa-search",
      title: "\u041F\u043E\u0438\u0441\u043A \u043F\u043E \u0441\u043F\u0440\u0430\u0432\u043E\u0447\u043D\u0438\u043A\u0443",
      activeIf: [search]
    }
  ]);
  var buttonIsShow = function buttonIsShow2(name) {
    return !(componentContent !== null && componentContent !== void 0 && componentContent.actions) || UTILS$2.parseParams(componentContent === null || componentContent === void 0 ? void 0 : componentContent.actions[name]).show;
  };
  var clickToButton = function clickToButton2(name) {
    return function() {
      var newMode = name;
      switch ("".concat(actionsMode, "->").concat(name)) {
        case "".concat(addLine, "->").concat(edit):
          newMode = null;
          break;
        case "".concat(addLine, "->").concat(addLine):
          newMode = edit;
          break;
      }
      setActionsMode(newMode);
    };
  };
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "d-flex g-1"
  }, buttons.current.map(function(button, index2) {
    var name = button.name, activeIf = button.activeIf, showIf = button.showIf, className = button.className, title = button.title, icon = button.icon;
    var isActive = activeIf.includes(actionsMode);
    var isShow = buttonIsShow(name) && (!showIf || showIf.includes(actionsMode));
    if (!isShow) {
      return null;
    }
    return /* @__PURE__ */ React__default.createElement("button", {
      index: index2,
      className: "tf_btn tf_btn-xs tf_btn-transparent tf_btn-icon ".concat(className).concat(UTILS$2.addActiveClassIf(isActive)),
      title,
      onClick: clickToButton(name)
    }, /* @__PURE__ */ React__default.createElement("i", {
      className: "fas fa-fw ".concat(icon)
    }));
  }));
};
var SetPickerActionsPanelSearch = function SetPickerActionsPanelSearch2(_ref) {
  var props = _extends$h({}, (_objectDestructuringEmpty(_ref), _ref));
  var actionsMode = props.actionsMode, searchContext = props.searchContext, setSearchContext = props.setSearchContext;
  var _React$useState = React__default.useState(searchContext), _React$useState2 = _slicedToArray(_React$useState, 2), value = _React$useState2[0], setValue = _React$useState2[1];
  var timeoutId = React__default.useRef(null);
  var inputRef = React__default.useRef(null);
  var onChangeValue = function onChangeValue2(e) {
    var newValue = e.target.value;
    setValue(newValue);
    if (timeoutId.current) {
      clearTimeout(timeoutId.current);
    }
    timeoutId.current = setTimeout(function() {
      timeoutId.current = null;
      setSearchContext(newValue);
    }, CONFIG_SETPICKER.searchTimeout);
  };
  var clearSearchContext = function clearSearchContext2() {
    setValue("");
    setSearchContext("");
  };
  React__default.useEffect(function() {
    if (actionsMode !== CONFIG_SETPICKER.actionModes.search) {
      return;
    }
    inputRef.current.focus();
  }, [actionsMode]);
  React__default.useEffect(function() {
    if (searchContext !== value) {
      setValue(searchContext);
    }
  }, [searchContext]);
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "c-search tf_input-group flex-grow-1".concat(UTILS$2.addHideClassIf(actionsMode !== CONFIG_SETPICKER.actionModes.search))
  }, /* @__PURE__ */ React__default.createElement("input", {
    className: "tf_form-control tf_form-control-xs tf_form-control-secondary",
    type: "text",
    value,
    placeholder: "\u041F\u043E\u0438\u0441\u043A...",
    onChange: onChangeValue,
    autoFocus: true,
    ref: inputRef
  }), /* @__PURE__ */ React__default.createElement("button", {
    className: "tf_btn tf_btn-xs tf_btn-secondary tf_btn-icon",
    title: "\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C",
    onClick: clearSearchContext
  }, /* @__PURE__ */ React__default.createElement("i", {
    className: "fas fa-backspace fa-fw"
  })));
};
var SetPickerSmartList = function SetPickerSmartList2(_ref) {
  var props = _extends$h({}, (_objectDestructuringEmpty(_ref), _ref));
  var options = props.options;
  var componentContent = options.componentContent, hideSearchBar = options.hideSearchBar;
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "tf_smartwindow-body".concat(hideSearchBar ? " without-searchbar" : "")
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "tf_smartlist"
  }, !((componentContent === null || componentContent === void 0 ? void 0 : componentContent.header) === false) && /* @__PURE__ */ React__default.createElement(SetPickerSmartListHeader, props), /* @__PURE__ */ React__default.createElement(SetPickerSmartListBody, props)));
};
var SetPickerSmartListHeader = function SetPickerSmartListHeader2(_ref) {
  var _componentContent$hea;
  var props = _extends$h({}, (_objectDestructuringEmpty(_ref), _ref));
  var options = props.options;
  var componentContent = options.componentContent, hideCountersBar = options.hideCountersBar;
  if (hideCountersBar)
    return /* @__PURE__ */ React__default.createElement("div", {
      className: "tf_smartlist-header tf_smartlist-header-hidden"
    });
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "tf_smartlist-header"
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "d-flex g-2 align-items-end p-1 overflow-hidden"
  }, UTILS$2.parseParams(componentContent === null || componentContent === void 0 || (_componentContent$hea = componentContent.header) === null || _componentContent$hea === void 0 ? void 0 : _componentContent$hea.counts).show && /* @__PURE__ */ React__default.createElement(SetPickerSmartListHeaderCounts, props)), /* @__PURE__ */ React__default.createElement(SetPickerSpinner$1, props));
};
var SetPickerSmartListHeaderCounts = function SetPickerSmartListHeaderCounts2(_ref) {
  var _mainOptions$currInde, _mainOptions$currInde2, _mainOptions$mainInde2;
  var props = _extends$h({}, (_objectDestructuringEmpty(_ref), _ref));
  var utils2 = props.utils, _props$selected = props.selected, show = _props$selected.show, selectedList = _props$selected.selectedList, searchSelectedList = _props$selected.searchSelectedList, showSelectedList = props.showSelectedList, setShowSelectedList = props.setShowSelectedList, pages = props.pages, searchContext = props.searchContext, setSearchContext = props.setSearchContext, setSelected = props.setSelected, singleChoiceOnly = props.options.singleChoiceOnly, componentCallback = props.componentCallback, listName = props.listName;
  var _mainOptions = pages._mainOptions;
  utils2.showSelectedListMode = false;
  var mainIndex = utils2.getPagesIndex("", 0);
  var currIndex = utils2.getPagesIndex(searchContext, 0);
  utils2.showSelectedListMode = showSelectedList;
  var clickToTotalCount = function clickToTotalCount2() {
    if (showSelectedList) {
      setShowSelectedList(false);
      return;
    }
    if (!(_mainOptions !== null && _mainOptions !== void 0 && _mainOptions.totalCount)) {
      utils2.spinner(listName, true);
      var resetSpinner = function resetSpinner2() {
        return utils2.spinner(listName, false);
      };
      var promise = utils2.requestGetTotalCounter(props);
      if (promise !== null && promise !== void 0 && promise.then) {
        promise.then(resetSpinner);
      }
      return;
    }
  };
  var clickToGlobalTotalCount = function clickToGlobalTotalCount2() {
    var _mainOptions$mainInde;
    if (showSelectedList) {
      setShowSelectedList(false);
      setSearchContext("");
      return;
    }
    if (!((_mainOptions$mainInde = _mainOptions[mainIndex]) !== null && _mainOptions$mainInde !== void 0 && _mainOptions$mainInde.totalCount)) {
      utils2.requestGetGlobalTotalCounter(props);
      return;
    }
    setSearchContext("");
  };
  var unselect = function unselect2() {
    setSelected({
      selectedList: []
    });
    componentCallback({
      code: CONFIG_SETPICKER.operationCodes.unselectAll
    });
  };
  var totalCountText = _mainOptions && ((_mainOptions$currInde = _mainOptions[currIndex]) === null || _mainOptions$currInde === void 0 ? void 0 : _mainOptions$currInde.totalCount) !== void 0 ? (_mainOptions$currInde2 = _mainOptions[currIndex]) === null || _mainOptions$currInde2 === void 0 ? void 0 : _mainOptions$currInde2.totalCount : showSelectedList ? "\u0432\u0441\u0435\u0445" : "\u043F\u043E\u043A\u0430\u0437\u0430\u0442\u044C";
  var globalTotalCountText = _mainOptions && ((_mainOptions$mainInde2 = _mainOptions[mainIndex]) === null || _mainOptions$mainInde2 === void 0 ? void 0 : _mainOptions$mainInde2.totalCount) !== void 0 ? _mainOptions[mainIndex].totalCount : showSelectedList ? "\u0432\u0441\u0435\u0445" : "\u043F\u043E\u043A\u0430\u0437\u0430\u0442\u044C";
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("div", {
    className: "flex-grow-1"
  }, !singleChoiceOnly && !!selectedList.length && /* @__PURE__ */ React__default.createElement("div", {
    className: "tf_form-check"
  }, /* @__PURE__ */ React__default.createElement("i", {
    className: "fas fa-times unselect",
    onClick: unselect
  }))), /* @__PURE__ */ React__default.createElement("div", {
    className: "lh-1 text-end",
    style: {
      visibility: show ? "unset" : "hidden"
    }
  }, /* @__PURE__ */ React__default.createElement("span", {
    className: "text-nowrap"
  }, "\u0432\u044B\u0431\u0440\u0430\u043D\u043E ", /* @__PURE__ */ React__default.createElement("span", {
    className: "text-primary",
    tabIndex: "1",
    role: "button",
    style: {
      "font-weight": showSelectedList === "search" ? "bold" : ""
    },
    onClick: function onClick() {
      return setShowSelectedList(true, true);
    }
  }, searchSelectedList.length || 0), " \u0438\u0437 ", /* @__PURE__ */ React__default.createElement("span", {
    className: "text-primary",
    tabIndex: "1",
    role: "button",
    style: {
      "font-weight": !showSelectedList ? "bold" : ""
    },
    onClick: clickToTotalCount
  }, totalCountText), searchContext && /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, " (\u0432\u0441\u0435\u0433\u043E ", /* @__PURE__ */ React__default.createElement("span", {
    className: "text-primary",
    tabIndex: "1",
    role: "button",
    style: {
      "font-weight": showSelectedList === "full" ? "bold" : ""
    },
    onClick: function onClick() {
      return setShowSelectedList(true, false);
    }
  }, selectedList.length || 0), " \u0438\u0437 ", /* @__PURE__ */ React__default.createElement("span", {
    className: "text-primary",
    tabIndex: "1",
    role: "button",
    onClick: clickToGlobalTotalCount
  }, globalTotalCountText), ")"))));
};
var scrollbar = "";
var Scrollbar = function Scrollbar2(_ref) {
  var _smartListRef$current;
  var props = _extends$h({}, (_objectDestructuringEmpty(_ref), _ref));
  var list = props.list, currentList = props.currentList, resetScrollbar = props.resetScrollbar, scrollData = props.scrollData, strHeight = props.strHeight;
  var smartListRef = React__default.useRef(null);
  var getSubList = function getSubList2(data2) {
    var listHeight = data2.listHeight, wrapperHeight2 = data2.wrapperHeight, scroll = data2.scroll;
    var freeSpace = listHeight - wrapperHeight2;
    var fromPx = freeSpace / 100 * scroll;
    var toPx = fromPx + wrapperHeight2;
    var subListFrom = Math.ceil(fromPx / strHeight);
    var subListTo = Math.ceil(toPx / strHeight);
    var subList = currentList.current.slice(subListFrom, subListTo + 1);
    return {
      subListFrom,
      subListTo,
      subList
    };
  };
  var _useCurrentState = useCurrentState({
    wrapperHeight: void 0,
    wrapperWidth: void 0,
    scroll: 0,
    listHeight: currentList.current.length * strHeight,
    upDownHeight: strHeight * 3,
    subListFrom: 0,
    subListTo: 0,
    subList: []
  }, true), _useCurrentState2 = _slicedToArray(_useCurrentState, 3), data = _useCurrentState2[0], currentData = _useCurrentState2[1], _setData = _useCurrentState2[2];
  var setData = function setData2(obj) {
    var cd = currentData.current;
    if (obj.listHeight && obj.listHeight !== cd.listHeight && cd.scroll === 100) {
      obj.scroll = (cd.listHeight - cd.wrapperHeight + strHeight) * 100 / (obj.listHeight - cd.wrapperHeight);
    }
    _setData(obj);
    var subListData = getSubList(currentData.current);
    Object.assign(currentData.current, subListData);
  };
  var mouseOverTheSmartList = React__default.useRef(false);
  React__default.useEffect(function() {
    if (scrollData) {
      scrollData.current = currentData;
    }
    var setSizeData = function setSizeData2() {
      setData({
        wrapperWidth: smartListRef.current.clientWidth,
        wrapperHeight: smartListRef.current.clientHeight
      });
    };
    setTimeout(function() {
      setSizeData();
    }, 0);
    smartListRef.current.onmouseover = function() {
      mouseOverTheSmartList.current = true;
    };
    smartListRef.current.onmouseleave = function() {
      mouseOverTheSmartList.current = false;
    };
  }, []);
  React__default.useEffect(function() {
    setData({
      scroll: 0
    });
  }, [resetScrollbar]);
  React__default.useEffect(function() {
    setData({
      listHeight: list.length * strHeight
    });
  }, [list]);
  var onWheel = function onWheel2(e) {
    var direction = e.deltaY > 0 ? 1 : -1;
    if (direction === -1 && data.scroll === 0) {
      return;
    }
    var listFreeSpacePx = data.listHeight - data.wrapperHeight;
    var deltaPersent = data.upDownHeight * 100 / listFreeSpacePx;
    var newScroll = Math.max(0, Math.min(100, data.scroll + deltaPersent * direction));
    setData({
      scroll: newScroll
    });
  };
  var wrapperHeight = (_smartListRef$current = smartListRef.current) === null || _smartListRef$current === void 0 ? void 0 : _smartListRef$current.clientHeight;
  if (wrapperHeight && wrapperHeight !== currentData.current.wrapperHeight) {
    setData({
      wrapperWidth: smartListRef.current.clientWidth,
      wrapperHeight: smartListRef.current.clientHeight
    });
  }
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("div", {
    className: "tf_smartlist-items",
    onWheel,
    ref: smartListRef
  }, /* @__PURE__ */ React__default.createElement(ScrollbarContainer, _extends$h({}, props, {
    list: data.subList,
    subListFrom: data.subListFrom,
    subListTo: data.subListTo
  }))), /* @__PURE__ */ React__default.createElement(ScrollbarScrollbar, _extends$h({}, props, {
    strHeight,
    data,
    setData,
    mouseOverTheSmartList: mouseOverTheSmartList.current
  })));
};
var ScrollbarScrollbar = function ScrollbarScrollbar2(_ref) {
  var props = _extends$h({}, (_objectDestructuringEmpty(_ref), _ref));
  var data = props.data, setData = props.setData, wheelTimeout = props.wheelTimeout, endOfScroll = props.endOfScroll, mouseOverTheSmartList = props.mouseOverTheSmartList;
  var listHeight = data.listHeight, wrapperHeight = data.wrapperHeight, scroll = data.scroll, subListFrom = data.subListFrom, subListTo = data.subListTo, subList = data.subList;
  var innerHeight = Math.min(1e4, listHeight);
  var wrapperRef = React__default.useRef(null);
  var setDataBlocked = React__default.useRef(false);
  var wheelTimeoutId = React__default.useRef(0);
  var forceTimeout = React__default.useRef(wheelTimeout);
  var scrollByKey = React__default.useRef(void 0);
  var scrollPercentToPx = function scrollPercentToPx2(scrollPercent) {
    return scrollPercent * (innerHeight - wrapperHeight) / 100;
  };
  var scrollPxToPercent = function scrollPxToPercent2(scrollPx) {
    return scrollPx * 100 / (innerHeight - wrapperHeight);
  };
  var checkEndOfScroll = function checkEndOfScroll2() {
    if (wheelTimeoutId.current) {
      clearTimeout(wheelTimeoutId.current);
    }
    wheelTimeoutId.current = setTimeout(function() {
      wheelTimeoutId.current = 0;
      endOfScroll({
        subListFrom,
        subListTo,
        subList
      });
    }, forceTimeout.current);
  };
  var onScroll = function onScroll2(e) {
    if (setDataBlocked.current) {
      setDataBlocked.current = false;
      checkEndOfScroll();
      return;
    }
    setDataBlocked.current = true;
    setData({
      scroll: scrollPxToPercent(e.target.scrollTop)
    });
    checkEndOfScroll();
  };
  var keyUp = function keyUp2(e) {
    if (!scrollByKey.current) {
      return;
    }
    var delta = 0;
    switch (e.code) {
      case "ArrowUp":
        delta = -1;
        break;
      case "ArrowDown":
        delta = 1;
        break;
      default:
        return;
    }
    forceTimeout.current = 0;
    wrapperRef.current.scrollBy({
      top: delta
    });
    setTimeout(function() {
      forceTimeout.current = wheelTimeout;
    }, 10);
  };
  React__default.useEffect(function() {
    document.addEventListener("keyup", keyUp);
    return function() {
      return document.removeEventListener("keyup", keyUp);
    };
  }, []);
  React__default.useEffect(function() {
    scrollByKey.current = mouseOverTheSmartList;
  }, [mouseOverTheSmartList]);
  React__default.useEffect(function() {
    if (setDataBlocked.current) {
      setDataBlocked.current = false;
      checkEndOfScroll();
      return;
    }
    var newScroll = scrollPercentToPx(scroll);
    if (wrapperRef.current.scrollTop !== newScroll) {
      setDataBlocked.current = true;
      wrapperRef.current.scrollTop = newScroll;
      checkEndOfScroll();
    }
  }, [scroll]);
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "tf_smartscroll",
    onScroll,
    ref: wrapperRef
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "tf_smartscroll-wrapper",
    style: {
      height: "".concat(innerHeight, "px")
    }
  }));
};
var ScrollbarContainer = function ScrollbarContainer2(_ref) {
  var props = _extends$h({}, (_objectDestructuringEmpty(_ref), _ref));
  var count2 = React__default.useRef(0);
  count2.current++;
  var odd = count2.current % 2 === 0;
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, odd ? /* @__PURE__ */ React__default.createElement(ScrollbarContainerOdd, props) : /* @__PURE__ */ React__default.createElement(ScrollbarContainerEven, props));
};
var ScrollbarContainerOdd = function ScrollbarContainerOdd2(_ref2) {
  var props = _extends$h({}, (_objectDestructuringEmpty(_ref2), _ref2));
  return /* @__PURE__ */ React__default.createElement(ScrollbarContainerAll, props);
};
var ScrollbarContainerEven = function ScrollbarContainerEven2(_ref3) {
  var props = _extends$h({}, (_objectDestructuringEmpty(_ref3), _ref3));
  return /* @__PURE__ */ React__default.createElement(ScrollbarContainerAll, props);
};
var ScrollbarContainerAll = function ScrollbarContainerAll2(_ref4) {
  var props = _extends$h({}, (_objectDestructuringEmpty(_ref4), _ref4));
  var list = props.list, ItemView = props.ItemView, subListFrom = props.subListFrom;
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, list.map(function(item, index2) {
    return /* @__PURE__ */ React__default.createElement(ItemView, _extends$h({}, props, {
      item,
      subListFrom,
      index: index2
    }));
  }));
};
var SetPickerSmartListBody = function SetPickerSmartListBody2(_ref) {
  var props = _extends$h({}, (_objectDestructuringEmpty(_ref), _ref));
  var options = props.options, componentReturn = props.componentReturn;
  var strHeight = options.strHeight;
  var bodyRef = React__default.useRef(null);
  var _React$useState = React__default.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), listHeight = _React$useState2[0], setListHeight = _React$useState2[1];
  var calcListHeight = function calcListHeight2() {
    var heightPX = bodyRef.current.clientHeight;
    setListHeight(Math.floor(heightPX / strHeight));
  };
  React__default.useEffect(function() {
    componentReturn.onResize = calcListHeight;
    calcListHeight();
  }, []);
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("div", {
    ref: bodyRef,
    className: "tf_smartlist-body"
  }, /* @__PURE__ */ React__default.createElement(Scrollbar, _extends$h({}, props, {
    listHeight
  }))));
};
var SetPickerItemView = function SetPickerItemView2(_ref) {
  var _componentContent$lin;
  var props = _extends$h({}, (_objectDestructuringEmpty(_ref), _ref));
  var item = props.item, selected = props.selected, options = props.options, index2 = props.index, onClickToLineCheckbox = props.onClickToLineCheckbox;
  var componentContent = options.componentContent, strHeight = options.strHeight, highlightNodes = options.highlightNodes, singleChoiceOnly = options.singleChoiceOnly, unavailableItemsList = options.unavailableItemsList, ItemViewName = options.ItemViewName;
  var id = item.id, hasChildren = item.hasChildren;
  var skeletonSpace = 4;
  var skeletonColor = "#ddd";
  var minSkeletonElements = 4;
  var maxSkeletonElements = 20;
  var minSkeletonElementLength = 5;
  var maxSkeletonElementLength = 60;
  var itemIsUnavailable = unavailableItemsList ? unavailableItemsList.includes(id) : false;
  var generateSkeletonArr = function generateSkeletonArr2() {
    var randomInteger = function randomInteger2(min2, max2) {
      return Math.floor(min2 + Math.random() * (max2 + 1 - min2));
    };
    var out = [];
    for (var i = 0; i < randomInteger(minSkeletonElements, maxSkeletonElements); i++) {
      out.push(randomInteger(minSkeletonElementLength, maxSkeletonElementLength));
    }
    return out;
  };
  var currSkeleton = React__default.useRef(generateSkeletonArr());
  var getChecked = function getChecked2() {
    return selected.selectedList.includes(id);
  };
  var _React$useState = React__default.useState(getChecked()), _React$useState2 = _slicedToArray(_React$useState, 2), checked = _React$useState2[0], setChecked = _React$useState2[1];
  var inputRef = React__default.useRef(null);
  var checkRadioClass = React__default.useRef(singleChoiceOnly ? "radio" : "check");
  var checkRadioType = React__default.useRef(singleChoiceOnly ? "radio" : "checkbox");
  React__default.useEffect(function() {
    var newChecked = getChecked();
    if (newChecked === checked) {
      return;
    }
    setChecked(newChecked);
  }, [selected]);
  var getSkeleton = function getSkeleton2(arr) {
    var out = [];
    var start = 0;
    var getSk = function getSk2(length2) {
      return "".concat(skeletonColor, " ").concat(start, "px, ").concat(skeletonColor, " ").concat(start + length2, "px, #fff ").concat(start + length2, "px, #fff ").concat(start + length2 + skeletonSpace, "px");
    };
    var _iterator = _createForOfIteratorHelper(arr), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var length = _step.value;
        out.push(getSk(length));
        start += length + skeletonSpace;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return "linear-gradient(to right, ".concat(out.join(","), ")");
  };
  var onClickToSelect = function onClickToSelect2() {
    if (itemIsUnavailable)
      return;
    onClickToLineCheckbox(item, !checked);
  };
  var itemIsEmptyClass = !id ? " item-is-empty" : "";
  var itemHasChildrenClass = hasChildren && highlightNodes ? " item-has-children" : "";
  var itemIsUnavailableClass = itemIsUnavailable ? " item-is-unavailable" : "";
  var CurrentItemViewName = ItemViewName ? ItemViewName : SetPickerItemViewName;
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("div", {
    className: "tf_smartlist-item".concat(itemIsEmptyClass).concat(itemHasChildrenClass).concat(itemIsUnavailableClass).concat(checked ? " selected" : ""),
    style: {
      height: "".concat(strHeight, "px")
    },
    index: index2,
    onClick: onClickToSelect
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "tf_smartitem"
  }, /* @__PURE__ */ React__default.createElement(SetPickerItemViewLevel, props), UTILS$2.parseParams(componentContent === null || componentContent === void 0 || (_componentContent$lin = componentContent.line) === null || _componentContent$lin === void 0 ? void 0 : _componentContent$lin.select).show && /* @__PURE__ */ React__default.createElement("div", {
    className: "tf_form-".concat(checkRadioClass.current)
  }, /* @__PURE__ */ React__default.createElement("input", {
    ref: inputRef,
    className: "tf_form-".concat(checkRadioClass.current, "-input"),
    name: "selectedGroup",
    type: checkRadioType.current,
    checked,
    onChange: function onChange() {
    }
  })), /* @__PURE__ */ React__default.createElement(CurrentItemViewName, _extends$h({}, props, {
    skeleton: typeof id === "undefined" ? getSkeleton(currSkeleton.current) : null,
    itemIsEmptyClass,
    getChecked,
    checked,
    onChange: function onChange() {
    }
  })))));
};
var SetPickerItemViewLevel = function SetPickerItemViewLevel2(_ref) {
  var props = _extends$h({}, (_objectDestructuringEmpty(_ref), _ref));
  var item = props.item, options = props.options, deltaLevel = props.deltaLevel;
  var _selectedRoots = options.selectedRoots;
  var _level = item.level, l2 = item.l, id = item.id, hasChildren = item.hasChildren;
  var empty = !id;
  var level = empty ? l2 : _level;
  level += deltaLevel || 0;
  var selectedRoots = !(_selectedRoots === false);
  var arr = UTILS$2.monoArray(level + (!hasChildren && selectedRoots), true);
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, arr.map(function() {
    return /* @__PURE__ */ React__default.createElement("div", {
      className: "s-em"
    });
  }));
};
var SetPickerItemViewName = function SetPickerItemViewName2(_ref) {
  var props = _extends$h({}, (_objectDestructuringEmpty(_ref), _ref));
  var actionsMode = props.actionsMode, item = props.item, searchContext = props.searchContext, options = props.options, skeleton = props.skeleton;
  var highlightFound = options.highlightFound;
  var id = item.id, label = item.label;
  var noName = React__default.useRef(id && label === CONFIG_SETPICKER.newItemLabel);
  var calcLabelHtml = function calcLabelHtml2() {
    return noName.current ? "" : !id ? CONFIG_SETPICKER.emptyText : searchContext && highlightFound ? UTILS$2.textWithSearchContext(label, searchContext || "") : label;
  };
  var labelHtml = React__default.useRef(calcLabelHtml());
  var isEditable = actionsMode === CONFIG_SETPICKER.actionModes.edit || actionsMode === CONFIG_SETPICKER.actionModes.addLine;
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("div", {
    className: "tf_smartitem-name".concat(noName.current ? " no-name" : ""),
    contentEditable: isEditable,
    dangerouslySetInnerHTML: {
      __html: labelHtml.current
    },
    style: skeleton ? {
      backgroundImage: skeleton
    } : {}
  }));
};
if (!useState) {
  throw new Error("mobx-react-lite requires React with Hooks support");
}
if (!makeObservable) {
  throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available");
}
function defaultNoopBatch(callback) {
  callback();
}
function observerBatching(reactionScheduler3) {
  if (!reactionScheduler3) {
    reactionScheduler3 = defaultNoopBatch;
  }
  configure({ reactionScheduler: reactionScheduler3 });
}
function printDebugValue(v) {
  return getDependencyTree(v);
}
var REGISTRY_FINALIZE_AFTER = 1e4;
var REGISTRY_SWEEP_INTERVAL = 1e4;
var TimerBasedFinalizationRegistry = function() {
  function TimerBasedFinalizationRegistry2(finalize) {
    var _this = this;
    Object.defineProperty(this, "finalize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: finalize
    });
    Object.defineProperty(this, "registrations", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
    Object.defineProperty(this, "sweepTimeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "sweep", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: function(maxAge) {
        if (maxAge === void 0) {
          maxAge = REGISTRY_FINALIZE_AFTER;
        }
        clearTimeout(_this.sweepTimeout);
        _this.sweepTimeout = void 0;
        var now2 = Date.now();
        _this.registrations.forEach(function(registration, token2) {
          if (now2 - registration.registeredAt >= maxAge) {
            _this.finalize(registration.value);
            _this.registrations.delete(token2);
          }
        });
        if (_this.registrations.size > 0) {
          _this.scheduleSweep();
        }
      }
    });
    Object.defineProperty(this, "finalizeAllImmediately", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: function() {
        _this.sweep(0);
      }
    });
  }
  Object.defineProperty(TimerBasedFinalizationRegistry2.prototype, "register", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function(target, value, token2) {
      this.registrations.set(token2, {
        value,
        registeredAt: Date.now()
      });
      this.scheduleSweep();
    }
  });
  Object.defineProperty(TimerBasedFinalizationRegistry2.prototype, "unregister", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function(token2) {
      this.registrations.delete(token2);
    }
  });
  Object.defineProperty(TimerBasedFinalizationRegistry2.prototype, "scheduleSweep", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function() {
      if (this.sweepTimeout === void 0) {
        this.sweepTimeout = setTimeout(this.sweep, REGISTRY_SWEEP_INTERVAL);
      }
    }
  });
  return TimerBasedFinalizationRegistry2;
}();
var UniversalFinalizationRegistry = typeof FinalizationRegistry !== "undefined" ? FinalizationRegistry : TimerBasedFinalizationRegistry;
var observerFinalizationRegistry = new UniversalFinalizationRegistry(function(adm) {
  var _a2;
  (_a2 = adm.reaction) === null || _a2 === void 0 ? void 0 : _a2.dispose();
  adm.reaction = null;
});
var __read = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function observerComponentNameFor(baseComponentName) {
  return "observer".concat(baseComponentName);
}
var ObjectToBeRetainedByReact = function() {
  function ObjectToBeRetainedByReact2() {
  }
  return ObjectToBeRetainedByReact2;
}();
function objectToBeRetainedByReactFactory() {
  return new ObjectToBeRetainedByReact();
}
function useObserver(fn, baseComponentName) {
  if (baseComponentName === void 0) {
    baseComponentName = "observed";
  }
  var _a2 = __read(React__default.useState(objectToBeRetainedByReactFactory), 1), objectRetainedByReact = _a2[0];
  var _b = __read(React__default.useState(), 2), setState = _b[1];
  var forceUpdate = function() {
    return setState([]);
  };
  var admRef = React__default.useRef(null);
  if (!admRef.current) {
    admRef.current = {
      reaction: null,
      mounted: false,
      changedBeforeMount: false
    };
  }
  var adm = admRef.current;
  if (!adm.reaction) {
    adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), function() {
      if (adm.mounted) {
        forceUpdate();
      } else {
        adm.changedBeforeMount = true;
      }
    });
    observerFinalizationRegistry.register(objectRetainedByReact, adm, adm);
  }
  React__default.useDebugValue(adm.reaction, printDebugValue);
  React__default.useEffect(function() {
    observerFinalizationRegistry.unregister(adm);
    adm.mounted = true;
    if (adm.reaction) {
      if (adm.changedBeforeMount) {
        adm.changedBeforeMount = false;
        forceUpdate();
      }
    } else {
      adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), function() {
        forceUpdate();
      });
      forceUpdate();
    }
    return function() {
      adm.reaction.dispose();
      adm.reaction = null;
      adm.mounted = false;
      adm.changedBeforeMount = false;
    };
  }, []);
  var rendering;
  var exception;
  adm.reaction.track(function() {
    try {
      rendering = fn();
    } catch (e) {
      exception = e;
    }
  });
  if (exception) {
    throw exception;
  }
  return rendering;
}
var hasSymbol = typeof Symbol === "function" && Symbol.for;
var ReactForwardRefSymbol = hasSymbol ? Symbol.for("react.forward_ref") : typeof forwardRef === "function" && forwardRef(function(props) {
  return null;
})["$$typeof"];
var ReactMemoSymbol = hasSymbol ? Symbol.for("react.memo") : typeof memo === "function" && memo(function(props) {
  return null;
})["$$typeof"];
function observer$1(baseComponent, options) {
  var _a2;
  if (ReactMemoSymbol && baseComponent["$$typeof"] === ReactMemoSymbol) {
    throw new Error("[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.");
  }
  var useForwardRef = (_a2 = options === null || options === void 0 ? void 0 : options.forwardRef) !== null && _a2 !== void 0 ? _a2 : false;
  var render3 = baseComponent;
  var baseComponentName = baseComponent.displayName || baseComponent.name;
  if (ReactForwardRefSymbol && baseComponent["$$typeof"] === ReactForwardRefSymbol) {
    useForwardRef = true;
    render3 = baseComponent["render"];
    if (typeof render3 !== "function") {
      throw new Error("[mobx-react-lite] `render` property of ForwardRef was not a function");
    }
  }
  var observerComponent = function(props, ref) {
    return useObserver(function() {
      return render3(props, ref);
    }, baseComponentName);
  };
  if (baseComponentName !== "") {
    observerComponent.displayName = baseComponentName;
  }
  if (baseComponent.contextTypes) {
    observerComponent.contextTypes = baseComponent.contextTypes;
  }
  if (useForwardRef) {
    observerComponent = forwardRef(observerComponent);
  }
  observerComponent = memo(observerComponent);
  copyStaticProperties(baseComponent, observerComponent);
  return observerComponent;
}
var hoistBlackList = {
  $$typeof: true,
  render: true,
  compare: true,
  type: true,
  displayName: true
};
function copyStaticProperties(base, target) {
  Object.keys(base).forEach(function(key) {
    if (!hoistBlackList[key]) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));
    }
  });
}
globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var _a$1;
observerBatching(unstable_batchedUpdates);
(_a$1 = observerFinalizationRegistry["finalizeAllImmediately"]) !== null && _a$1 !== void 0 ? _a$1 : function() {
};
var symbolId = 0;
function createSymbol(name) {
  if (typeof Symbol === "function") {
    return Symbol(name);
  }
  var symbol = "__$mobx-react " + name + " (" + symbolId + ")";
  symbolId++;
  return symbol;
}
var createdSymbols = {};
function newSymbol(name) {
  if (!createdSymbols[name]) {
    createdSymbols[name] = createSymbol(name);
  }
  return createdSymbols[name];
}
function shallowEqual$1(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  for (var i = 0; i < keysA.length; i++) {
    if (!Object.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}
function is(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function setHiddenProp(target, prop, value) {
  if (!Object.hasOwnProperty.call(target, prop)) {
    Object.defineProperty(target, prop, {
      enumerable: false,
      configurable: true,
      writable: true,
      value
    });
  } else {
    target[prop] = value;
  }
}
var mobxMixins = /* @__PURE__ */ newSymbol("patchMixins");
var mobxPatchedDefinition = /* @__PURE__ */ newSymbol("patchedDefinition");
function getMixins(target, methodName) {
  var mixins = target[mobxMixins] = target[mobxMixins] || {};
  var methodMixins = mixins[methodName] = mixins[methodName] || {};
  methodMixins.locks = methodMixins.locks || 0;
  methodMixins.methods = methodMixins.methods || [];
  return methodMixins;
}
function wrapper(realMethod, mixins) {
  var _this = this;
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  mixins.locks++;
  try {
    var retVal;
    if (realMethod !== void 0 && realMethod !== null) {
      retVal = realMethod.apply(this, args);
    }
    return retVal;
  } finally {
    mixins.locks--;
    if (mixins.locks === 0) {
      mixins.methods.forEach(function(mx) {
        mx.apply(_this, args);
      });
    }
  }
}
function wrapFunction(realMethod, mixins) {
  var fn = function fn2() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    wrapper.call.apply(wrapper, [this, realMethod, mixins].concat(args));
  };
  return fn;
}
function patch(target, methodName, mixinMethod) {
  var mixins = getMixins(target, methodName);
  if (mixins.methods.indexOf(mixinMethod) < 0) {
    mixins.methods.push(mixinMethod);
  }
  var oldDefinition = Object.getOwnPropertyDescriptor(target, methodName);
  if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {
    return;
  }
  var originalMethod = target[methodName];
  var newDefinition = createDefinition(target, methodName, oldDefinition ? oldDefinition.enumerable : void 0, mixins, originalMethod);
  Object.defineProperty(target, methodName, newDefinition);
}
function createDefinition(target, methodName, enumerable, mixins, originalMethod) {
  var _ref;
  var wrappedFunc = wrapFunction(originalMethod, mixins);
  return _ref = {}, _ref[mobxPatchedDefinition] = true, _ref.get = function get5() {
    return wrappedFunc;
  }, _ref.set = function set5(value) {
    if (this === target) {
      wrappedFunc = wrapFunction(value, mixins);
    } else {
      var newDefinition = createDefinition(this, methodName, enumerable, mixins, value);
      Object.defineProperty(this, methodName, newDefinition);
    }
  }, _ref.configurable = true, _ref.enumerable = enumerable, _ref;
}
var mobxAdminProperty = $mobx || "$mobx";
var mobxObserverProperty = /* @__PURE__ */ newSymbol("isMobXReactObserver");
var mobxIsUnmounted = /* @__PURE__ */ newSymbol("isUnmounted");
var skipRenderKey = /* @__PURE__ */ newSymbol("skipRender");
var isForcingUpdateKey = /* @__PURE__ */ newSymbol("isForcingUpdate");
function makeClassComponentObserver(componentClass) {
  var target = componentClass.prototype;
  if (componentClass[mobxObserverProperty]) {
    var displayName = getDisplayName(target);
    console.warn("The provided component class (" + displayName + ")\n                has already been declared as an observer component.");
  } else {
    componentClass[mobxObserverProperty] = true;
  }
  if (target.componentWillReact) {
    throw new Error("The componentWillReact life-cycle event is no longer supported");
  }
  if (componentClass["__proto__"] !== PureComponent) {
    if (!target.shouldComponentUpdate) {
      target.shouldComponentUpdate = observerSCU;
    } else if (target.shouldComponentUpdate !== observerSCU) {
      throw new Error("It is not allowed to use shouldComponentUpdate in observer based components.");
    }
  }
  makeObservableProp(target, "props");
  makeObservableProp(target, "state");
  if (componentClass.contextType) {
    makeObservableProp(target, "context");
  }
  var originalRender = target.render;
  if (typeof originalRender !== "function") {
    var _displayName = getDisplayName(target);
    throw new Error("[mobx-react] class component (" + _displayName + ") is missing `render` method.\n`observer` requires `render` being a function defined on prototype.\n`render = () => {}` or `render = function() {}` is not supported.");
  }
  target.render = function() {
    this.render = createReactiveRender.call(this, originalRender);
    return this.render();
  };
  patch(target, "componentDidMount", function() {
    this[mobxIsUnmounted] = false;
    if (!this.render[mobxAdminProperty]) {
      Component.prototype.forceUpdate.call(this);
    }
  });
  patch(target, "componentWillUnmount", function() {
    var reaction2 = this.render[mobxAdminProperty];
    if (reaction2) {
      reaction2.dispose();
      this.render[mobxAdminProperty] = null;
    } else {
      var _displayName2 = getDisplayName(this);
      console.warn("The reactive render of an observer class component (" + _displayName2 + ")\n                was overridden after MobX attached. This may result in a memory leak if the\n                overridden reactive render was not properly disposed.");
    }
    this[mobxIsUnmounted] = true;
  });
  return componentClass;
}
function getDisplayName(comp) {
  return comp.displayName || comp.name || comp.constructor && (comp.constructor.displayName || comp.constructor.name) || "<component>";
}
function createReactiveRender(originalRender) {
  var _this = this;
  setHiddenProp(this, skipRenderKey, false);
  setHiddenProp(this, isForcingUpdateKey, false);
  var initialName = getDisplayName(this);
  var boundOriginalRender = originalRender.bind(this);
  var isRenderingPending = false;
  var createReaction = function createReaction2() {
    var reaction2 = new Reaction(initialName + ".render()", function() {
      if (!isRenderingPending) {
        isRenderingPending = true;
        if (_this[mobxIsUnmounted] !== true) {
          var hasError = true;
          try {
            setHiddenProp(_this, isForcingUpdateKey, true);
            if (!_this[skipRenderKey]) {
              Component.prototype.forceUpdate.call(_this);
            }
            hasError = false;
          } finally {
            setHiddenProp(_this, isForcingUpdateKey, false);
            if (hasError) {
              reaction2.dispose();
              _this.render[mobxAdminProperty] = null;
            }
          }
        }
      }
    });
    reaction2["reactComponent"] = _this;
    return reaction2;
  };
  function reactiveRender() {
    var _reactiveRender$mobxA;
    isRenderingPending = false;
    var reaction2 = (_reactiveRender$mobxA = reactiveRender[mobxAdminProperty]) != null ? _reactiveRender$mobxA : reactiveRender[mobxAdminProperty] = createReaction();
    var exception = void 0;
    var rendering = void 0;
    reaction2.track(function() {
      try {
        rendering = allowStateChanges(false, boundOriginalRender);
      } catch (e) {
        exception = e;
      }
    });
    if (exception) {
      throw exception;
    }
    return rendering;
  }
  return reactiveRender;
}
function observerSCU(nextProps, nextState) {
  if (this.state !== nextState) {
    return true;
  }
  return !shallowEqual$1(this.props, nextProps);
}
function makeObservableProp(target, propName) {
  var valueHolderKey = newSymbol("reactProp_" + propName + "_valueHolder");
  var atomHolderKey = newSymbol("reactProp_" + propName + "_atomHolder");
  function getAtom2() {
    if (!this[atomHolderKey]) {
      setHiddenProp(this, atomHolderKey, createAtom("reactive " + propName));
    }
    return this[atomHolderKey];
  }
  Object.defineProperty(target, propName, {
    configurable: true,
    enumerable: true,
    get: function get5() {
      var prevReadState = false;
      if (allowStateReadsStart && allowStateReadsEnd) {
        prevReadState = allowStateReadsStart(true);
      }
      getAtom2.call(this).reportObserved();
      if (allowStateReadsStart && allowStateReadsEnd) {
        allowStateReadsEnd(prevReadState);
      }
      return this[valueHolderKey];
    },
    set: function set5(v) {
      if (!this[isForcingUpdateKey] && !shallowEqual$1(this[valueHolderKey], v)) {
        setHiddenProp(this, valueHolderKey, v);
        setHiddenProp(this, skipRenderKey, true);
        getAtom2.call(this).reportChanged();
        setHiddenProp(this, skipRenderKey, false);
      } else {
        setHiddenProp(this, valueHolderKey, v);
      }
    }
  });
}
function observer(component) {
  if (component["isMobxInjector"] === true) {
    console.warn("Mobx observer: You are trying to use `observer` on a component that already has `inject`. Please apply `observer` before applying `inject`");
  }
  if (Object.prototype.isPrototypeOf.call(Component, component) || Object.prototype.isPrototypeOf.call(PureComponent, component)) {
    return makeClassComponentObserver(component);
  } else {
    return observer$1(component);
  }
}
if (!Component)
  throw new Error("mobx-react requires React to be available");
if (!observable)
  throw new Error("mobx-react requires mobx to be available");
var SetPickerSpinner = function SetPickerSpinner2(_ref) {
  var props = _extends$h({}, (_objectDestructuringEmpty(_ref), _ref));
  var listName = props.listName;
  var showSpinner = Store$1.getState(CONSTANTS_SETPICKER.stateSpinner(listName));
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "spinner",
    style: {
      background: showSpinner ? "" : "#fff"
    }
  });
};
var SetPickerSpinner$1 = observer(SetPickerSpinner);
var CONFIG_SETPICKER = {
  lineHeight: 23,
  wheelTimeout: 200,
  searchTimeout: 500,
  newItemLabel: " ",
  emptyText: "",
  emptyId: "",
  loadingText: "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430...",
  actionModes: {
    search: "search",
    addLine: "addLine",
    edit: "edit"
  },
  operationCodes: {
    actionsAddNewLine: "actions-add-new-line",
    actionsRenameLine: "actions-rename-line",
    actionsChangeSelectedLevels: "actions-change-selected-levels",
    itemMenuSelectAllLevels: "item-menu-select-all-levels",
    itemMenuSelectChild: "item-menu-select-child",
    itemMenuRaiseLevel: "item-menu-raise-level",
    itemMenuLowerLevel: "item-menu-lower-level",
    itemMenuAddChild: "item-menu-add-child",
    itemMenuDeleteWithLevels: "item-menu-delete-with-levels",
    itemMenuDelete: "item-menu-delete",
    itemSelect: "item-select",
    unselectell: "unselect-all",
    changeSearchContext: "change-search-context",
    changeSearchFilter: "change-search-filter"
  },
  url: function url(set_id, elem_id) {
    return {
      getBlock: "/rspa/set/".concat(set_id, "/page2/"),
      getCounters: "/rspa/set/".concat(set_id, "/counters2/"),
      addNewItem: "/rspa/set/".concat(set_id, "/elements/"),
      renameItem: "/rspa/set/".concat(set_id, "/elements/").concat(elem_id, "/"),
      deleteItem: "/rspa/set/".concat(set_id, "/elements/").concat(elem_id, "/"),
      constraints: "/rspa/set/".concat(set_id, "/constraints/")
    };
  }
};
var CONSTANTS_SETPICKER = {
  widgetName: "setpicker",
  dataName: {
    sessionOptions: "_sessionOptions",
    mainOptions: "_mainOptions",
    pagesOptions: "_pagesOptions",
    rootsOptions: "_rootsOptions",
    pagesIndexes: "_pagesIndexes"
  },
  initStates: {
    spinner: false,
    spinner2: false
  },
  initCommonStates: {
    currentListName: void 0,
    listNames: {}
  }
};
CONSTANTS_SETPICKER.pagesData = function(listName) {
  return "".concat(CONSTANTS_SETPICKER.widgetName, "-pagesData-").concat(listName);
};
CONSTANTS_SETPICKER.pageData = function(listName, pageIndex, index2) {
  return "".concat(CONSTANTS_SETPICKER.pagesData(listName), ".").concat(pageIndex, ".").concat(index2);
};
CONSTANTS_SETPICKER.sessionOptionsIndex = function(listName) {
  return "".concat(CONSTANTS_SETPICKER.pagesData(listName), ".").concat(CONSTANTS_SETPICKER.dataName.sessionOptions);
};
CONSTANTS_SETPICKER.rootsOptionsIndex = function(listName) {
  return "".concat(CONSTANTS_SETPICKER.pagesData(listName), ".").concat(CONSTANTS_SETPICKER.dataName.rootsOptions);
};
CONSTANTS_SETPICKER.states = function(listName) {
  return "".concat(CONSTANTS_SETPICKER.widgetName, "-states-").concat(listName);
};
CONSTANTS_SETPICKER.state = function(listName, stateName) {
  return "".concat(CONSTANTS_SETPICKER.states(listName), ".").concat(stateName);
};
CONSTANTS_SETPICKER.stateSpinner = function(listName) {
  return "".concat(CONSTANTS_SETPICKER.states(listName), ".spinner");
};
CONSTANTS_SETPICKER.stateSpinner2 = function(listName) {
  return "".concat(CONSTANTS_SETPICKER.states(listName), ".spinner2");
};
CONSTANTS_SETPICKER.commonStates = function() {
  return "".concat(CONSTANTS_SETPICKER.widgetName, "-commonStates");
};
CONSTANTS_SETPICKER.currentListName = function() {
  return "".concat(CONSTANTS_SETPICKER.commonStates(), ".currentListName");
};
CONSTANTS_SETPICKER.listNams = function() {
  return "".concat(CONSTANTS_SETPICKER.commonStates(), ".listNames");
};
var Utils$1 = /* @__PURE__ */ function() {
  function Utils2(_ref) {
    var finalList = _ref.finalList;
    _classCallCheck$a(this, Utils2);
    _defineProperty$7(this, "blockDataConverter", function(_ref2) {
      var searchContext = _ref2.searchContext, page = _ref2.page;
      return function(_response) {
        var response = Array.isArray(_response) ? _response : [_response];
        var out = {
          data: response.map(function(item) {
            return {
              id: item || CONFIG_SETPICKER.emptyId,
              label: item
            };
          }),
          searchContext: searchContext || "",
          page
        };
        return out;
      };
    });
    this.finalList = finalList || null;
    this.indexDetails = {
      zeroSearch: "<ALL>",
      selectedSearch: "<SELECTED ONLY>"
    };
    this.showSelectedListMode = false;
    this.error = {
      pageReadingError: "*** \u041E\u0428\u0418\u0411\u041A\u0410 \u0427\u0422\u0415\u041D\u0418\u042F \u0421\u0422\u0420\u0410\u041D\u0418\u0426\u042B ***"
    };
  }
  return _createClass$9(Utils2, [{
    key: "getFilterIndex",
    value: function getFilterIndex(search) {
      return "search=".concat(this.showSelectedListMode ? this.indexDetails.selectedSearch : search || this.indexDetails.zeroSearch);
    }
  }, {
    key: "getPagesIndex",
    value: function getPagesIndex(search, id) {
      return "".concat(this.getFilterIndex(search), " id=").concat(id || 0);
    }
  }, {
    key: "getPageIndex",
    value: function getPageIndex(pagesIndex, num) {
      return "".concat(pagesIndex, " page=").concat(num || 0);
    }
  }, {
    key: "spinner",
    value: function spinner(listName, show) {
      var spinnerAddr = CONSTANTS_SETPICKER.stateSpinner(listName);
      var spinner2 = Store$1.getState(spinnerAddr);
      if (spinner2 !== show) {
        Store$1.setState(spinnerAddr, show);
      }
    }
  }, {
    key: "storeSavePage",
    value: function storeSavePage(_ref3) {
      var props = _extends$h({}, (_objectDestructuringEmpty(_ref3), _ref3));
      var listName = props.listName, _pagesIndex = props.pagesIndex, _pageIndex = props.pageIndex, oldList = props.oldList, data = props.data, callbackForGetBlock = props.callbackForGetBlock;
      var dataFromServer = data.data, page = data.page, _data$searchContext = data.searchContext, searchContext = _data$searchContext === void 0 ? "" : _data$searchContext;
      var pagesIndex = _pagesIndex || this.getPagesIndex(searchContext, 0);
      var pageIndex = _pageIndex || this.getPageIndex(pagesIndex, page);
      var newList = oldList || _objectSpread2({}, toJS(Store$1.getState(CONSTANTS_SETPICKER.pagesData(listName))));
      newList[pageIndex] = dataFromServer;
      newList._rootsOptions = newList._rootsOptions || {};
      newList._rootsOptions[pagesIndex] = newList._rootsOptions[pagesIndex] || {
        childrenItems: 0,
        pagesCounts: []
      };
      var _length = newList._rootsOptions[pagesIndex].childrenItems + dataFromServer.length;
      newList._rootsOptions[pagesIndex].childrenItems = _length;
      newList._rootsOptions[pagesIndex].pagesCounts.push(dataFromServer.length);
      newList._items = newList._items || {};
      var _iterator = _createForOfIteratorHelper(dataFromServer), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var item = _step.value;
          newList._items[item.id] = item.label;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (!newList._mainOptions) {
        newList._mainOptions = {
          hasParent: false,
          totalItems: 0,
          pagesCounts: []
        };
      }
      if (newList._mainOptions[pagesIndex] && page === 0) {
        return;
      }
      newList._pagesOptions = newList._pagesOptions || {};
      newList._pagesOptions[pagesIndex] = {
        parentID: 0,
        page
      };
      var pageLevel = 0;
      newList._pagesIndexes = newList._pagesIndexes || {};
      newList._pagesIndexes[pagesIndex] = {
        searchContext,
        parentID: 0,
        pagesIndex,
        pageIndex,
        pageLevel
      };
      newList._pagesIndexes[pageIndex] = {
        searchContext,
        parentID: 0,
        page,
        pagesIndex,
        pageIndex,
        pageLevel
      };
      newList._change = {
        searchContext,
        parentID: 0,
        pagesIndex,
        pageIndex,
        page
      };
      if (!oldList) {
        Store$1.setState(CONSTANTS_SETPICKER.pagesData(listName), newList);
      }
      var counter = {
        childrenItems: _length,
        pagesCounts: newList._rootsOptions[pagesIndex].pagesCounts,
        totalItems: _length
      };
      if (dataFromServer.length < CONFIG_API.listBlockLength || this.finalList) {
        counter.isFinalTotalCount = true;
        counter.totalCount = _length;
      }
      this.storeSaveCounters(_objectSpread2(_objectSpread2({}, props), {}, {
        data: counter
      }));
      if (callbackForGetBlock) {
        callbackForGetBlock();
      }
    }
  }, {
    key: "storeSaveCounters",
    value: function storeSaveCounters(_ref4) {
      var _newData$_mainOptions;
      var props = _extends$h({}, (_objectDestructuringEmpty(_ref4), _ref4));
      var listName = props.listName, _props$searchContext = props.searchContext, searchContext = _props$searchContext === void 0 ? "" : _props$searchContext, parentID = props.parentID, callbackForGetBlock = props.callbackForGetBlock, data = props.data;
      var totalItems = data.totalItems, _totalCount = data.totalCount, childrenItems = data.childrenItems, pagesCounts = data.pagesCounts, isFinalTotalCount = data.isFinalTotalCount;
      var pagesIndex = this.getPagesIndex(searchContext, parentID);
      var newData = _objectSpread2({}, toJS(Store$1.getState(CONSTANTS_SETPICKER.pagesData(listName))));
      var totalCount = _totalCount !== void 0 ? _totalCount : (_newData$_mainOptions = newData._mainOptions[pagesIndex]) === null || _newData$_mainOptions === void 0 ? void 0 : _newData$_mainOptions.totalCount;
      if (totalItems !== void 0) {
        var out = {
          totalItems,
          isFinalTotalCount: !!isFinalTotalCount,
          totalCount,
          pagesCounts
        };
        newData._mainOptions = _objectSpread2(_objectSpread2(_objectSpread2({}, newData._mainOptions), out), {}, _defineProperty$7({}, pagesIndex, _objectSpread2({}, out)));
      }
      newData._rootsOptions[pagesIndex] = {
        childrenItems,
        pagesCounts
      };
      newData._change.forceReBuild = true;
      Store$1.setState(CONSTANTS_SETPICKER.pagesData(listName), newData);
      if (callbackForGetBlock) {
        callbackForGetBlock();
      }
    }
  }, {
    key: "storeSaveTotalCounter",
    value: function storeSaveTotalCounter(_ref5) {
      var props = _extends$h({}, (_objectDestructuringEmpty(_ref5), _ref5));
      var listName = props.listName, _props$searchContext2 = props.searchContext, searchContext = _props$searchContext2 === void 0 ? "" : _props$searchContext2, parentID = props.parentID, totalCount = props.data;
      var pagesIndex = this.getPagesIndex(searchContext, parentID);
      var newData = _objectSpread2({}, toJS(Store$1.getState(CONSTANTS_SETPICKER.pagesData(listName))));
      newData._mainOptions.totalCount = totalCount;
      newData._mainOptions[pagesIndex].totalCount = totalCount;
      Store$1.setState(CONSTANTS_SETPICKER.pagesData(listName), newData);
    }
  }, {
    key: "storeSaveGlobalTotalCounter",
    value: function storeSaveGlobalTotalCounter(_ref6) {
      var props = _extends$h({}, (_objectDestructuringEmpty(_ref6), _ref6));
      var listName = props.listName, _props$searchContext3 = props.searchContext, searchContext = _props$searchContext3 === void 0 ? "" : _props$searchContext3, parentID = props.parentID, totalCount = props.data;
      var pagesIndex = this.getPagesIndex("", parentID);
      var newData = _objectSpread2({}, toJS(Store$1.getState(CONSTANTS_SETPICKER.pagesData(listName))));
      if (!searchContext)
        newData._mainOptions.totalCount = totalCount;
      newData._mainOptions[pagesIndex].totalCount = totalCount;
      Store$1.setState(CONSTANTS_SETPICKER.pagesData(listName), newData);
    }
  }, {
    key: "getSearchArr",
    value: function getSearchArr(list, search) {
      if (!search)
        return list;
      var context = search.toLowerCase();
      return list.filter(function(item) {
        return ~item.toLowerCase().indexOf(context);
      });
    }
  }, {
    key: "requestGetPage",
    value: function requestGetPage(props) {
      var _this = this;
      var _request = props.request, searchContext = props.searchContext, page = props.page, callbackForGetBlock = props.callbackForGetBlock;
      if (this.finalList) {
        var subList = this.getSearchArr(this.finalList, searchContext);
        var data = this.blockDataConverter({
          searchContext,
          page
        })(subList);
        this.storeSavePage(_objectSpread2(_objectSpread2({}, props), {}, {
          data
        }));
        return;
      }
      var _request$method = _request.method, method = _request$method === void 0 ? "get" : _request$method, url2 = _request.url, registryId = _request.registryId, _request$keys = _request.keys, keys2 = _request$keys === void 0 ? {} : _request$keys;
      var _keys$pageLength = keys2.pageLength, keyPageLength = _keys$pageLength === void 0 ? "length" : _keys$pageLength, _keys$pageNum = keys2.pageNum, keyPageNum = _keys$pageNum === void 0 ? "page_num" : _keys$pageNum, _keys$searchContext = keys2.searchContext, keySearchContext = _keys$searchContext === void 0 ? "search" : _keys$searchContext;
      var _url = registryId ? url2.replace("<registryId>", registryId) : url2;
      var _length = "?".concat(keyPageLength, "=").concat(CONFIG_API.listBlockLength);
      var _page = "&".concat(keyPageNum, "=").concat(page);
      var _search = !!searchContext ? "&".concat(keySearchContext, "=").concat(searchContext) : "";
      return request[method]({
        url: "".concat(_url).concat(_length).concat(_page).concat(_search),
        dataConverter: this.blockDataConverter({
          searchContext,
          page
        }),
        success: function success(data2) {
          _this.storeSavePage(_objectSpread2(_objectSpread2({}, props), {}, {
            data: data2
          }));
        },
        error: function error(data2) {
          console.error(_this.error.pageReadingError, "requestGetPage", data2);
          callbackForGetBlock();
        }
      });
    }
  }, {
    key: "requestGetTotalCounter",
    value: function requestGetTotalCounter(props) {
      var _this2 = this;
      var _request = props.request, searchContext = props.searchContext, callbackForGetBlock = props.callbackForGetBlock, counterRequest = props.counterRequest;
      var _request$method2 = _request.method, method = _request$method2 === void 0 ? "get" : _request$method2, url2 = _request.url, registryId = _request.registryId, _request$keys2 = _request.keys, keys2 = _request$keys2 === void 0 ? {} : _request$keys2;
      var _keys$searchContext2 = keys2.searchContext, keySearchContext = _keys$searchContext2 === void 0 ? "search" : _keys$searchContext2, _keys$count = keys2.count, keyCount = _keys$count === void 0 ? "count" : _keys$count;
      if (counterRequest.current[searchContext])
        return;
      counterRequest.current[searchContext] = true;
      var _url = registryId ? url2.replace("<registryId>", registryId) : url2;
      var _count = "?".concat(keyCount, "=true");
      var _search = !!searchContext ? "&".concat(keySearchContext, "=").concat(searchContext) : "";
      return request[method]({
        url: "".concat(_url).concat(_count).concat(_search),
        success: function success(data) {
          _this2.storeSaveTotalCounter(_objectSpread2(_objectSpread2({}, props), {}, {
            data
          }));
          counterRequest.current[searchContext] = false;
        },
        error: function error(data) {
          console.error(_this2.error.pageReadingError, "requestGetTotalCounter", data);
          callbackForGetBlock();
          counterRequest.current[searchContext] = false;
        }
      });
    }
  }, {
    key: "requestGetGlobalTotalCounter",
    value: function requestGetGlobalTotalCounter(props) {
      var _this3 = this;
      var _request = props.request, callbackForGetBlock = props.callbackForGetBlock, counterRequest = props.counterRequest;
      var _request$method3 = _request.method, method = _request$method3 === void 0 ? "get" : _request$method3, url2 = _request.url, registryId = _request.registryId, _request$keys3 = _request.keys, keys2 = _request$keys3 === void 0 ? {} : _request$keys3;
      var _keys$count2 = keys2.count, keyCount = _keys$count2 === void 0 ? "count" : _keys$count2;
      var searchContext = this.indexDetails.zeroSearch;
      if (counterRequest.current[searchContext])
        return;
      counterRequest.current[searchContext] = true;
      var _url = registryId ? url2.replace("<registryId>", registryId) : url2;
      var _count = "?".concat(keyCount, "=true");
      return request[method]({
        url: "".concat(_url).concat(_count),
        success: function success(data) {
          _this3.storeSaveGlobalTotalCounter(_objectSpread2(_objectSpread2({}, props), {}, {
            data
          }));
          counterRequest.current[searchContext] = false;
        },
        error: function error(data) {
          console.error(_this3.error.pageReadingError, "requestGetGlobalTotalCounter", data);
          callbackForGetBlock();
          counterRequest.current[searchContext] = false;
        }
      });
    }
  }, {
    key: "goToSelectedListMode",
    value: function goToSelectedListMode(props) {
      var listName = props.listName, list = props.list;
      var listLength = list.length;
      var newList = _objectSpread2({}, toJS(Store$1.getState(CONSTANTS_SETPICKER.pagesData(listName))));
      var items = newList._items;
      var pagesIndex = this.getPagesIndex(null, 0);
      var pageIndex = this.getPageIndex(pagesIndex, 0);
      var out = [];
      var _iterator2 = _createForOfIteratorHelper(list), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var name = _step2.value;
          out.push({
            id: name,
            label: items[name]
          });
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      newList[pageIndex] = out;
      newList._rootsOptions[pagesIndex] = {
        childrenItems: listLength,
        pagesCounts: [listLength]
      };
      var newMainOptions = {
        isFinalTotalCount: true,
        totalItems: listLength,
        totalCount: listLength
      };
      var oldMainOptions = JSON.parse(JSON.stringify(newList._mainOptions));
      newList._mainOptions = _objectSpread2(_objectSpread2(_objectSpread2({}, newList._mainOptions), newMainOptions), {}, _defineProperty$7(_defineProperty$7({}, pagesIndex, _objectSpread2({}, newMainOptions)), "oldMainOptions", oldMainOptions));
      Store$1.setState(CONSTANTS_SETPICKER.pagesData(listName), newList);
    }
  }, {
    key: "goFromSelectedListMode",
    value: function goFromSelectedListMode(_ref7) {
      var listName = _ref7.listName;
      var newList = _objectSpread2({}, toJS(Store$1.getState(CONSTANTS_SETPICKER.pagesData(listName))));
      newList._mainOptions = newList._mainOptions.oldMainOptions;
      Store$1.setState(CONSTANTS_SETPICKER.pagesData(listName), newList);
    }
  }]);
}();
function ListPicker(props) {
  var _props$label = props.label, label = _props$label === void 0 ? "" : _props$label, _props$list = props.list, list = _props$list === void 0 ? [] : _props$list, _props$selectedValue = props.selectedValue, selectedValue = _props$selectedValue === void 0 ? "" : _props$selectedValue, _props$selectedValues = props.selectedValues, selectedValues = _props$selectedValues === void 0 ? [] : _props$selectedValues, _props$onChange = props.onChange, onChange = _props$onChange === void 0 ? function() {
  } : _props$onChange, _props$isMultiSelect = props.isMultiSelect, isMultiSelect = _props$isMultiSelect === void 0 ? false : _props$isMultiSelect, _props$hideSearchBar = props.hideSearchBar, hideSearchBar = _props$hideSearchBar === void 0 ? false : _props$hideSearchBar, _props$hideCountersBa = props.hideCountersBar, hideCountersBar = _props$hideCountersBa === void 0 ? false : _props$hideCountersBa, _props$ItemViewName = props.ItemViewName, ItemViewName = _props$ItemViewName === void 0 ? false : _props$ItemViewName, _props$extraClass = props.extraClass, extraClass = _props$extraClass === void 0 ? "" : _props$extraClass;
  var componentRef = React__default.useRef(null);
  var componentCallback = function componentCallback2(data) {
    var code = data.code, selectedValues2 = data.selectedList;
    if (code !== "item-select")
      return;
    onChange({
      inputType: "select",
      label,
      list,
      selectedValues: selectedValues2
    });
  };
  var getSelected = function getSelected2() {
    if (selectedValue) {
      return selectedValue.split(", ");
    }
    if (selectedValues) {
      if (Array.isArray(selectedValues)) {
        return selectedValues;
      }
      return [selectedValues];
    }
    return [];
  };
  var getOptions = function getOptions2() {
    return {
      listName: label,
      request: null,
      singleChoiceOnly: !isMultiSelect,
      title: false,
      selectable: true,
      finalList: list.map(function(item) {
        return item.label ? item.label : item;
      }),
      unavailableItemsList: list.filter(function(item) {
        return item.notAvailable;
      }).map(function(item) {
        return item.label;
      }),
      highlightFound: true,
      selectedList: getSelected(),
      strHeight: 18,
      listBlockLength: list.length,
      hideSearchBar,
      hideCountersBar,
      ItemViewName
    };
  };
  React__default.useEffect(function() {
    return function() {
    };
  }, []);
  var componentReturn = React__default.useRef({});
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "setpicker-component-root".concat(extraClass ? " " + extraClass : ""),
    ref: componentRef
  }, /* @__PURE__ */ React__default.createElement(SetPicker, {
    options: getOptions(),
    componentCallback,
    componentReturn: componentReturn.current
  }));
}
var elementsPickerHeader = "";
var elementsPickerList = "";
var elementsPickerList_item = "";
var elementsPicker = "";
var alert = "";
var prompt = "";
function r(e) {
  var t, f2, n2 = "";
  if ("string" == typeof e || "number" == typeof e)
    n2 += e;
  else if ("object" == typeof e)
    if (Array.isArray(e)) {
      var o = e.length;
      for (t = 0; t < o; t++)
        e[t] && (f2 = r(e[t])) && (n2 && (n2 += " "), n2 += f2);
    } else
      for (f2 in e)
        e[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e, t, f2 = 0, n2 = "", o = arguments.length; f2 < o; f2++)
    (e = arguments[f2]) && (t = r(e)) && (n2 && (n2 += " "), n2 += t);
  return n2;
}
function toDate(argument) {
  const argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new argument.constructor(+argument);
  } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
    return new Date(argument);
  } else {
    return new Date(NaN);
  }
}
function constructFrom(date2, value) {
  if (date2 instanceof Date) {
    return new date2.constructor(value);
  } else {
    return new Date(value);
  }
}
function addDays(date2, amount) {
  const _date = toDate(date2);
  if (isNaN(amount))
    return constructFrom(date2, NaN);
  if (!amount) {
    return _date;
  }
  _date.setDate(_date.getDate() + amount);
  return _date;
}
function addMonths(date2, amount) {
  const _date = toDate(date2);
  if (isNaN(amount))
    return constructFrom(date2, NaN);
  if (!amount) {
    return _date;
  }
  const dayOfMonth = _date.getDate();
  const endOfDesiredMonth = constructFrom(date2, _date.getTime());
  endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
  const daysInMonth2 = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth2) {
    return endOfDesiredMonth;
  } else {
    _date.setFullYear(
      endOfDesiredMonth.getFullYear(),
      endOfDesiredMonth.getMonth(),
      dayOfMonth
    );
    return _date;
  }
}
function addMilliseconds(date2, amount) {
  const timestamp = +toDate(date2);
  return constructFrom(date2, timestamp + amount);
}
const millisecondsInWeek = 6048e5;
const millisecondsInDay = 864e5;
const millisecondsInMinute = 6e4;
const millisecondsInHour = 36e5;
const millisecondsInSecond = 1e3;
function addHours(date2, amount) {
  return addMilliseconds(date2, amount * millisecondsInHour);
}
let defaultOptions = {};
function getDefaultOptions$1() {
  return defaultOptions;
}
function startOfWeek(date2, options) {
  var _a2, _b, _c, _d, _e, _f, _g, _h;
  const defaultOptions2 = getDefaultOptions$1();
  const weekStartsOn = (_h = (_g = (_d = (_c = options == null ? void 0 : options.weekStartsOn) != null ? _c : (_b = (_a2 = options == null ? void 0 : options.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b.weekStartsOn) != null ? _d : defaultOptions2.weekStartsOn) != null ? _g : (_f = (_e = defaultOptions2.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) != null ? _h : 0;
  const _date = toDate(date2);
  const day = _date.getDay();
  const diff2 = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff2);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function startOfISOWeek(date2) {
  return startOfWeek(date2, { weekStartsOn: 1 });
}
function getISOWeekYear(date2) {
  const _date = toDate(date2);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(date2, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(date2, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfDay(date2) {
  const _date = toDate(date2);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function getTimezoneOffsetInMilliseconds(date2) {
  const _date = toDate(date2);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date2 - +utcDate;
}
function differenceInCalendarDays(dateLeft, dateRight) {
  const startOfDayLeft = startOfDay(dateLeft);
  const startOfDayRight = startOfDay(dateRight);
  const timestampLeft = +startOfDayLeft - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  const timestampRight = +startOfDayRight - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / millisecondsInDay);
}
function startOfISOWeekYear(date2) {
  const year = getISOWeekYear(date2);
  const fourthOfJanuary = constructFrom(date2, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}
function addMinutes(date2, amount) {
  return addMilliseconds(date2, amount * millisecondsInMinute);
}
function addQuarters(date2, amount) {
  const months2 = amount * 3;
  return addMonths(date2, months2);
}
function addSeconds(date2, amount) {
  return addMilliseconds(date2, amount * 1e3);
}
function addWeeks(date2, amount) {
  const days2 = amount * 7;
  return addDays(date2, days2);
}
function addYears(date2, amount) {
  return addMonths(date2, amount * 12);
}
function max$1(dates) {
  let result;
  dates.forEach(function(dirtyDate) {
    const currentDate = toDate(dirtyDate);
    if (result === void 0 || result < currentDate || isNaN(Number(currentDate))) {
      result = currentDate;
    }
  });
  return result || new Date(NaN);
}
function min$1(dates) {
  let result;
  dates.forEach((dirtyDate) => {
    const date2 = toDate(dirtyDate);
    if (!result || result > date2 || isNaN(+date2)) {
      result = date2;
    }
  });
  return result || new Date(NaN);
}
function isSameDay$1(dateLeft, dateRight) {
  const dateLeftStartOfDay = startOfDay(dateLeft);
  const dateRightStartOfDay = startOfDay(dateRight);
  return +dateLeftStartOfDay === +dateRightStartOfDay;
}
function isDate(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function isValid$1(date2) {
  if (!isDate(date2) && typeof date2 !== "number") {
    return false;
  }
  const _date = toDate(date2);
  return !isNaN(Number(_date));
}
function differenceInCalendarMonths(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
  const monthDiff2 = _dateLeft.getMonth() - _dateRight.getMonth();
  return yearDiff * 12 + monthDiff2;
}
function getQuarter(date2) {
  const _date = toDate(date2);
  const quarter = Math.trunc(_date.getMonth() / 3) + 1;
  return quarter;
}
function differenceInCalendarQuarters(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
  const quarterDiff = getQuarter(_dateLeft) - getQuarter(_dateRight);
  return yearDiff * 4 + quarterDiff;
}
function differenceInCalendarYears(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  return _dateLeft.getFullYear() - _dateRight.getFullYear();
}
function differenceInDays(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  const sign2 = compareLocalAsc(_dateLeft, _dateRight);
  const difference = Math.abs(differenceInCalendarDays(_dateLeft, _dateRight));
  _dateLeft.setDate(_dateLeft.getDate() - sign2 * difference);
  const isLastDayNotFull = Number(
    compareLocalAsc(_dateLeft, _dateRight) === -sign2
  );
  const result = sign2 * (difference - isLastDayNotFull);
  return result === 0 ? 0 : result;
}
function compareLocalAsc(dateLeft, dateRight) {
  const diff2 = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();
  if (diff2 < 0) {
    return -1;
  } else if (diff2 > 0) {
    return 1;
  } else {
    return diff2;
  }
}
function endOfDay(date2) {
  const _date = toDate(date2);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function endOfMonth(date2) {
  const _date = toDate(date2);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function startOfQuarter(date2) {
  const _date = toDate(date2);
  const currentMonth = _date.getMonth();
  const month = currentMonth - currentMonth % 3;
  _date.setMonth(month, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function startOfMonth(date2) {
  const _date = toDate(date2);
  _date.setDate(1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function endOfYear(date2) {
  const _date = toDate(date2);
  const year = _date.getFullYear();
  _date.setFullYear(year + 1, 0, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function startOfYear(date2) {
  const cleanDate = toDate(date2);
  const _date = constructFrom(date2, 0);
  _date.setFullYear(cleanDate.getFullYear(), 0, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function endOfWeek(date2, options) {
  var _a2, _b, _c, _d, _e, _f, _g, _h;
  const defaultOptions2 = getDefaultOptions$1();
  const weekStartsOn = (_h = (_g = (_d = (_c = options == null ? void 0 : options.weekStartsOn) != null ? _c : (_b = (_a2 = options == null ? void 0 : options.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b.weekStartsOn) != null ? _d : defaultOptions2.weekStartsOn) != null ? _g : (_f = (_e = defaultOptions2.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) != null ? _h : 0;
  const _date = toDate(date2);
  const day = _date.getDay();
  const diff2 = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  _date.setDate(_date.getDate() + diff2);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
const formatDistanceLocale$1 = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
const formatDistance$1 = (token2, count2, options) => {
  let result;
  const tokenValue = formatDistanceLocale$1[token2];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count2 === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count2.toString());
  }
  if (options == null ? void 0 : options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
function buildFormatLongFn(args) {
  return (options = {}) => {
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
const dateFormats$1 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
const timeFormats$1 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$1 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$1 = {
  date: buildFormatLongFn({
    formats: dateFormats$1,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$1 = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
const formatRelative$1 = (token2, _date, _baseDate, _options) => formatRelativeLocale$1[token2];
function buildLocalizeFn(args) {
  return (value, options) => {
    const context = (options == null ? void 0 : options.context) ? String(options.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = (options == null ? void 0 : options.width) ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = (options == null ? void 0 : options.width) ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index2 = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index2];
  };
}
const eraValues$1 = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
const quarterValues$1 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
const monthValues$1 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
const dayValues$1 = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
const dayPeriodValues$1 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
const formattingDayPeriodValues$1 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
const ordinalNumber$1 = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
const localize$1 = {
  ordinalNumber: ordinalNumber$1,
  era: buildLocalizeFn({
    values: eraValues$1,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$1,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$1,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$1,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$1,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$1,
    defaultFormattingWidth: "wide"
  })
};
function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : findKey(parsePatterns, (pattern) => pattern.test(matchedString));
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey(object2, predicate) {
  for (const key in object2) {
    if (Object.prototype.hasOwnProperty.call(object2, key) && predicate(object2[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array2, predicate) {
  for (let key = 0; key < array2.length; key++) {
    if (predicate(array2[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
const matchOrdinalNumberPattern$1 = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$1 = /\d+/i;
const matchEraPatterns$1 = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
const parseEraPatterns$1 = {
  any: [/^b/i, /^(a|c)/i]
};
const matchQuarterPatterns$1 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
const parseQuarterPatterns$1 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
const parseMonthPatterns$1 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$1 = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
const parseDayPatterns$1 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns$1 = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns$1 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
const match$1 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$1,
    parsePattern: parseOrdinalNumberPattern$1,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$1,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1,
    defaultParseWidth: "any"
  })
};
const enUS = {
  code: "en-US",
  formatDistance: formatDistance$1,
  formatLong: formatLong$1,
  formatRelative: formatRelative$1,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function getDayOfYear(date2) {
  const _date = toDate(date2);
  const diff2 = differenceInCalendarDays(_date, startOfYear(_date));
  const dayOfYear = diff2 + 1;
  return dayOfYear;
}
function getISOWeek(date2) {
  const _date = toDate(date2);
  const diff2 = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff2 / millisecondsInWeek) + 1;
}
function getWeekYear(date2, options) {
  var _a2, _b, _c, _d, _e, _f, _g, _h;
  const _date = toDate(date2);
  const year = _date.getFullYear();
  const defaultOptions2 = getDefaultOptions$1();
  const firstWeekContainsDate = (_h = (_g = (_d = (_c = options == null ? void 0 : options.firstWeekContainsDate) != null ? _c : (_b = (_a2 = options == null ? void 0 : options.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b.firstWeekContainsDate) != null ? _d : defaultOptions2.firstWeekContainsDate) != null ? _g : (_f = (_e = defaultOptions2.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.firstWeekContainsDate) != null ? _h : 1;
  const firstWeekOfNextYear = constructFrom(date2, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  const firstWeekOfThisYear = constructFrom(date2, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfWeekYear(date2, options) {
  var _a2, _b, _c, _d, _e, _f, _g, _h;
  const defaultOptions2 = getDefaultOptions$1();
  const firstWeekContainsDate = (_h = (_g = (_d = (_c = options == null ? void 0 : options.firstWeekContainsDate) != null ? _c : (_b = (_a2 = options == null ? void 0 : options.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b.firstWeekContainsDate) != null ? _d : defaultOptions2.firstWeekContainsDate) != null ? _g : (_f = (_e = defaultOptions2.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.firstWeekContainsDate) != null ? _h : 1;
  const year = getWeekYear(date2, options);
  const firstWeek = constructFrom(date2, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}
function getWeek$1(date2, options) {
  const _date = toDate(date2);
  const diff2 = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
  return Math.round(diff2 / millisecondsInWeek) + 1;
}
function addLeadingZeros(number, targetLength) {
  const sign2 = number < 0 ? "-" : "";
  const output = Math.abs(number).toString().padStart(targetLength, "0");
  return sign2 + output;
}
const lightFormatters = {
  y(date2, token2) {
    const signedYear = date2.getFullYear();
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token2 === "yy" ? year % 100 : year, token2.length);
  },
  M(date2, token2) {
    const month = date2.getMonth();
    return token2 === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  d(date2, token2) {
    return addLeadingZeros(date2.getDate(), token2.length);
  },
  a(date2, token2) {
    const dayPeriodEnumValue = date2.getHours() / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  h(date2, token2) {
    return addLeadingZeros(date2.getHours() % 12 || 12, token2.length);
  },
  H(date2, token2) {
    return addLeadingZeros(date2.getHours(), token2.length);
  },
  m(date2, token2) {
    return addLeadingZeros(date2.getMinutes(), token2.length);
  },
  s(date2, token2) {
    return addLeadingZeros(date2.getSeconds(), token2.length);
  },
  S(date2, token2) {
    const numberOfDigits = token2.length;
    const milliseconds2 = date2.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds2 * Math.pow(10, numberOfDigits - 3)
    );
    return addLeadingZeros(fractionalSeconds, token2.length);
  }
};
const dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
const formatters = {
  G: function(date2, token2, localize2) {
    const era = date2.getFullYear() > 0 ? 1 : 0;
    switch (token2) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, { width: "abbreviated" });
      case "GGGGG":
        return localize2.era(era, { width: "narrow" });
      case "GGGG":
      default:
        return localize2.era(era, { width: "wide" });
    }
  },
  y: function(date2, token2, localize2) {
    if (token2 === "yo") {
      const signedYear = date2.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, { unit: "year" });
    }
    return lightFormatters.y(date2, token2);
  },
  Y: function(date2, token2, localize2, options) {
    const signedWeekYear = getWeekYear(date2, options);
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token2 === "YY") {
      const twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token2 === "Yo") {
      return localize2.ordinalNumber(weekYear, { unit: "year" });
    }
    return addLeadingZeros(weekYear, token2.length);
  },
  R: function(date2, token2) {
    const isoWeekYear = getISOWeekYear(date2);
    return addLeadingZeros(isoWeekYear, token2.length);
  },
  u: function(date2, token2) {
    const year = date2.getFullYear();
    return addLeadingZeros(year, token2.length);
  },
  Q: function(date2, token2, localize2) {
    const quarter = Math.ceil((date2.getMonth() + 1) / 3);
    switch (token2) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  q: function(date2, token2, localize2) {
    const quarter = Math.ceil((date2.getMonth() + 1) / 3);
    switch (token2) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  M: function(date2, token2, localize2) {
    const month = date2.getMonth();
    switch (token2) {
      case "M":
      case "MM":
        return lightFormatters.M(date2, token2);
      case "Mo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, { width: "wide", context: "formatting" });
    }
  },
  L: function(date2, token2, localize2) {
    const month = date2.getMonth();
    switch (token2) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, { width: "wide", context: "standalone" });
    }
  },
  w: function(date2, token2, localize2, options) {
    const week = getWeek$1(date2, options);
    if (token2 === "wo") {
      return localize2.ordinalNumber(week, { unit: "week" });
    }
    return addLeadingZeros(week, token2.length);
  },
  I: function(date2, token2, localize2) {
    const isoWeek = getISOWeek(date2);
    if (token2 === "Io") {
      return localize2.ordinalNumber(isoWeek, { unit: "week" });
    }
    return addLeadingZeros(isoWeek, token2.length);
  },
  d: function(date2, token2, localize2) {
    if (token2 === "do") {
      return localize2.ordinalNumber(date2.getDate(), { unit: "date" });
    }
    return lightFormatters.d(date2, token2);
  },
  D: function(date2, token2, localize2) {
    const dayOfYear = getDayOfYear(date2);
    if (token2 === "Do") {
      return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }
    return addLeadingZeros(dayOfYear, token2.length);
  },
  E: function(date2, token2, localize2) {
    const dayOfWeek = date2.getDay();
    switch (token2) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  e: function(date2, token2, localize2, options) {
    const dayOfWeek = date2.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  c: function(date2, token2, localize2, options) {
    const dayOfWeek = date2.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token2.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  i: function(date2, token2, localize2) {
    const dayOfWeek = date2.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token2) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token2.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  a: function(date2, token2, localize2) {
    const hours2 = date2.getHours();
    const dayPeriodEnumValue = hours2 / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  b: function(date2, token2, localize2) {
    const hours2 = date2.getHours();
    let dayPeriodEnumValue;
    if (hours2 === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours2 === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours2 / 12 >= 1 ? "pm" : "am";
    }
    switch (token2) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  B: function(date2, token2, localize2) {
    const hours2 = date2.getHours();
    let dayPeriodEnumValue;
    if (hours2 >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours2 >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours2 >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token2) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  h: function(date2, token2, localize2) {
    if (token2 === "ho") {
      let hours2 = date2.getHours() % 12;
      if (hours2 === 0)
        hours2 = 12;
      return localize2.ordinalNumber(hours2, { unit: "hour" });
    }
    return lightFormatters.h(date2, token2);
  },
  H: function(date2, token2, localize2) {
    if (token2 === "Ho") {
      return localize2.ordinalNumber(date2.getHours(), { unit: "hour" });
    }
    return lightFormatters.H(date2, token2);
  },
  K: function(date2, token2, localize2) {
    const hours2 = date2.getHours() % 12;
    if (token2 === "Ko") {
      return localize2.ordinalNumber(hours2, { unit: "hour" });
    }
    return addLeadingZeros(hours2, token2.length);
  },
  k: function(date2, token2, localize2) {
    let hours2 = date2.getHours();
    if (hours2 === 0)
      hours2 = 24;
    if (token2 === "ko") {
      return localize2.ordinalNumber(hours2, { unit: "hour" });
    }
    return addLeadingZeros(hours2, token2.length);
  },
  m: function(date2, token2, localize2) {
    if (token2 === "mo") {
      return localize2.ordinalNumber(date2.getMinutes(), { unit: "minute" });
    }
    return lightFormatters.m(date2, token2);
  },
  s: function(date2, token2, localize2) {
    if (token2 === "so") {
      return localize2.ordinalNumber(date2.getSeconds(), { unit: "second" });
    }
    return lightFormatters.s(date2, token2);
  },
  S: function(date2, token2) {
    return lightFormatters.S(date2, token2);
  },
  X: function(date2, token2, _localize) {
    const timezoneOffset = date2.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token2) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  x: function(date2, token2, _localize) {
    const timezoneOffset = date2.getTimezoneOffset();
    switch (token2) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  O: function(date2, token2, _localize) {
    const timezoneOffset = date2.getTimezoneOffset();
    switch (token2) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  z: function(date2, token2, _localize) {
    const timezoneOffset = date2.getTimezoneOffset();
    switch (token2) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  t: function(date2, token2, _localize) {
    const timestamp = Math.trunc(date2.getTime() / 1e3);
    return addLeadingZeros(timestamp, token2.length);
  },
  T: function(date2, token2, _localize) {
    const timestamp = date2.getTime();
    return addLeadingZeros(timestamp, token2.length);
  }
};
function formatTimezoneShort(offset2, delimiter = "") {
  const sign2 = offset2 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset2);
  const hours2 = Math.trunc(absOffset / 60);
  const minutes2 = absOffset % 60;
  if (minutes2 === 0) {
    return sign2 + String(hours2);
  }
  return sign2 + String(hours2) + delimiter + addLeadingZeros(minutes2, 2);
}
function formatTimezoneWithOptionalMinutes(offset2, delimiter) {
  if (offset2 % 60 === 0) {
    const sign2 = offset2 > 0 ? "-" : "+";
    return sign2 + addLeadingZeros(Math.abs(offset2) / 60, 2);
  }
  return formatTimezone(offset2, delimiter);
}
function formatTimezone(offset2, delimiter = "") {
  const sign2 = offset2 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset2);
  const hours2 = addLeadingZeros(Math.trunc(absOffset / 60), 2);
  const minutes2 = addLeadingZeros(absOffset % 60, 2);
  return sign2 + hours2 + delimiter + minutes2;
}
const dateLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "P":
      return formatLong2.date({ width: "short" });
    case "PP":
      return formatLong2.date({ width: "medium" });
    case "PPP":
      return formatLong2.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong2.date({ width: "full" });
  }
};
const timeLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "p":
      return formatLong2.time({ width: "short" });
    case "pp":
      return formatLong2.time({ width: "medium" });
    case "ppp":
      return formatLong2.time({ width: "long" });
    case "pppp":
    default:
      return formatLong2.time({ width: "full" });
  }
};
const dateTimeLongFormatter = (pattern, formatLong2) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  let dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({ width: "full" });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
const longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
const dayOfYearTokenRE = /^D+$/;
const weekYearTokenRE = /^Y+$/;
const throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(token2) {
  return dayOfYearTokenRE.test(token2);
}
function isProtectedWeekYearToken(token2) {
  return weekYearTokenRE.test(token2);
}
function warnOrThrowProtectedError(token2, format2, input) {
  const _message = message(token2, format2, input);
  console.warn(_message);
  if (throwTokens.includes(token2))
    throw new RangeError(_message);
}
function message(token2, format2, input) {
  const subject = token2[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token2.toLowerCase()}\` instead of \`${token2}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
const longFormattingTokensRegExp$2 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
const escapedStringRegExp$1 = /^'([^]*?)'?$/;
const doubleQuoteRegExp$1 = /''/g;
const unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
function format(date2, formatStr, options) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
  const defaultOptions2 = getDefaultOptions$1();
  const locale2 = (_b = (_a2 = options == null ? void 0 : options.locale) != null ? _a2 : defaultOptions2.locale) != null ? _b : enUS;
  const firstWeekContainsDate = (_j = (_i = (_f = (_e = options == null ? void 0 : options.firstWeekContainsDate) != null ? _e : (_d = (_c = options == null ? void 0 : options.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) != null ? _f : defaultOptions2.firstWeekContainsDate) != null ? _i : (_h = (_g = defaultOptions2.locale) == null ? void 0 : _g.options) == null ? void 0 : _h.firstWeekContainsDate) != null ? _j : 1;
  const weekStartsOn = (_r = (_q = (_n = (_m = options == null ? void 0 : options.weekStartsOn) != null ? _m : (_l = (_k = options == null ? void 0 : options.locale) == null ? void 0 : _k.options) == null ? void 0 : _l.weekStartsOn) != null ? _n : defaultOptions2.weekStartsOn) != null ? _q : (_p = (_o = defaultOptions2.locale) == null ? void 0 : _o.options) == null ? void 0 : _p.weekStartsOn) != null ? _r : 0;
  const originalDate = toDate(date2);
  if (!isValid$1(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  let parts = formatStr.match(longFormattingTokensRegExp$2).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp$1).map((substring) => {
    if (substring === "''") {
      return { isToken: false, value: "'" };
    }
    const firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return { isToken: false, value: cleanEscapedString$1(substring) };
    }
    if (formatters[firstCharacter]) {
      return { isToken: true, value: substring };
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
      );
    }
    return { isToken: false, value: substring };
  });
  if (locale2.localize.preprocessor) {
    parts = locale2.localize.preprocessor(originalDate, parts);
  }
  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2
  };
  return parts.map((part) => {
    if (!part.isToken)
      return part.value;
    const token2 = part.value;
    if (!(options == null ? void 0 : options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token2) || !(options == null ? void 0 : options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token2)) {
      warnOrThrowProtectedError(token2, formatStr, String(date2));
    }
    const formatter = formatters[token2[0]];
    return formatter(originalDate, token2, locale2.localize, formatterOptions);
  }).join("");
}
function cleanEscapedString$1(input) {
  const matched = input.match(escapedStringRegExp$1);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp$1, "'");
}
function getDate(date2) {
  const _date = toDate(date2);
  const dayOfMonth = _date.getDate();
  return dayOfMonth;
}
function getDay(date2) {
  const _date = toDate(date2);
  const day = _date.getDay();
  return day;
}
function getDaysInMonth(date2) {
  const _date = toDate(date2);
  const year = _date.getFullYear();
  const monthIndex = _date.getMonth();
  const lastDayOfMonth = constructFrom(date2, 0);
  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}
function getDefaultOptions() {
  return Object.assign({}, getDefaultOptions$1());
}
function getHours(date2) {
  const _date = toDate(date2);
  const hours2 = _date.getHours();
  return hours2;
}
function getISODay(date2) {
  const _date = toDate(date2);
  let day = _date.getDay();
  if (day === 0) {
    day = 7;
  }
  return day;
}
function getMinutes(date2) {
  const _date = toDate(date2);
  const minutes2 = _date.getMinutes();
  return minutes2;
}
function getMonth(date2) {
  const _date = toDate(date2);
  const month = _date.getMonth();
  return month;
}
function getSeconds(date2) {
  const _date = toDate(date2);
  const seconds2 = _date.getSeconds();
  return seconds2;
}
function getTime(date2) {
  const _date = toDate(date2);
  const timestamp = _date.getTime();
  return timestamp;
}
function getYear(date2) {
  return toDate(date2).getFullYear();
}
function isAfter(date2, dateToCompare) {
  const _date = toDate(date2);
  const _dateToCompare = toDate(dateToCompare);
  return _date.getTime() > _dateToCompare.getTime();
}
function isBefore(date2, dateToCompare) {
  const _date = toDate(date2);
  const _dateToCompare = toDate(dateToCompare);
  return +_date < +_dateToCompare;
}
function isEqual$1(leftDate, rightDate) {
  const _dateLeft = toDate(leftDate);
  const _dateRight = toDate(rightDate);
  return +_dateLeft === +_dateRight;
}
function transpose(fromDate, constructor) {
  const date2 = constructor instanceof Date ? constructFrom(constructor, 0) : new constructor(0);
  date2.setFullYear(
    fromDate.getFullYear(),
    fromDate.getMonth(),
    fromDate.getDate()
  );
  date2.setHours(
    fromDate.getHours(),
    fromDate.getMinutes(),
    fromDate.getSeconds(),
    fromDate.getMilliseconds()
  );
  return date2;
}
const TIMEZONE_UNIT_PRIORITY = 10;
class Setter {
  constructor() {
    __publicField(this, "subPriority", 0);
  }
  validate(_utcDate, _options) {
    return true;
  }
}
class ValueSetter extends Setter {
  constructor(value, validateValue, setValue, priority, subPriority) {
    super();
    this.value = value;
    this.validateValue = validateValue;
    this.setValue = setValue;
    this.priority = priority;
    if (subPriority) {
      this.subPriority = subPriority;
    }
  }
  validate(date2, options) {
    return this.validateValue(date2, this.value, options);
  }
  set(date2, flags, options) {
    return this.setValue(date2, flags, this.value, options);
  }
}
class DateToSystemTimezoneSetter extends Setter {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", TIMEZONE_UNIT_PRIORITY);
    __publicField(this, "subPriority", -1);
  }
  set(date2, flags) {
    if (flags.timestampIsSet)
      return date2;
    return constructFrom(date2, transpose(date2, Date));
  }
}
class Parser {
  run(dateString, token2, match5, options) {
    const result = this.parse(dateString, token2, match5, options);
    if (!result) {
      return null;
    }
    return {
      setter: new ValueSetter(
        result.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: result.rest
    };
  }
  validate(_utcDate, _value, _options) {
    return true;
  }
}
class EraParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 140);
    __publicField(this, "incompatibleTokens", ["R", "u", "t", "T"]);
  }
  parse(dateString, token2, match5) {
    switch (token2) {
      case "G":
      case "GG":
      case "GGG":
        return match5.era(dateString, { width: "abbreviated" }) || match5.era(dateString, { width: "narrow" });
      case "GGGGG":
        return match5.era(dateString, { width: "narrow" });
      case "GGGG":
      default:
        return match5.era(dateString, { width: "wide" }) || match5.era(dateString, { width: "abbreviated" }) || match5.era(dateString, { width: "narrow" });
    }
  }
  set(date2, flags, value) {
    flags.era = value;
    date2.setFullYear(value, 0, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
const numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  date: /^(3[0-1]|[0-2]?\d)/,
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  week: /^(5[0-3]|[0-4]?\d)/,
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  hour11h: /^(1[0-1]|0?\d)/,
  hour12h: /^(1[0-2]|0?\d)/,
  minute: /^[0-5]?\d/,
  second: /^[0-5]?\d/,
  singleDigit: /^\d/,
  twoDigits: /^\d{1,2}/,
  threeDigits: /^\d{1,3}/,
  fourDigits: /^\d{1,4}/,
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  twoDigitsSigned: /^-?\d{1,2}/,
  threeDigitsSigned: /^-?\d{1,3}/,
  fourDigitsSigned: /^-?\d{1,4}/
};
const timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  const sign2 = matchResult[1] === "+" ? 1 : -1;
  const hours2 = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  const minutes2 = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  const seconds2 = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign2 * (hours2 * millisecondsInHour + minutes2 * millisecondsInMinute + seconds2 * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n2, dateString) {
  switch (n2) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n2 + "}"), dateString);
  }
}
function parseNDigitsSigned(n2, dateString) {
  switch (n2) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n2 + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  const isCommonEra = currentYear > 0;
  const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  let result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    const rangeEnd = absCurrentYear + 50;
    const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
    const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex$1(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
class YearParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token2, match5) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token2 === "yy"
    });
    switch (token2) {
      case "y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "yo":
        return mapValue(
          match5.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token2.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date2, flags, value) {
    const currentYear = date2.getFullYear();
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date2.setFullYear(normalizedTwoDigitYear, 0, 1);
      date2.setHours(0, 0, 0, 0);
      return date2;
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date2.setFullYear(year, 0, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
class LocalWeekYearParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(dateString, token2, match5) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token2 === "YY"
    });
    switch (token2) {
      case "Y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "Yo":
        return mapValue(
          match5.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token2.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date2, flags, value, options) {
    const currentYear = getWeekYear(date2, options);
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date2.setFullYear(
        normalizedTwoDigitYear,
        0,
        options.firstWeekContainsDate
      );
      date2.setHours(0, 0, 0, 0);
      return startOfWeek(date2, options);
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date2.setFullYear(year, 0, options.firstWeekContainsDate);
    date2.setHours(0, 0, 0, 0);
    return startOfWeek(date2, options);
  }
}
class ISOWeekYearParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", [
      "G",
      "y",
      "Y",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token2) {
    if (token2 === "R") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token2.length, dateString);
  }
  set(date2, _flags, value) {
    const firstWeekOfYear = constructFrom(date2, 0);
    firstWeekOfYear.setFullYear(value, 0, 4);
    firstWeekOfYear.setHours(0, 0, 0, 0);
    return startOfISOWeek(firstWeekOfYear);
  }
}
class ExtendedYearParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token2) {
    if (token2 === "u") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token2.length, dateString);
  }
  set(date2, _flags, value) {
    date2.setFullYear(value, 0, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
class QuarterParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 120);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token2, match5) {
    switch (token2) {
      case "Q":
      case "QQ":
        return parseNDigits(token2.length, dateString);
      case "Qo":
        return match5.ordinalNumber(dateString, { unit: "quarter" });
      case "QQQ":
        return match5.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match5.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQQ":
        return match5.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return match5.quarter(dateString, {
          width: "wide",
          context: "formatting"
        }) || match5.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match5.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date2, _flags, value) {
    date2.setMonth((value - 1) * 3, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
class StandAloneQuarterParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 120);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token2, match5) {
    switch (token2) {
      case "q":
      case "qq":
        return parseNDigits(token2.length, dateString);
      case "qo":
        return match5.ordinalNumber(dateString, { unit: "quarter" });
      case "qqq":
        return match5.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match5.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqqq":
        return match5.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return match5.quarter(dateString, {
          width: "wide",
          context: "standalone"
        }) || match5.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match5.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date2, _flags, value) {
    date2.setMonth((value - 1) * 3, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
class MonthParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "L",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
    __publicField(this, "priority", 110);
  }
  parse(dateString, token2, match5) {
    const valueCallback = (value) => value - 1;
    switch (token2) {
      case "M":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      case "MM":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      case "Mo":
        return mapValue(
          match5.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      case "MMM":
        return match5.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match5.month(dateString, { width: "narrow", context: "formatting" });
      case "MMMMM":
        return match5.month(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return match5.month(dateString, { width: "wide", context: "formatting" }) || match5.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match5.month(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date2, _flags, value) {
    date2.setMonth(value, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
class StandAloneMonthParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 110);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token2, match5) {
    const valueCallback = (value) => value - 1;
    switch (token2) {
      case "L":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      case "LL":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      case "Lo":
        return mapValue(
          match5.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      case "LLL":
        return match5.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match5.month(dateString, { width: "narrow", context: "standalone" });
      case "LLLLL":
        return match5.month(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return match5.month(dateString, { width: "wide", context: "standalone" }) || match5.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match5.month(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date2, _flags, value) {
    date2.setMonth(value, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
function setWeek(date2, week, options) {
  const _date = toDate(date2);
  const diff2 = getWeek$1(_date, options) - week;
  _date.setDate(_date.getDate() - diff2 * 7);
  return _date;
}
class LocalWeekParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 100);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(dateString, token2, match5) {
    switch (token2) {
      case "w":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "wo":
        return match5.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token2.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date2, _flags, value, options) {
    return startOfWeek(setWeek(date2, value, options), options);
  }
}
function setISOWeek(date2, week) {
  const _date = toDate(date2);
  const diff2 = getISOWeek(_date) - week;
  _date.setDate(_date.getDate() - diff2 * 7);
  return _date;
}
class ISOWeekParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 100);
    __publicField(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token2, match5) {
    switch (token2) {
      case "I":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "Io":
        return match5.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token2.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date2, _flags, value) {
    return startOfISOWeek(setISOWeek(date2, value));
  }
}
const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const DAYS_IN_MONTH_LEAP_YEAR = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
class DateParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "subPriority", 1);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token2, match5) {
    switch (token2) {
      case "d":
        return parseNumericPattern(numericPatterns.date, dateString);
      case "do":
        return match5.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token2.length, dateString);
    }
  }
  validate(date2, value) {
    const year = date2.getFullYear();
    const isLeapYear2 = isLeapYearIndex$1(year);
    const month = date2.getMonth();
    if (isLeapYear2) {
      return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
    } else {
      return value >= 1 && value <= DAYS_IN_MONTH[month];
    }
  }
  set(date2, _flags, value) {
    date2.setDate(value);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
class DayOfYearParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "subpriority", 1);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "E",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token2, match5) {
    switch (token2) {
      case "D":
      case "DD":
        return parseNumericPattern(numericPatterns.dayOfYear, dateString);
      case "Do":
        return match5.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token2.length, dateString);
    }
  }
  validate(date2, value) {
    const year = date2.getFullYear();
    const isLeapYear2 = isLeapYearIndex$1(year);
    if (isLeapYear2) {
      return value >= 1 && value <= 366;
    } else {
      return value >= 1 && value <= 365;
    }
  }
  set(date2, _flags, value) {
    date2.setMonth(0, value);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
function setDay(date2, day, options) {
  var _a2, _b, _c, _d, _e, _f, _g, _h;
  const defaultOptions2 = getDefaultOptions$1();
  const weekStartsOn = (_h = (_g = (_d = (_c = options == null ? void 0 : options.weekStartsOn) != null ? _c : (_b = (_a2 = options == null ? void 0 : options.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b.weekStartsOn) != null ? _d : defaultOptions2.weekStartsOn) != null ? _g : (_f = (_e = defaultOptions2.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) != null ? _h : 0;
  const _date = toDate(date2);
  const currentDay = _date.getDay();
  const remainder = day % 7;
  const dayIndex = (remainder + 7) % 7;
  const delta = 7 - weekStartsOn;
  const diff2 = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
  return addDays(_date, diff2);
}
class DayParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token2, match5) {
    switch (token2) {
      case "E":
      case "EE":
      case "EEE":
        return match5.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match5.day(dateString, { width: "short", context: "formatting" }) || match5.day(dateString, { width: "narrow", context: "formatting" });
      case "EEEEE":
        return match5.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return match5.day(dateString, { width: "short", context: "formatting" }) || match5.day(dateString, { width: "narrow", context: "formatting" });
      case "EEEE":
      default:
        return match5.day(dateString, { width: "wide", context: "formatting" }) || match5.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match5.day(dateString, { width: "short", context: "formatting" }) || match5.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date2, _flags, value, options) {
    date2 = setDay(date2, value, options);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
class LocalDayParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token2, match5, options) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token2) {
      case "e":
      case "ee":
        return mapValue(parseNDigits(token2.length, dateString), valueCallback);
      case "eo":
        return mapValue(
          match5.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      case "eee":
        return match5.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match5.day(dateString, { width: "short", context: "formatting" }) || match5.day(dateString, { width: "narrow", context: "formatting" });
      case "eeeee":
        return match5.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return match5.day(dateString, { width: "short", context: "formatting" }) || match5.day(dateString, { width: "narrow", context: "formatting" });
      case "eeee":
      default:
        return match5.day(dateString, { width: "wide", context: "formatting" }) || match5.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match5.day(dateString, { width: "short", context: "formatting" }) || match5.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date2, _flags, value, options) {
    date2 = setDay(date2, value, options);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
class StandAloneLocalDayParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "e",
      "t",
      "T"
    ]);
  }
  parse(dateString, token2, match5, options) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token2) {
      case "c":
      case "cc":
        return mapValue(parseNDigits(token2.length, dateString), valueCallback);
      case "co":
        return mapValue(
          match5.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      case "ccc":
        return match5.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match5.day(dateString, { width: "short", context: "standalone" }) || match5.day(dateString, { width: "narrow", context: "standalone" });
      case "ccccc":
        return match5.day(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return match5.day(dateString, { width: "short", context: "standalone" }) || match5.day(dateString, { width: "narrow", context: "standalone" });
      case "cccc":
      default:
        return match5.day(dateString, { width: "wide", context: "standalone" }) || match5.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match5.day(dateString, { width: "short", context: "standalone" }) || match5.day(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date2, _flags, value, options) {
    date2 = setDay(date2, value, options);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
function setISODay(date2, day) {
  const _date = toDate(date2);
  const currentDay = getISODay(_date);
  const diff2 = day - currentDay;
  return addDays(_date, diff2);
}
class ISODayParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "E",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token2, match5) {
    const valueCallback = (value) => {
      if (value === 0) {
        return 7;
      }
      return value;
    };
    switch (token2) {
      case "i":
      case "ii":
        return parseNDigits(token2.length, dateString);
      case "io":
        return match5.ordinalNumber(dateString, { unit: "day" });
      case "iii":
        return mapValue(
          match5.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      case "iiiii":
        return mapValue(
          match5.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      case "iiiiii":
        return mapValue(
          match5.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      case "iiii":
      default:
        return mapValue(
          match5.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 7;
  }
  set(date2, _flags, value) {
    date2 = setISODay(date2, value);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
}
class AMPMParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
  }
  parse(dateString, token2, match5) {
    switch (token2) {
      case "a":
      case "aa":
      case "aaa":
        return match5.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match5.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return match5.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return match5.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match5.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match5.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date2, _flags, value) {
    date2.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date2;
  }
}
class AMPMMidnightParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
  }
  parse(dateString, token2, match5) {
    switch (token2) {
      case "b":
      case "bb":
      case "bbb":
        return match5.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match5.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return match5.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return match5.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match5.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match5.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date2, _flags, value) {
    date2.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date2;
  }
}
class DayPeriodParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["a", "b", "t", "T"]);
  }
  parse(dateString, token2, match5) {
    switch (token2) {
      case "B":
      case "BB":
      case "BBB":
        return match5.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match5.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return match5.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return match5.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match5.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match5.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date2, _flags, value) {
    date2.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date2;
  }
}
class Hour1to12Parser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
  }
  parse(dateString, token2, match5) {
    switch (token2) {
      case "h":
        return parseNumericPattern(numericPatterns.hour12h, dateString);
      case "ho":
        return match5.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token2.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 12;
  }
  set(date2, _flags, value) {
    const isPM = date2.getHours() >= 12;
    if (isPM && value < 12) {
      date2.setHours(value + 12, 0, 0, 0);
    } else if (!isPM && value === 12) {
      date2.setHours(0, 0, 0, 0);
    } else {
      date2.setHours(value, 0, 0, 0);
    }
    return date2;
  }
}
class Hour0to23Parser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
  }
  parse(dateString, token2, match5) {
    switch (token2) {
      case "H":
        return parseNumericPattern(numericPatterns.hour23h, dateString);
      case "Ho":
        return match5.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token2.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 23;
  }
  set(date2, _flags, value) {
    date2.setHours(value, 0, 0, 0);
    return date2;
  }
}
class Hour0To11Parser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
  }
  parse(dateString, token2, match5) {
    switch (token2) {
      case "K":
        return parseNumericPattern(numericPatterns.hour11h, dateString);
      case "Ko":
        return match5.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token2.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date2, _flags, value) {
    const isPM = date2.getHours() >= 12;
    if (isPM && value < 12) {
      date2.setHours(value + 12, 0, 0, 0);
    } else {
      date2.setHours(value, 0, 0, 0);
    }
    return date2;
  }
}
class Hour1To24Parser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
  }
  parse(dateString, token2, match5) {
    switch (token2) {
      case "k":
        return parseNumericPattern(numericPatterns.hour24h, dateString);
      case "ko":
        return match5.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token2.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 24;
  }
  set(date2, _flags, value) {
    const hours2 = value <= 24 ? value % 24 : value;
    date2.setHours(hours2, 0, 0, 0);
    return date2;
  }
}
class MinuteParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 60);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token2, match5) {
    switch (token2) {
      case "m":
        return parseNumericPattern(numericPatterns.minute, dateString);
      case "mo":
        return match5.ordinalNumber(dateString, { unit: "minute" });
      default:
        return parseNDigits(token2.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date2, _flags, value) {
    date2.setMinutes(value, 0, 0);
    return date2;
  }
}
class SecondParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 50);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token2, match5) {
    switch (token2) {
      case "s":
        return parseNumericPattern(numericPatterns.second, dateString);
      case "so":
        return match5.ordinalNumber(dateString, { unit: "second" });
      default:
        return parseNDigits(token2.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date2, _flags, value) {
    date2.setSeconds(value, 0);
    return date2;
  }
}
class FractionOfSecondParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 30);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token2) {
    const valueCallback = (value) => Math.trunc(value * Math.pow(10, -token2.length + 3));
    return mapValue(parseNDigits(token2.length, dateString), valueCallback);
  }
  set(date2, _flags, value) {
    date2.setMilliseconds(value);
    return date2;
  }
}
class ISOTimezoneWithZParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 10);
    __publicField(this, "incompatibleTokens", ["t", "T", "x"]);
  }
  parse(dateString, token2) {
    switch (token2) {
      case "X":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "XX":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "XXXX":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "XXXXX":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "XXX":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date2, flags, value) {
    if (flags.timestampIsSet)
      return date2;
    return constructFrom(
      date2,
      date2.getTime() - getTimezoneOffsetInMilliseconds(date2) - value
    );
  }
}
class ISOTimezoneParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 10);
    __publicField(this, "incompatibleTokens", ["t", "T", "X"]);
  }
  parse(dateString, token2) {
    switch (token2) {
      case "x":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "xx":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "xxxx":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "xxxxx":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "xxx":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date2, flags, value) {
    if (flags.timestampIsSet)
      return date2;
    return constructFrom(
      date2,
      date2.getTime() - getTimezoneOffsetInMilliseconds(date2) - value
    );
  }
}
class TimestampSecondsParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 40);
    __publicField(this, "incompatibleTokens", "*");
  }
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date2, _flags, value) {
    return [constructFrom(date2, value * 1e3), { timestampIsSet: true }];
  }
}
class TimestampMillisecondsParser extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 20);
    __publicField(this, "incompatibleTokens", "*");
  }
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date2, _flags, value) {
    return [constructFrom(date2, value), { timestampIsSet: true }];
  }
}
const parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};
const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
const longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;
const notWhitespaceRegExp = /\S/;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse(dateStr, formatStr, referenceDate, options) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
  const defaultOptions2 = getDefaultOptions();
  const locale2 = (_b = (_a2 = options == null ? void 0 : options.locale) != null ? _a2 : defaultOptions2.locale) != null ? _b : enUS;
  const firstWeekContainsDate = (_j = (_i = (_f = (_e = options == null ? void 0 : options.firstWeekContainsDate) != null ? _e : (_d = (_c = options == null ? void 0 : options.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) != null ? _f : defaultOptions2.firstWeekContainsDate) != null ? _i : (_h = (_g = defaultOptions2.locale) == null ? void 0 : _g.options) == null ? void 0 : _h.firstWeekContainsDate) != null ? _j : 1;
  const weekStartsOn = (_r = (_q = (_n = (_m = options == null ? void 0 : options.weekStartsOn) != null ? _m : (_l = (_k = options == null ? void 0 : options.locale) == null ? void 0 : _k.options) == null ? void 0 : _l.weekStartsOn) != null ? _n : defaultOptions2.weekStartsOn) != null ? _q : (_p = (_o = defaultOptions2.locale) == null ? void 0 : _o.options) == null ? void 0 : _p.weekStartsOn) != null ? _r : 0;
  if (formatStr === "") {
    if (dateStr === "") {
      return toDate(referenceDate);
    } else {
      return constructFrom(referenceDate, NaN);
    }
  }
  const subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2
  };
  const setters = [new DateToSystemTimezoneSetter()];
  const tokens2 = formatStr.match(longFormattingTokensRegExp$1).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter in longFormatters) {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp);
  const usedTokens = [];
  for (let token2 of tokens2) {
    if (!(options == null ? void 0 : options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token2)) {
      warnOrThrowProtectedError(token2, formatStr, dateStr);
    }
    if (!(options == null ? void 0 : options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token2)) {
      warnOrThrowProtectedError(token2, formatStr, dateStr);
    }
    const firstCharacter = token2[0];
    const parser = parsers[firstCharacter];
    if (parser) {
      const { incompatibleTokens } = parser;
      if (Array.isArray(incompatibleTokens)) {
        const incompatibleToken = usedTokens.find(
          (usedToken) => incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter
        );
        if (incompatibleToken) {
          throw new RangeError(
            `The format string mustn't contain \`${incompatibleToken.fullToken}\` and \`${token2}\` at the same time`
          );
        }
      } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
        throw new RangeError(
          `The format string mustn't contain \`${token2}\` and any other token at the same time`
        );
      }
      usedTokens.push({ token: firstCharacter, fullToken: token2 });
      const parseResult = parser.run(
        dateStr,
        token2,
        locale2.match,
        subFnOptions
      );
      if (!parseResult) {
        return constructFrom(referenceDate, NaN);
      }
      setters.push(parseResult.setter);
      dateStr = parseResult.rest;
    } else {
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
        );
      }
      if (token2 === "''") {
        token2 = "'";
      } else if (firstCharacter === "'") {
        token2 = cleanEscapedString(token2);
      }
      if (dateStr.indexOf(token2) === 0) {
        dateStr = dateStr.slice(token2.length);
      } else {
        return constructFrom(referenceDate, NaN);
      }
    }
  }
  if (dateStr.length > 0 && notWhitespaceRegExp.test(dateStr)) {
    return constructFrom(referenceDate, NaN);
  }
  const uniquePrioritySetters = setters.map((setter) => setter.priority).sort((a, b) => b - a).filter((priority, index2, array2) => array2.indexOf(priority) === index2).map(
    (priority) => setters.filter((setter) => setter.priority === priority).sort((a, b) => b.subPriority - a.subPriority)
  ).map((setterArray) => setterArray[0]);
  let date2 = toDate(referenceDate);
  if (isNaN(date2.getTime())) {
    return constructFrom(referenceDate, NaN);
  }
  const flags = {};
  for (const setter of uniquePrioritySetters) {
    if (!setter.validate(date2, subFnOptions)) {
      return constructFrom(referenceDate, NaN);
    }
    const result = setter.set(date2, flags, subFnOptions);
    if (Array.isArray(result)) {
      date2 = result[0];
      Object.assign(flags, result[1]);
    } else {
      date2 = result;
    }
  }
  return constructFrom(referenceDate, date2);
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
function isSameWeek(dateLeft, dateRight, options) {
  const dateLeftStartOfWeek = startOfWeek(dateLeft, options);
  const dateRightStartOfWeek = startOfWeek(dateRight, options);
  return +dateLeftStartOfWeek === +dateRightStartOfWeek;
}
function isSameMonth$1(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  return _dateLeft.getFullYear() === _dateRight.getFullYear() && _dateLeft.getMonth() === _dateRight.getMonth();
}
function isSameQuarter$1(dateLeft, dateRight) {
  const dateLeftStartOfQuarter = startOfQuarter(dateLeft);
  const dateRightStartOfQuarter = startOfQuarter(dateRight);
  return +dateLeftStartOfQuarter === +dateRightStartOfQuarter;
}
function isSameYear$1(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  return _dateLeft.getFullYear() === _dateRight.getFullYear();
}
function isWithinInterval(date2, interval) {
  const time = +toDate(date2);
  const [startTime, endTime] = [
    +toDate(interval.start),
    +toDate(interval.end)
  ].sort((a, b) => a - b);
  return time >= startTime && time <= endTime;
}
function subDays(date2, amount) {
  return addDays(date2, -amount);
}
function parseISO(argument, options) {
  var _a2;
  const additionalDigits = (_a2 = options == null ? void 0 : options.additionalDigits) != null ? _a2 : 2;
  const dateStrings = splitDateString(argument);
  let date2;
  if (dateStrings.date) {
    const parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date2 = parseDate$1(parseYearResult.restDateString, parseYearResult.year);
  }
  if (!date2 || isNaN(date2.getTime())) {
    return new Date(NaN);
  }
  const timestamp = date2.getTime();
  let time = 0;
  let offset2;
  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) {
      return new Date(NaN);
    }
  }
  if (dateStrings.timezone) {
    offset2 = parseTimezone(dateStrings.timezone);
    if (isNaN(offset2)) {
      return new Date(NaN);
    }
  } else {
    const dirtyDate = new Date(timestamp + time);
    const result = new Date(0);
    result.setFullYear(
      dirtyDate.getUTCFullYear(),
      dirtyDate.getUTCMonth(),
      dirtyDate.getUTCDate()
    );
    result.setHours(
      dirtyDate.getUTCHours(),
      dirtyDate.getUTCMinutes(),
      dirtyDate.getUTCSeconds(),
      dirtyDate.getUTCMilliseconds()
    );
    return result;
  }
  return new Date(timestamp + time + offset2);
}
const patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
const dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
const timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
const timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(dateString) {
  const dateStrings = {};
  const array2 = dateString.split(patterns.dateTimeDelimiter);
  let timeString;
  if (array2.length > 2) {
    return dateStrings;
  }
  if (/:/.test(array2[0])) {
    timeString = array2[0];
  } else {
    dateStrings.date = array2[0];
    timeString = array2[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(
        dateStrings.date.length,
        dateString.length
      );
    }
  }
  if (timeString) {
    const token2 = patterns.timezone.exec(timeString);
    if (token2) {
      dateStrings.time = timeString.replace(token2[1], "");
      dateStrings.timezone = token2[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  const regex = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)"
  );
  const captures = dateString.match(regex);
  if (!captures)
    return { year: NaN, restDateString: "" };
  const year = captures[1] ? parseInt(captures[1]) : null;
  const century = captures[2] ? parseInt(captures[2]) : null;
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}
function parseDate$1(dateString, year) {
  if (year === null)
    return new Date(NaN);
  const captures = dateString.match(dateRegex);
  if (!captures)
    return new Date(NaN);
  const isWeekDate = !!captures[4];
  const dayOfYear = parseDateUnit(captures[1]);
  const month = parseDateUnit(captures[2]) - 1;
  const day = parseDateUnit(captures[3]);
  const week = parseDateUnit(captures[4]);
  const dayOfWeek = parseDateUnit(captures[5]) - 1;
  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    const date2 = new Date(0);
    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return new Date(NaN);
    }
    date2.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date2;
  }
}
function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
  const captures = timeString.match(timeRegex);
  if (!captures)
    return NaN;
  const hours2 = parseTimeUnit(captures[1]);
  const minutes2 = parseTimeUnit(captures[2]);
  const seconds2 = parseTimeUnit(captures[3]);
  if (!validateTime(hours2, minutes2, seconds2)) {
    return NaN;
  }
  return hours2 * millisecondsInHour + minutes2 * millisecondsInMinute + seconds2 * 1e3;
}
function parseTimeUnit(value) {
  return value && parseFloat(value.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
  if (timezoneString === "Z")
    return 0;
  const captures = timezoneString.match(timezoneRegex);
  if (!captures)
    return 0;
  const sign2 = captures[1] === "+" ? -1 : 1;
  const hours2 = parseInt(captures[2]);
  const minutes2 = captures[3] && parseInt(captures[3]) || 0;
  if (!validateTimezone(hours2, minutes2)) {
    return NaN;
  }
  return sign2 * (hours2 * millisecondsInHour + minutes2 * millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  const date2 = new Date(0);
  date2.setUTCFullYear(isoWeekYear, 0, 4);
  const fourthOfJanuaryDay = date2.getUTCDay() || 7;
  const diff2 = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date2.setUTCDate(date2.getUTCDate() + diff2);
  return date2;
}
const daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date2) {
  return month >= 0 && month <= 11 && date2 >= 1 && date2 <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}
function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours2, minutes2, seconds2) {
  if (hours2 === 24) {
    return minutes2 === 0 && seconds2 === 0;
  }
  return seconds2 >= 0 && seconds2 < 60 && minutes2 >= 0 && minutes2 < 60 && hours2 >= 0 && hours2 < 25;
}
function validateTimezone(_hours, minutes2) {
  return minutes2 >= 0 && minutes2 <= 59;
}
function setMonth(date2, month) {
  const _date = toDate(date2);
  const year = _date.getFullYear();
  const day = _date.getDate();
  const dateWithDesiredMonth = constructFrom(date2, 0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  const daysInMonth2 = getDaysInMonth(dateWithDesiredMonth);
  _date.setMonth(month, Math.min(day, daysInMonth2));
  return _date;
}
function set4(date2, values) {
  let _date = toDate(date2);
  if (isNaN(+_date)) {
    return constructFrom(date2, NaN);
  }
  if (values.year != null) {
    _date.setFullYear(values.year);
  }
  if (values.month != null) {
    _date = setMonth(_date, values.month);
  }
  if (values.date != null) {
    _date.setDate(values.date);
  }
  if (values.hours != null) {
    _date.setHours(values.hours);
  }
  if (values.minutes != null) {
    _date.setMinutes(values.minutes);
  }
  if (values.seconds != null) {
    _date.setSeconds(values.seconds);
  }
  if (values.milliseconds != null) {
    _date.setMilliseconds(values.milliseconds);
  }
  return _date;
}
function setHours(date2, hours2) {
  const _date = toDate(date2);
  _date.setHours(hours2);
  return _date;
}
function setMinutes(date2, minutes2) {
  const _date = toDate(date2);
  _date.setMinutes(minutes2);
  return _date;
}
function setQuarter(date2, quarter) {
  const _date = toDate(date2);
  const oldQuarter = Math.trunc(_date.getMonth() / 3) + 1;
  const diff2 = quarter - oldQuarter;
  return setMonth(_date, _date.getMonth() + diff2 * 3);
}
function setSeconds(date2, seconds2) {
  const _date = toDate(date2);
  _date.setSeconds(seconds2);
  return _date;
}
function setYear(date2, year) {
  const _date = toDate(date2);
  if (isNaN(+_date)) {
    return constructFrom(date2, NaN);
  }
  _date.setFullYear(year);
  return _date;
}
function subMonths(date2, amount) {
  return addMonths(date2, -amount);
}
function subQuarters(date2, amount) {
  return addQuarters(date2, -amount);
}
function subWeeks(date2, amount) {
  return addWeeks(date2, -amount);
}
function subYears(date2, amount) {
  return addYears(date2, -amount);
}
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
const sides = ["top", "right", "bottom", "left"];
const alignments = ["start", "end"];
const placements = /* @__PURE__ */ sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v) => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$12 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$12, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$12 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$12 ? center - min$12 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
const autoPlacement = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform: platform2,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = placements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const placements$1 = alignment !== void 0 || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map((d) => {
        const alignment2 = getAlignment(d.placement);
        return [d.placement, alignment2 && crossAxis ? d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) : d.overflows[0], d.overflows];
      }).sort((a, b) => a[1] - b[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d) => d[2].slice(
        0,
        getAlignment(d[0]) ? 2 : 3
      ).every((v) => v <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
function getBoundingRect(rects) {
  const minX = min(...rects.map((rect) => rect.left));
  const minY = min(...rects.map((rect) => rect.top));
  const maxX = max(...rects.map((rect) => rect.right));
  const maxY = max(...rects.map((rect) => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);
  const groups = [];
  let prevRect = null;
  for (let i = 0; i < sortedRects.length; i++) {
    const rect = sortedRects[i];
    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
      groups.push([rect]);
    } else {
      groups[groups.length - 1].push(rect);
    }
    prevRect = rect;
  }
  return groups.map((rect) => rectToClientRect(getBoundingRect(rect)));
}
const inline = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "inline",
    options,
    async fn(state) {
      const {
        placement,
        elements,
        rects,
        platform: platform2,
        strategy
      } = state;
      const {
        padding = 2,
        x,
        y
      } = evaluate(options, state);
      const nativeClientRects = Array.from(await (platform2.getClientRects == null ? void 0 : platform2.getClientRects(elements.reference)) || []);
      const clientRects = getRectsByLine(nativeClientRects);
      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));
      const paddingObject = getPaddingObject(padding);
      function getBoundingClientRect2() {
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
          return clientRects.find((rect) => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
        }
        if (clientRects.length >= 2) {
          if (getSideAxis(placement) === "y") {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = getSide(placement) === "top";
            const top2 = firstRect.top;
            const bottom2 = lastRect.bottom;
            const left2 = isTop ? firstRect.left : lastRect.left;
            const right2 = isTop ? firstRect.right : lastRect.right;
            const width2 = right2 - left2;
            const height2 = bottom2 - top2;
            return {
              top: top2,
              bottom: bottom2,
              left: left2,
              right: right2,
              width: width2,
              height: height2,
              x: left2,
              y: top2
            };
          }
          const isLeftSide = getSide(placement) === "left";
          const maxRight = max(...clientRects.map((rect) => rect.right));
          const minLeft = min(...clientRects.map((rect) => rect.left));
          const measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform2.getElementRects({
        reference: {
          getBoundingClientRect: getBoundingClientRect2
        },
        floating: elements.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply: apply2 = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply2({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function getCssDimensions(element) {
  const css = getComputedStyle(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : getWindowScrollBarX(documentElement, htmlRect));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        root: root2.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
autoPlacement;
shift2;
const flip$1 = flip$2;
size;
hide;
const arrow$2 = arrow$3;
inline;
limitShift;
const computePosition = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index$1 = typeof document !== "undefined" ? useLayoutEffect : useEffect;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys2;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length)
        return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys2 = Object.keys(a);
    length = keys2.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys2[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys2[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React$1.useRef(value);
  index$1(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating$1(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform: transform2 = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React$1.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React$1.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React$1.useState(null);
  const [_floating, _setFloating] = React$1.useState(null);
  const setReference = React$1.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React$1.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React$1.useRef(null);
  const floatingRef = React$1.useRef(null);
  const dataRef = React$1.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React$1.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index$1(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React$1.useRef(false);
  index$1(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index$1(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React$1.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React$1.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React$1.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform2) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform2, elements.floating, data.x, data.y]);
  return React$1.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef2(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef2(element)) {
        if (element.current != null) {
          return arrow$2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
const SafeReact = {
  ...React$1
};
const useInsertionEffect = SafeReact.useInsertionEffect;
const useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref = React$1.useRef(() => {
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return React$1.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
var index = typeof document !== "undefined" ? useLayoutEffect : useEffect;
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
let serverHandoffComplete = false;
let count = 0;
const genId = () => "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++;
function useFloatingId() {
  const [id, setId] = React$1.useState(() => serverHandoffComplete ? genId() : void 0);
  index(() => {
    if (id == null) {
      setId(genId());
    }
  }, []);
  React$1.useEffect(() => {
    serverHandoffComplete = true;
  }, []);
  return id;
}
const useReactId = SafeReact.useId;
const useId = useReactId || useFloatingId;
const FloatingArrow = /* @__PURE__ */ React$1.forwardRef(function FloatingArrow2(props, ref) {
  const {
    context: {
      placement,
      elements: {
        floating
      },
      middlewareData: {
        arrow: arrow2,
        shift: shift3
      }
    },
    width = 14,
    height = 7,
    tipRadius = 0,
    strokeWidth = 0,
    staticOffset,
    stroke,
    d,
    style: {
      transform: transform2,
      ...restStyle
    } = {},
    ...rest
  } = props;
  const clipPathId = useId();
  const [isRTL2, setIsRTL] = React$1.useState(false);
  index(() => {
    if (!floating)
      return;
    const isRTL3 = getComputedStyle(floating).direction === "rtl";
    if (isRTL3) {
      setIsRTL(true);
    }
  }, [floating]);
  if (!floating) {
    return null;
  }
  const [side, alignment] = placement.split("-");
  const isVerticalSide = side === "top" || side === "bottom";
  let computedStaticOffset = staticOffset;
  if (isVerticalSide && shift3 != null && shift3.x || !isVerticalSide && shift3 != null && shift3.y) {
    computedStaticOffset = null;
  }
  const computedStrokeWidth = strokeWidth * 2;
  const halfStrokeWidth = computedStrokeWidth / 2;
  const svgX = width / 2 * (tipRadius / -8 + 1);
  const svgY = height / 2 * tipRadius / 4;
  const isCustomShape = !!d;
  const yOffsetProp = computedStaticOffset && alignment === "end" ? "bottom" : "top";
  let xOffsetProp = computedStaticOffset && alignment === "end" ? "right" : "left";
  if (computedStaticOffset && isRTL2) {
    xOffsetProp = alignment === "end" ? "left" : "right";
  }
  const arrowX = (arrow2 == null ? void 0 : arrow2.x) != null ? computedStaticOffset || arrow2.x : "";
  const arrowY = (arrow2 == null ? void 0 : arrow2.y) != null ? computedStaticOffset || arrow2.y : "";
  const dValue = d || "M0,0" + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + " Z";
  const rotation = {
    top: isCustomShape ? "rotate(180deg)" : "",
    left: isCustomShape ? "rotate(90deg)" : "rotate(-90deg)",
    bottom: isCustomShape ? "" : "rotate(180deg)",
    right: isCustomShape ? "rotate(-90deg)" : "rotate(90deg)"
  }[side];
  return /* @__PURE__ */ React$1.createElement("svg", _extends({}, rest, {
    "aria-hidden": true,
    ref,
    width: isCustomShape ? width : width + computedStrokeWidth,
    height: width,
    viewBox: "0 0 " + width + " " + (height > width ? height : width),
    style: {
      position: "absolute",
      pointerEvents: "none",
      [xOffsetProp]: arrowX,
      [yOffsetProp]: arrowY,
      [side]: isVerticalSide || isCustomShape ? "100%" : "calc(100% - " + computedStrokeWidth / 2 + "px)",
      transform: [rotation, transform2].filter((t) => !!t).join(" "),
      ...restStyle
    }
  }), computedStrokeWidth > 0 && /* @__PURE__ */ React$1.createElement("path", {
    clipPath: "url(#" + clipPathId + ")",
    fill: "none",
    stroke,
    strokeWidth: computedStrokeWidth + (d ? 0 : 1),
    d: dValue
  }), /* @__PURE__ */ React$1.createElement("path", {
    stroke: computedStrokeWidth && !d ? rest.fill : "none",
    d: dValue
  }), /* @__PURE__ */ React$1.createElement("clipPath", {
    id: clipPathId
  }, /* @__PURE__ */ React$1.createElement("rect", {
    x: -halfStrokeWidth,
    y: halfStrokeWidth * (isCustomShape ? -1 : 1),
    width: width + computedStrokeWidth,
    height: width
  })));
});
function createPubSub() {
  const map3 = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map3.get(event)) == null || _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map3.set(event, [...map3.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map3.set(event, ((_map$get2 = map3.get(event)) == null ? void 0 : _map$get2.filter((l2) => l2 !== listener)) || []);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ React$1.createContext(null);
const FloatingTreeContext = /* @__PURE__ */ React$1.createContext(null);
const useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = React$1.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
const useFloatingTree = () => React$1.useContext(FloatingTreeContext);
function useFloatingRootContext(options) {
  const {
    open = false,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options;
  const floatingId = useId();
  const dataRef = React$1.useRef({});
  const [events] = React$1.useState(() => createPubSub());
  const nested = useFloatingParentNodeId() != null;
  const [positionReference, setPositionReference] = React$1.useState(elementsProp.reference);
  const onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0;
    events.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    });
    onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);
  });
  const refs = React$1.useMemo(() => ({
    setPositionReference
  }), []);
  const elements = React$1.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React$1.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    nodeId
  } = options;
  const internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  });
  const rootContext = options.rootContext || internalRootContext;
  const computedElements = rootContext.elements;
  const [_domReference, setDomReference] = React$1.useState(null);
  const [positionReference, _setPositionReference] = React$1.useState(null);
  const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;
  const domReference = optionDomReference || _domReference;
  const domReferenceRef = React$1.useRef(null);
  const tree = useFloatingTree();
  index(() => {
    if (domReference) {
      domReferenceRef.current = domReference;
    }
  }, [domReference]);
  const position = useFloating$1({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  });
  const setPositionReference = React$1.useCallback((node) => {
    const computedPositionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      contextElement: node
    } : node;
    _setPositionReference(computedPositionReference);
    position.refs.setReference(computedPositionReference);
  }, [position.refs]);
  const setReference = React$1.useCallback((node) => {
    if (isElement(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }
    if (isElement(position.refs.reference.current) || position.refs.reference.current === null || node !== null && !isElement(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = React$1.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements = React$1.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]);
  const context = React$1.useMemo(() => ({
    ...position,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position, refs, elements, nodeId, rootContext]);
  index(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  return React$1.useMemo(() => ({
    ...position,
    context,
    refs,
    elements
  }), [position, refs, elements, context]);
}
var _extendStatics = function extendStatics(d, b) {
  _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p2 in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p2))
        d2[p2] = b2[p2];
  };
  return _extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  _extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var _assign = function __assign() {
  _assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return _assign.apply(this, arguments);
};
function __spreadArray(to2, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to2.concat(ar || Array.prototype.slice.call(from2));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
  var e = new Error(message2);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var CalendarContainer = function(_a2) {
  var _b = _a2.showTimeSelectOnly, showTimeSelectOnly = _b === void 0 ? false : _b, _c = _a2.showTime, showTime = _c === void 0 ? false : _c, className = _a2.className, children = _a2.children;
  var ariaLabel = showTimeSelectOnly ? "Choose Time" : "Choose Date".concat(showTime ? " and Time" : "");
  return /* @__PURE__ */ jsx("div", { className, role: "dialog", "aria-label": ariaLabel, "aria-modal": "true", children });
};
var useDetectClickOutside = function(onClickOutside, ignoreClass) {
  var ref = useRef(null);
  var onClickOutsideRef = useRef(onClickOutside);
  onClickOutsideRef.current = onClickOutside;
  var handleClickOutside = useCallback(function(event) {
    var _a2;
    if (ref.current && !ref.current.contains(event.target)) {
      if (!(ignoreClass && event.target instanceof HTMLElement && event.target.classList.contains(ignoreClass))) {
        (_a2 = onClickOutsideRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(onClickOutsideRef, event);
      }
    }
  }, [ignoreClass]);
  useEffect(function() {
    document.addEventListener("mousedown", handleClickOutside);
    return function() {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [handleClickOutside]);
  return ref;
};
var ClickOutsideWrapper = function(_a2) {
  var children = _a2.children, onClickOutside = _a2.onClickOutside, className = _a2.className, containerRef = _a2.containerRef, style = _a2.style, ignoreClass = _a2.ignoreClass;
  var detectRef = useDetectClickOutside(onClickOutside, ignoreClass);
  return /* @__PURE__ */ jsx("div", { className, style, ref: function(node) {
    detectRef.current = node;
    if (containerRef) {
      containerRef.current = node;
    }
  }, children });
};
var KeyType;
(function(KeyType2) {
  KeyType2["ArrowUp"] = "ArrowUp";
  KeyType2["ArrowDown"] = "ArrowDown";
  KeyType2["ArrowLeft"] = "ArrowLeft";
  KeyType2["ArrowRight"] = "ArrowRight";
  KeyType2["PageUp"] = "PageUp";
  KeyType2["PageDown"] = "PageDown";
  KeyType2["Home"] = "Home";
  KeyType2["End"] = "End";
  KeyType2["Enter"] = "Enter";
  KeyType2["Space"] = " ";
  KeyType2["Tab"] = "Tab";
  KeyType2["Escape"] = "Escape";
  KeyType2["Backspace"] = "Backspace";
  KeyType2["X"] = "x";
})(KeyType || (KeyType = {}));
function getLocaleScope() {
  var scope2 = typeof window !== "undefined" ? window : globalThis;
  return scope2;
}
var DEFAULT_YEAR_ITEM_NUMBER = 12;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
function newDate(value) {
  if (value == null) {
    return new Date();
  }
  var d = typeof value === "string" ? parseISO(value) : toDate(value);
  return isValid2(d) ? d : new Date();
}
function parseDate(value, dateFormat, locale2, strictParsing, minDate) {
  var _a2;
  var parsedDate = null;
  var localeObject = getLocaleObject(locale2) || getLocaleObject(getDefaultLocale());
  var strictParsingValueMatch = true;
  if (Array.isArray(dateFormat)) {
    dateFormat.forEach(function(df) {
      var tryParseDate = parse(value, df, new Date(), { locale: localeObject, useAdditionalWeekYearTokens: true, useAdditionalDayOfYearTokens: true });
      if (strictParsing) {
        strictParsingValueMatch = isValid2(tryParseDate, minDate) && value === formatDate(tryParseDate, df, locale2);
      }
      if (isValid2(tryParseDate, minDate) && strictParsingValueMatch) {
        parsedDate = tryParseDate;
      }
    });
    return parsedDate;
  }
  parsedDate = parse(value, dateFormat, new Date(), { locale: localeObject, useAdditionalWeekYearTokens: true, useAdditionalDayOfYearTokens: true });
  if (strictParsing) {
    strictParsingValueMatch = isValid2(parsedDate) && value === formatDate(parsedDate, dateFormat, locale2);
  } else if (!isValid2(parsedDate)) {
    var format_1 = ((_a2 = dateFormat.match(longFormattingTokensRegExp)) !== null && _a2 !== void 0 ? _a2 : []).map(function(substring) {
      var firstCharacter = substring[0];
      if (firstCharacter === "p" || firstCharacter === "P") {
        var longFormatter = longFormatters[firstCharacter];
        return localeObject ? longFormatter(substring, localeObject.formatLong) : firstCharacter;
      }
      return substring;
    }).join("");
    if (value.length > 0) {
      parsedDate = parse(value, format_1.slice(0, value.length), new Date(), { useAdditionalWeekYearTokens: true, useAdditionalDayOfYearTokens: true });
    }
    if (!isValid2(parsedDate)) {
      parsedDate = new Date(value);
    }
  }
  return isValid2(parsedDate) && strictParsingValueMatch ? parsedDate : null;
}
function isValid2(date2, minDate) {
  return isValid$1(date2) && !isBefore(date2, minDate !== null && minDate !== void 0 ? minDate : new Date("1/1/1800"));
}
function formatDate(date2, formatStr, locale2) {
  if (locale2 === "en") {
    return format(date2, formatStr, { useAdditionalWeekYearTokens: true, useAdditionalDayOfYearTokens: true });
  }
  var localeObj = locale2 ? getLocaleObject(locale2) : void 0;
  if (locale2 && !localeObj) {
    console.warn('A locale object was not found for the provided string ["'.concat(locale2, '"].'));
  }
  if (!localeObj && !!getDefaultLocale() && !!getLocaleObject(getDefaultLocale())) {
    localeObj = getLocaleObject(getDefaultLocale());
  }
  return format(date2, formatStr, { locale: localeObj, useAdditionalWeekYearTokens: true, useAdditionalDayOfYearTokens: true });
}
function safeDateFormat(date2, _a2) {
  var dateFormat = _a2.dateFormat, locale2 = _a2.locale;
  var formatStr = Array.isArray(dateFormat) && dateFormat.length > 0 ? dateFormat[0] : dateFormat;
  return date2 && formatDate(date2, formatStr, locale2) || "";
}
function safeDateRangeFormat(startDate, endDate, props) {
  if (!startDate) {
    return "";
  }
  var formattedStartDate = safeDateFormat(startDate, props);
  var formattedEndDate = endDate ? safeDateFormat(endDate, props) : "";
  return "".concat(formattedStartDate, " - ").concat(formattedEndDate);
}
function safeMultipleDatesFormat(dates, props) {
  if (!(dates === null || dates === void 0 ? void 0 : dates.length)) {
    return "";
  }
  var formattedFirstDate = dates[0] ? safeDateFormat(dates[0], props) : "";
  if (dates.length === 1) {
    return formattedFirstDate;
  }
  if (dates.length === 2 && dates[1]) {
    var formattedSecondDate = safeDateFormat(dates[1], props);
    return "".concat(formattedFirstDate, ", ").concat(formattedSecondDate);
  }
  var extraDatesCount = dates.length - 1;
  return "".concat(formattedFirstDate, " (+").concat(extraDatesCount, ")");
}
function setTime(date2, _a2) {
  var _b = _a2.hour, hour = _b === void 0 ? 0 : _b, _c = _a2.minute, minute = _c === void 0 ? 0 : _c, _d = _a2.second, second = _d === void 0 ? 0 : _d;
  return setHours(setMinutes(setSeconds(date2, second), minute), hour);
}
function getWeek(date2) {
  return getISOWeek(date2);
}
function getDayOfWeekCode(day, locale2) {
  return formatDate(day, "ddd", locale2);
}
function getStartOfDay(date2) {
  return startOfDay(date2);
}
function getStartOfWeek(date2, locale2, calendarStartDay) {
  var localeObj = locale2 ? getLocaleObject(locale2) : getLocaleObject(getDefaultLocale());
  return startOfWeek(date2, { locale: localeObj, weekStartsOn: calendarStartDay });
}
function getStartOfMonth(date2) {
  return startOfMonth(date2);
}
function getStartOfYear(date2) {
  return startOfYear(date2);
}
function getStartOfQuarter(date2) {
  return startOfQuarter(date2);
}
function getStartOfToday() {
  return startOfDay(newDate());
}
function getEndOfDay(date2) {
  return endOfDay(date2);
}
function getEndOfWeek(date2) {
  return endOfWeek(date2);
}
function getEndOfMonth(date2) {
  return endOfMonth(date2);
}
function isSameYear(date1, date2) {
  if (date1 && date2) {
    return isSameYear$1(date1, date2);
  } else {
    return !date1 && !date2;
  }
}
function isSameMonth(date1, date2) {
  if (date1 && date2) {
    return isSameMonth$1(date1, date2);
  } else {
    return !date1 && !date2;
  }
}
function isSameQuarter(date1, date2) {
  if (date1 && date2) {
    return isSameQuarter$1(date1, date2);
  } else {
    return !date1 && !date2;
  }
}
function isSameDay(date1, date2) {
  if (date1 && date2) {
    return isSameDay$1(date1, date2);
  } else {
    return !date1 && !date2;
  }
}
function isEqual(date1, date2) {
  if (date1 && date2) {
    return isEqual$1(date1, date2);
  } else {
    return !date1 && !date2;
  }
}
function isDayInRange(day, startDate, endDate) {
  var valid;
  var start = startOfDay(startDate);
  var end = endOfDay(endDate);
  try {
    valid = isWithinInterval(day, { start, end });
  } catch (err) {
    valid = false;
  }
  return valid;
}
function getDefaultLocale() {
  var scope2 = getLocaleScope();
  return scope2.__localeId__;
}
function getLocaleObject(localeSpec) {
  if (typeof localeSpec === "string") {
    var scope2 = getLocaleScope();
    return scope2.__localeData__ ? scope2.__localeData__[localeSpec] : void 0;
  } else {
    return localeSpec;
  }
}
function getFormattedWeekdayInLocale(date2, formatFunc, locale2) {
  return formatFunc(formatDate(date2, "EEEE", locale2));
}
function getWeekdayMinInLocale(date2, locale2) {
  return formatDate(date2, "EEEEEE", locale2);
}
function getWeekdayShortInLocale(date2, locale2) {
  return formatDate(date2, "EEE", locale2);
}
function getMonthInLocale(month, locale2) {
  return formatDate(setMonth(newDate(), month), "LLLL", locale2);
}
function getMonthShortInLocale(month, locale2) {
  return formatDate(setMonth(newDate(), month), "LLL", locale2);
}
function getQuarterShortInLocale(quarter, locale2) {
  return formatDate(setQuarter(newDate(), quarter), "QQQ", locale2);
}
function isDayDisabled(day, _a2) {
  var _b = _a2 === void 0 ? {} : _a2, minDate = _b.minDate, maxDate = _b.maxDate, excludeDates = _b.excludeDates, excludeDateIntervals = _b.excludeDateIntervals, includeDates = _b.includeDates, includeDateIntervals = _b.includeDateIntervals, filterDate = _b.filterDate;
  return isOutOfBounds(day, { minDate, maxDate }) || excludeDates && excludeDates.some(function(excludeDate) {
    if (excludeDate instanceof Date) {
      return isSameDay(day, excludeDate);
    } else {
      return isSameDay(day, excludeDate.date);
    }
  }) || excludeDateIntervals && excludeDateIntervals.some(function(_a3) {
    var start = _a3.start, end = _a3.end;
    return isWithinInterval(day, { start, end });
  }) || includeDates && !includeDates.some(function(includeDate) {
    return isSameDay(day, includeDate);
  }) || includeDateIntervals && !includeDateIntervals.some(function(_a3) {
    var start = _a3.start, end = _a3.end;
    return isWithinInterval(day, { start, end });
  }) || filterDate && !filterDate(newDate(day)) || false;
}
function isDayExcluded(day, _a2) {
  var _b = _a2 === void 0 ? {} : _a2, excludeDates = _b.excludeDates, excludeDateIntervals = _b.excludeDateIntervals;
  if (excludeDateIntervals && excludeDateIntervals.length > 0) {
    return excludeDateIntervals.some(function(_a3) {
      var start = _a3.start, end = _a3.end;
      return isWithinInterval(day, { start, end });
    });
  }
  return excludeDates && excludeDates.some(function(excludeDate) {
    var _a3;
    if (excludeDate instanceof Date) {
      return isSameDay(day, excludeDate);
    } else {
      return isSameDay(day, (_a3 = excludeDate.date) !== null && _a3 !== void 0 ? _a3 : new Date());
    }
  }) || false;
}
function isMonthDisabled(month, _a2) {
  var _b = _a2 === void 0 ? {} : _a2, minDate = _b.minDate, maxDate = _b.maxDate, excludeDates = _b.excludeDates, includeDates = _b.includeDates, filterDate = _b.filterDate;
  return isOutOfBounds(month, { minDate: minDate ? startOfMonth(minDate) : void 0, maxDate: maxDate ? endOfMonth(maxDate) : void 0 }) || (excludeDates === null || excludeDates === void 0 ? void 0 : excludeDates.some(function(excludeDate) {
    return isSameMonth(month, excludeDate instanceof Date ? excludeDate : excludeDate.date);
  })) || includeDates && !includeDates.some(function(includeDate) {
    return isSameMonth(month, includeDate);
  }) || filterDate && !filterDate(newDate(month)) || false;
}
function isMonthInRange(startDate, endDate, m2, day) {
  var startDateYear = getYear(startDate);
  var startDateMonth = getMonth(startDate);
  var endDateYear = getYear(endDate);
  var endDateMonth = getMonth(endDate);
  var dayYear = getYear(day);
  if (startDateYear === endDateYear && startDateYear === dayYear) {
    return startDateMonth <= m2 && m2 <= endDateMonth;
  } else if (startDateYear < endDateYear) {
    return dayYear === startDateYear && startDateMonth <= m2 || dayYear === endDateYear && endDateMonth >= m2 || dayYear < endDateYear && dayYear > startDateYear;
  }
  return false;
}
function isMonthYearDisabled(date2, _a2) {
  var _b = _a2 === void 0 ? {} : _a2, minDate = _b.minDate, maxDate = _b.maxDate, excludeDates = _b.excludeDates, includeDates = _b.includeDates;
  return isOutOfBounds(date2, { minDate, maxDate }) || excludeDates && excludeDates.some(function(excludedDate) {
    return isSameMonth(excludedDate instanceof Date ? excludedDate : excludedDate.date, date2);
  }) || includeDates && !includeDates.some(function(includedDate) {
    return isSameMonth(includedDate, date2);
  }) || false;
}
function isQuarterDisabled(quarter, _a2) {
  var _b = _a2 === void 0 ? {} : _a2, minDate = _b.minDate, maxDate = _b.maxDate, excludeDates = _b.excludeDates, includeDates = _b.includeDates, filterDate = _b.filterDate;
  return isOutOfBounds(quarter, { minDate, maxDate }) || (excludeDates === null || excludeDates === void 0 ? void 0 : excludeDates.some(function(excludeDate) {
    return isSameQuarter(quarter, excludeDate instanceof Date ? excludeDate : excludeDate.date);
  })) || includeDates && !includeDates.some(function(includeDate) {
    return isSameQuarter(quarter, includeDate);
  }) || filterDate && !filterDate(newDate(quarter)) || false;
}
function isYearInRange(year, start, end) {
  if (!start || !end)
    return false;
  if (!isValid$1(start) || !isValid$1(end))
    return false;
  var startYear = getYear(start);
  var endYear = getYear(end);
  return startYear <= year && endYear >= year;
}
function isYearDisabled(year, _a2) {
  var _b = _a2 === void 0 ? {} : _a2, minDate = _b.minDate, maxDate = _b.maxDate, excludeDates = _b.excludeDates, includeDates = _b.includeDates, filterDate = _b.filterDate;
  var date2 = new Date(year, 0, 1);
  return isOutOfBounds(date2, { minDate: minDate ? startOfYear(minDate) : void 0, maxDate: maxDate ? endOfYear(maxDate) : void 0 }) || (excludeDates === null || excludeDates === void 0 ? void 0 : excludeDates.some(function(excludeDate) {
    return isSameYear(date2, excludeDate instanceof Date ? excludeDate : excludeDate.date);
  })) || includeDates && !includeDates.some(function(includeDate) {
    return isSameYear(date2, includeDate);
  }) || filterDate && !filterDate(newDate(date2)) || false;
}
function isQuarterInRange(startDate, endDate, q2, day) {
  var startDateYear = getYear(startDate);
  var startDateQuarter = getQuarter(startDate);
  var endDateYear = getYear(endDate);
  var endDateQuarter = getQuarter(endDate);
  var dayYear = getYear(day);
  if (startDateYear === endDateYear && startDateYear === dayYear) {
    return startDateQuarter <= q2 && q2 <= endDateQuarter;
  } else if (startDateYear < endDateYear) {
    return dayYear === startDateYear && startDateQuarter <= q2 || dayYear === endDateYear && endDateQuarter >= q2 || dayYear < endDateYear && dayYear > startDateYear;
  }
  return false;
}
function isOutOfBounds(day, _a2) {
  var _b;
  var _c = _a2 === void 0 ? {} : _a2, minDate = _c.minDate, maxDate = _c.maxDate;
  return (_b = minDate && differenceInCalendarDays(day, minDate) < 0 || maxDate && differenceInCalendarDays(day, maxDate) > 0) !== null && _b !== void 0 ? _b : false;
}
function isTimeInList(time, times) {
  return times.some(function(listTime) {
    return getHours(listTime) === getHours(time) && getMinutes(listTime) === getMinutes(time) && getSeconds(listTime) === getSeconds(time);
  });
}
function isTimeDisabled(time, _a2) {
  var _b = _a2 === void 0 ? {} : _a2, excludeTimes = _b.excludeTimes, includeTimes = _b.includeTimes, filterTime = _b.filterTime;
  return excludeTimes && isTimeInList(time, excludeTimes) || includeTimes && !isTimeInList(time, includeTimes) || filterTime && !filterTime(time) || false;
}
function isTimeInDisabledRange(time, _a2) {
  var minTime = _a2.minTime, maxTime = _a2.maxTime;
  if (!minTime || !maxTime) {
    throw new Error("Both minTime and maxTime props required");
  }
  var baseTime = newDate();
  baseTime = setHours(baseTime, getHours(time));
  baseTime = setMinutes(baseTime, getMinutes(time));
  baseTime = setSeconds(baseTime, getSeconds(time));
  var min2 = newDate();
  min2 = setHours(min2, getHours(minTime));
  min2 = setMinutes(min2, getMinutes(minTime));
  min2 = setSeconds(min2, getSeconds(minTime));
  var max2 = newDate();
  max2 = setHours(max2, getHours(maxTime));
  max2 = setMinutes(max2, getMinutes(maxTime));
  max2 = setSeconds(max2, getSeconds(maxTime));
  var valid;
  try {
    valid = !isWithinInterval(baseTime, { start: min2, end: max2 });
  } catch (err) {
    valid = false;
  }
  return valid;
}
function monthDisabledBefore(day, _a2) {
  var _b = _a2 === void 0 ? {} : _a2, minDate = _b.minDate, includeDates = _b.includeDates;
  var previousMonth = subMonths(day, 1);
  return minDate && differenceInCalendarMonths(minDate, previousMonth) > 0 || includeDates && includeDates.every(function(includeDate) {
    return differenceInCalendarMonths(includeDate, previousMonth) > 0;
  }) || false;
}
function monthDisabledAfter(day, _a2) {
  var _b = _a2 === void 0 ? {} : _a2, maxDate = _b.maxDate, includeDates = _b.includeDates;
  var nextMonth = addMonths(day, 1);
  return maxDate && differenceInCalendarMonths(nextMonth, maxDate) > 0 || includeDates && includeDates.every(function(includeDate) {
    return differenceInCalendarMonths(nextMonth, includeDate) > 0;
  }) || false;
}
function quarterDisabledBefore(date2, _a2) {
  var _b = _a2 === void 0 ? {} : _a2, minDate = _b.minDate, includeDates = _b.includeDates;
  var firstDateOfYear = startOfYear(date2);
  var previousQuarter = subQuarters(firstDateOfYear, 1);
  return minDate && differenceInCalendarQuarters(minDate, previousQuarter) > 0 || includeDates && includeDates.every(function(includeDate) {
    return differenceInCalendarQuarters(includeDate, previousQuarter) > 0;
  }) || false;
}
function quarterDisabledAfter(date2, _a2) {
  var _b = _a2 === void 0 ? {} : _a2, maxDate = _b.maxDate, includeDates = _b.includeDates;
  var lastDateOfYear = endOfYear(date2);
  var nextQuarter = addQuarters(lastDateOfYear, 1);
  return maxDate && differenceInCalendarQuarters(nextQuarter, maxDate) > 0 || includeDates && includeDates.every(function(includeDate) {
    return differenceInCalendarQuarters(nextQuarter, includeDate) > 0;
  }) || false;
}
function yearDisabledBefore(day, _a2) {
  var _b = _a2 === void 0 ? {} : _a2, minDate = _b.minDate, includeDates = _b.includeDates;
  var previousYear = subYears(day, 1);
  return minDate && differenceInCalendarYears(minDate, previousYear) > 0 || includeDates && includeDates.every(function(includeDate) {
    return differenceInCalendarYears(includeDate, previousYear) > 0;
  }) || false;
}
function yearsDisabledBefore(day, _a2) {
  var _b = _a2 === void 0 ? {} : _a2, minDate = _b.minDate, _c = _b.yearItemNumber, yearItemNumber = _c === void 0 ? DEFAULT_YEAR_ITEM_NUMBER : _c;
  var previousYear = getStartOfYear(subYears(day, yearItemNumber));
  var endPeriod = getYearsPeriod(previousYear, yearItemNumber).endPeriod;
  var minDateYear = minDate && getYear(minDate);
  return minDateYear && minDateYear > endPeriod || false;
}
function yearDisabledAfter(day, _a2) {
  var _b = _a2 === void 0 ? {} : _a2, maxDate = _b.maxDate, includeDates = _b.includeDates;
  var nextYear = addYears(day, 1);
  return maxDate && differenceInCalendarYears(nextYear, maxDate) > 0 || includeDates && includeDates.every(function(includeDate) {
    return differenceInCalendarYears(nextYear, includeDate) > 0;
  }) || false;
}
function yearsDisabledAfter(day, _a2) {
  var _b = _a2 === void 0 ? {} : _a2, maxDate = _b.maxDate, _c = _b.yearItemNumber, yearItemNumber = _c === void 0 ? DEFAULT_YEAR_ITEM_NUMBER : _c;
  var nextYear = addYears(day, yearItemNumber);
  var startPeriod = getYearsPeriod(nextYear, yearItemNumber).startPeriod;
  var maxDateYear = maxDate && getYear(maxDate);
  return maxDateYear && maxDateYear < startPeriod || false;
}
function getEffectiveMinDate(_a2) {
  var minDate = _a2.minDate, includeDates = _a2.includeDates;
  if (includeDates && minDate) {
    var minDates = includeDates.filter(function(includeDate) {
      return differenceInCalendarDays(includeDate, minDate) >= 0;
    });
    return min$1(minDates);
  } else if (includeDates) {
    return min$1(includeDates);
  } else {
    return minDate;
  }
}
function getEffectiveMaxDate(_a2) {
  var maxDate = _a2.maxDate, includeDates = _a2.includeDates;
  if (includeDates && maxDate) {
    var maxDates = includeDates.filter(function(includeDate) {
      return differenceInCalendarDays(includeDate, maxDate) <= 0;
    });
    return max$1(maxDates);
  } else if (includeDates) {
    return max$1(includeDates);
  } else {
    return maxDate;
  }
}
function getHighLightDaysMap(highlightDates, defaultClassName) {
  var _a2;
  if (highlightDates === void 0) {
    highlightDates = [];
  }
  if (defaultClassName === void 0) {
    defaultClassName = "react-datepicker__day--highlighted";
  }
  var dateClasses = /* @__PURE__ */ new Map();
  for (var i = 0, len = highlightDates.length; i < len; i++) {
    var obj = highlightDates[i];
    if (isDate(obj)) {
      var key = formatDate(obj, "MM.dd.yyyy");
      var classNamesArr = dateClasses.get(key) || [];
      if (!classNamesArr.includes(defaultClassName)) {
        classNamesArr.push(defaultClassName);
        dateClasses.set(key, classNamesArr);
      }
    } else if (typeof obj === "object") {
      var keys2 = Object.keys(obj);
      var className = (_a2 = keys2[0]) !== null && _a2 !== void 0 ? _a2 : "";
      var arrOfDates = obj[className];
      if (typeof className === "string" && Array.isArray(arrOfDates)) {
        for (var k2 = 0, len_1 = arrOfDates.length; k2 < len_1; k2++) {
          var dateK = arrOfDates[k2];
          if (dateK) {
            var key = formatDate(dateK, "MM.dd.yyyy");
            var classNamesArr = dateClasses.get(key) || [];
            if (!classNamesArr.includes(className)) {
              classNamesArr.push(className);
              dateClasses.set(key, classNamesArr);
            }
          }
        }
      }
    }
  }
  return dateClasses;
}
function arraysAreEqual(array1, array2) {
  if (array1.length !== array2.length) {
    return false;
  }
  return array1.every(function(value, index2) {
    return value === array2[index2];
  });
}
function getHolidaysMap(holidayDates, defaultClassName) {
  if (holidayDates === void 0) {
    holidayDates = [];
  }
  if (defaultClassName === void 0) {
    defaultClassName = "react-datepicker__day--holidays";
  }
  var dateClasses = /* @__PURE__ */ new Map();
  holidayDates.forEach(function(holiday) {
    var dateObj = holiday.date, holidayName = holiday.holidayName;
    if (!isDate(dateObj)) {
      return;
    }
    var key = formatDate(dateObj, "MM.dd.yyyy");
    var classNamesObj = dateClasses.get(key) || { className: "", holidayNames: [] };
    if ("className" in classNamesObj && classNamesObj["className"] === defaultClassName && arraysAreEqual(classNamesObj["holidayNames"], [holidayName])) {
      return;
    }
    classNamesObj["className"] = defaultClassName;
    var holidayNameArr = classNamesObj["holidayNames"];
    classNamesObj["holidayNames"] = holidayNameArr ? __spreadArray(__spreadArray([], holidayNameArr, true), [holidayName], false) : [holidayName];
    dateClasses.set(key, classNamesObj);
  });
  return dateClasses;
}
function timesToInjectAfter(startOfDay2, currentTime, currentMultiplier, intervals, injectedTimes) {
  var l2 = injectedTimes.length;
  var times = [];
  for (var i = 0; i < l2; i++) {
    var injectedTime = startOfDay2;
    var injectedTimeValue = injectedTimes[i];
    if (injectedTimeValue) {
      injectedTime = addHours(injectedTime, getHours(injectedTimeValue));
      injectedTime = addMinutes(injectedTime, getMinutes(injectedTimeValue));
      injectedTime = addSeconds(injectedTime, getSeconds(injectedTimeValue));
    }
    var nextTime = addMinutes(startOfDay2, (currentMultiplier + 1) * intervals);
    if (isAfter(injectedTime, currentTime) && isBefore(injectedTime, nextTime) && injectedTimeValue != void 0) {
      times.push(injectedTimeValue);
    }
  }
  return times;
}
function addZero(i) {
  return i < 10 ? "0".concat(i) : "".concat(i);
}
function getYearsPeriod(date2, yearItemNumber) {
  if (yearItemNumber === void 0) {
    yearItemNumber = DEFAULT_YEAR_ITEM_NUMBER;
  }
  var endPeriod = Math.ceil(getYear(date2) / yearItemNumber) * yearItemNumber;
  var startPeriod = endPeriod - (yearItemNumber - 1);
  return { startPeriod, endPeriod };
}
function getHoursInDay(d) {
  var startOfDay2 = new Date(d.getFullYear(), d.getMonth(), d.getDate());
  var startOfTheNextDay = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 24);
  return Math.round((+startOfTheNextDay - +startOfDay2) / 36e5);
}
function startOfMinute(d) {
  var seconds2 = d.getSeconds();
  var milliseconds2 = d.getMilliseconds();
  return toDate(d.getTime() - seconds2 * 1e3 - milliseconds2);
}
function isSameMinute(d1, d2) {
  return startOfMinute(d1).getTime() === startOfMinute(d2).getTime();
}
function getMidnightDate(date2) {
  if (!isDate(date2)) {
    throw new Error("Invalid date");
  }
  var dateWithoutTime = new Date(date2);
  dateWithoutTime.setHours(0, 0, 0, 0);
  return dateWithoutTime;
}
function isDateBefore(date2, dateToCompare) {
  if (!isDate(date2) || !isDate(dateToCompare)) {
    throw new Error("Invalid date received");
  }
  var midnightDate = getMidnightDate(date2);
  var midnightDateToCompare = getMidnightDate(dateToCompare);
  return isBefore(midnightDate, midnightDateToCompare);
}
function isSpaceKeyDown(event) {
  return event.key === KeyType.Space;
}
var InputTime = function(_super) {
  __extends(InputTime2, _super);
  function InputTime2(props) {
    var _this = _super.call(this, props) || this;
    _this.inputRef = React__default.createRef();
    _this.onTimeChange = function(time) {
      var _a2, _b;
      _this.setState({ time });
      var propDate = _this.props.date;
      var isPropDateValid = propDate instanceof Date && !isNaN(+propDate);
      var date2 = isPropDateValid ? propDate : new Date();
      if (time === null || time === void 0 ? void 0 : time.includes(":")) {
        var _c = time.split(":"), hours2 = _c[0], minutes2 = _c[1];
        date2.setHours(Number(hours2));
        date2.setMinutes(Number(minutes2));
      }
      (_b = (_a2 = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a2, date2);
    };
    _this.renderTimeInput = function() {
      var time = _this.state.time;
      var _a2 = _this.props, date2 = _a2.date, timeString = _a2.timeString, customTimeInput = _a2.customTimeInput;
      if (customTimeInput) {
        return cloneElement(customTimeInput, { date: date2, value: time, onChange: _this.onTimeChange });
      }
      return /* @__PURE__ */ jsx("input", { type: "time", className: "react-datepicker-time__input", placeholder: "Time", name: "time-input", ref: _this.inputRef, onClick: function() {
        var _a3;
        (_a3 = _this.inputRef.current) === null || _a3 === void 0 ? void 0 : _a3.focus();
      }, required: true, value: time, onChange: function(event) {
        _this.onTimeChange(event.target.value || timeString);
      } });
    };
    _this.state = { time: _this.props.timeString };
    return _this;
  }
  InputTime2.getDerivedStateFromProps = function(props, state) {
    if (props.timeString !== state.time) {
      return { time: props.timeString };
    }
    return null;
  };
  InputTime2.prototype.render = function() {
    return /* @__PURE__ */ jsxs("div", { className: "react-datepicker__input-time-container", children: [/* @__PURE__ */ jsx("div", { className: "react-datepicker-time__caption", children: this.props.timeInputLabel }), /* @__PURE__ */ jsx("div", { className: "react-datepicker-time__input-container", children: /* @__PURE__ */ jsx("div", { className: "react-datepicker-time__input", children: this.renderTimeInput() }) })] });
  };
  return InputTime2;
}(Component);
var Day = function(_super) {
  __extends(Day2, _super);
  function Day2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.dayEl = createRef();
    _this.handleClick = function(event) {
      if (!_this.isDisabled() && _this.props.onClick) {
        _this.props.onClick(event);
      }
    };
    _this.handleMouseEnter = function(event) {
      if (!_this.isDisabled() && _this.props.onMouseEnter) {
        _this.props.onMouseEnter(event);
      }
    };
    _this.handleOnKeyDown = function(event) {
      var _a2, _b;
      var eventKey = event.key;
      if (eventKey === KeyType.Space) {
        event.preventDefault();
        event.key = KeyType.Enter;
      }
      (_b = (_a2 = _this.props).handleOnKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a2, event);
    };
    _this.isSameDay = function(other) {
      return isSameDay(_this.props.day, other);
    };
    _this.isKeyboardSelected = function() {
      var _a2;
      if (_this.props.disabledKeyboardNavigation) {
        return false;
      }
      var isSelectedDate = _this.props.selectsMultiple ? (_a2 = _this.props.selectedDates) === null || _a2 === void 0 ? void 0 : _a2.some(function(date2) {
        return _this.isSameDayOrWeek(date2);
      }) : _this.isSameDayOrWeek(_this.props.selected);
      var isDisabled = _this.props.preSelection && _this.isDisabled(_this.props.preSelection);
      return !isSelectedDate && _this.isSameDayOrWeek(_this.props.preSelection) && !isDisabled;
    };
    _this.isDisabled = function(day) {
      if (day === void 0) {
        day = _this.props.day;
      }
      return isDayDisabled(day, { minDate: _this.props.minDate, maxDate: _this.props.maxDate, excludeDates: _this.props.excludeDates, excludeDateIntervals: _this.props.excludeDateIntervals, includeDateIntervals: _this.props.includeDateIntervals, includeDates: _this.props.includeDates, filterDate: _this.props.filterDate });
    };
    _this.isExcluded = function() {
      return isDayExcluded(_this.props.day, { excludeDates: _this.props.excludeDates, excludeDateIntervals: _this.props.excludeDateIntervals });
    };
    _this.isStartOfWeek = function() {
      return isSameDay(_this.props.day, getStartOfWeek(_this.props.day, _this.props.locale, _this.props.calendarStartDay));
    };
    _this.isSameWeek = function(other) {
      return _this.props.showWeekPicker && isSameDay(other, getStartOfWeek(_this.props.day, _this.props.locale, _this.props.calendarStartDay));
    };
    _this.isSameDayOrWeek = function(other) {
      return _this.isSameDay(other) || _this.isSameWeek(other);
    };
    _this.getHighLightedClass = function() {
      var _a2 = _this.props, day = _a2.day, highlightDates = _a2.highlightDates;
      if (!highlightDates) {
        return false;
      }
      var dayStr = formatDate(day, "MM.dd.yyyy");
      return highlightDates.get(dayStr);
    };
    _this.getHolidaysClass = function() {
      var _a2;
      var _b = _this.props, day = _b.day, holidays = _b.holidays;
      if (!holidays) {
        return [void 0];
      }
      var dayStr = formatDate(day, "MM.dd.yyyy");
      if (holidays.has(dayStr)) {
        return [(_a2 = holidays.get(dayStr)) === null || _a2 === void 0 ? void 0 : _a2.className];
      }
      return [void 0];
    };
    _this.isInRange = function() {
      var _a2 = _this.props, day = _a2.day, startDate = _a2.startDate, endDate = _a2.endDate;
      if (!startDate || !endDate) {
        return false;
      }
      return isDayInRange(day, startDate, endDate);
    };
    _this.isInSelectingRange = function() {
      var _a2;
      var _b = _this.props, day = _b.day, selectsStart = _b.selectsStart, selectsEnd = _b.selectsEnd, selectsRange = _b.selectsRange, selectsDisabledDaysInRange = _b.selectsDisabledDaysInRange, startDate = _b.startDate, endDate = _b.endDate;
      var selectingDate = (_a2 = _this.props.selectingDate) !== null && _a2 !== void 0 ? _a2 : _this.props.preSelection;
      if (!(selectsStart || selectsEnd || selectsRange) || !selectingDate || !selectsDisabledDaysInRange && _this.isDisabled()) {
        return false;
      }
      if (selectsStart && endDate && (isBefore(selectingDate, endDate) || isEqual(selectingDate, endDate))) {
        return isDayInRange(day, selectingDate, endDate);
      }
      if (selectsEnd && startDate && (isAfter(selectingDate, startDate) || isEqual(selectingDate, startDate))) {
        return isDayInRange(day, startDate, selectingDate);
      }
      if (selectsRange && startDate && !endDate && (isAfter(selectingDate, startDate) || isEqual(selectingDate, startDate))) {
        return isDayInRange(day, startDate, selectingDate);
      }
      return false;
    };
    _this.isSelectingRangeStart = function() {
      var _a2;
      if (!_this.isInSelectingRange()) {
        return false;
      }
      var _b = _this.props, day = _b.day, startDate = _b.startDate, selectsStart = _b.selectsStart;
      var selectingDate = (_a2 = _this.props.selectingDate) !== null && _a2 !== void 0 ? _a2 : _this.props.preSelection;
      if (selectsStart) {
        return isSameDay(day, selectingDate);
      } else {
        return isSameDay(day, startDate);
      }
    };
    _this.isSelectingRangeEnd = function() {
      var _a2;
      if (!_this.isInSelectingRange()) {
        return false;
      }
      var _b = _this.props, day = _b.day, endDate = _b.endDate, selectsEnd = _b.selectsEnd, selectsRange = _b.selectsRange;
      var selectingDate = (_a2 = _this.props.selectingDate) !== null && _a2 !== void 0 ? _a2 : _this.props.preSelection;
      if (selectsEnd || selectsRange) {
        return isSameDay(day, selectingDate);
      } else {
        return isSameDay(day, endDate);
      }
    };
    _this.isRangeStart = function() {
      var _a2 = _this.props, day = _a2.day, startDate = _a2.startDate, endDate = _a2.endDate;
      if (!startDate || !endDate) {
        return false;
      }
      return isSameDay(startDate, day);
    };
    _this.isRangeEnd = function() {
      var _a2 = _this.props, day = _a2.day, startDate = _a2.startDate, endDate = _a2.endDate;
      if (!startDate || !endDate) {
        return false;
      }
      return isSameDay(endDate, day);
    };
    _this.isWeekend = function() {
      var weekday = getDay(_this.props.day);
      return weekday === 0 || weekday === 6;
    };
    _this.isAfterMonth = function() {
      return _this.props.month !== void 0 && (_this.props.month + 1) % 12 === getMonth(_this.props.day);
    };
    _this.isBeforeMonth = function() {
      return _this.props.month !== void 0 && (getMonth(_this.props.day) + 1) % 12 === _this.props.month;
    };
    _this.isCurrentDay = function() {
      return _this.isSameDay(newDate());
    };
    _this.isSelected = function() {
      var _a2;
      if (_this.props.selectsMultiple) {
        return (_a2 = _this.props.selectedDates) === null || _a2 === void 0 ? void 0 : _a2.some(function(date2) {
          return _this.isSameDayOrWeek(date2);
        });
      }
      return _this.isSameDayOrWeek(_this.props.selected);
    };
    _this.getClassNames = function(date2) {
      var dayClassName = _this.props.dayClassName ? _this.props.dayClassName(date2) : void 0;
      return clsx("react-datepicker__day", dayClassName, "react-datepicker__day--" + getDayOfWeekCode(_this.props.day), { "react-datepicker__day--disabled": _this.isDisabled(), "react-datepicker__day--excluded": _this.isExcluded(), "react-datepicker__day--selected": _this.isSelected(), "react-datepicker__day--keyboard-selected": _this.isKeyboardSelected(), "react-datepicker__day--range-start": _this.isRangeStart(), "react-datepicker__day--range-end": _this.isRangeEnd(), "react-datepicker__day--in-range": _this.isInRange(), "react-datepicker__day--in-selecting-range": _this.isInSelectingRange(), "react-datepicker__day--selecting-range-start": _this.isSelectingRangeStart(), "react-datepicker__day--selecting-range-end": _this.isSelectingRangeEnd(), "react-datepicker__day--today": _this.isCurrentDay(), "react-datepicker__day--weekend": _this.isWeekend(), "react-datepicker__day--outside-month": _this.isAfterMonth() || _this.isBeforeMonth() }, _this.getHighLightedClass(), _this.getHolidaysClass());
    };
    _this.getAriaLabel = function() {
      var _a2 = _this.props, day = _a2.day, _b = _a2.ariaLabelPrefixWhenEnabled, ariaLabelPrefixWhenEnabled = _b === void 0 ? "Choose" : _b, _c = _a2.ariaLabelPrefixWhenDisabled, ariaLabelPrefixWhenDisabled = _c === void 0 ? "Not available" : _c;
      var prefix = _this.isDisabled() || _this.isExcluded() ? ariaLabelPrefixWhenDisabled : ariaLabelPrefixWhenEnabled;
      return "".concat(prefix, " ").concat(formatDate(day, "PPPP", _this.props.locale));
    };
    _this.getTitle = function() {
      var _a2 = _this.props, day = _a2.day, _b = _a2.holidays, holidays = _b === void 0 ? /* @__PURE__ */ new Map() : _b, excludeDates = _a2.excludeDates;
      var compareDt = formatDate(day, "MM.dd.yyyy");
      var titles = [];
      if (holidays.has(compareDt)) {
        titles.push.apply(titles, holidays.get(compareDt).holidayNames);
      }
      if (_this.isExcluded()) {
        titles.push(excludeDates === null || excludeDates === void 0 ? void 0 : excludeDates.filter(function(excludeDate) {
          if (excludeDate instanceof Date) {
            return isSameDay(excludeDate, day);
          }
          return isSameDay(excludeDate === null || excludeDate === void 0 ? void 0 : excludeDate.date, day);
        }).map(function(excludeDate) {
          if (excludeDate instanceof Date) {
            return void 0;
          }
          return excludeDate === null || excludeDate === void 0 ? void 0 : excludeDate.message;
        }));
      }
      return titles.join(", ");
    };
    _this.getTabIndex = function() {
      var selectedDay = _this.props.selected;
      var preSelectionDay = _this.props.preSelection;
      var tabIndex = !(_this.props.showWeekPicker && (_this.props.showWeekNumber || !_this.isStartOfWeek())) && (_this.isKeyboardSelected() || _this.isSameDay(selectedDay) && isSameDay(preSelectionDay, selectedDay)) ? 0 : -1;
      return tabIndex;
    };
    _this.handleFocusDay = function() {
      var _a2;
      _this.shouldFocusDay() && ((_a2 = _this.dayEl.current) === null || _a2 === void 0 ? void 0 : _a2.focus({ preventScroll: true }));
    };
    _this.renderDayContents = function() {
      if (_this.props.monthShowsDuplicateDaysEnd && _this.isAfterMonth())
        return null;
      if (_this.props.monthShowsDuplicateDaysStart && _this.isBeforeMonth())
        return null;
      return _this.props.renderDayContents ? _this.props.renderDayContents(getDate(_this.props.day), _this.props.day) : getDate(_this.props.day);
    };
    _this.render = function() {
      return /* @__PURE__ */ jsxs("div", { ref: _this.dayEl, className: _this.getClassNames(_this.props.day), onKeyDown: _this.handleOnKeyDown, onClick: _this.handleClick, onMouseEnter: !_this.props.usePointerEvent ? _this.handleMouseEnter : void 0, onPointerEnter: _this.props.usePointerEvent ? _this.handleMouseEnter : void 0, tabIndex: _this.getTabIndex(), "aria-label": _this.getAriaLabel(), role: "option", title: _this.getTitle(), "aria-disabled": _this.isDisabled(), "aria-current": _this.isCurrentDay() ? "date" : void 0, "aria-selected": _this.isSelected() || _this.isInRange(), children: [_this.renderDayContents(), _this.getTitle() !== "" && /* @__PURE__ */ jsx("span", { className: "overlay", children: _this.getTitle() })] });
    };
    return _this;
  }
  Day2.prototype.componentDidMount = function() {
    this.handleFocusDay();
  };
  Day2.prototype.componentDidUpdate = function() {
    this.handleFocusDay();
  };
  Day2.prototype.shouldFocusDay = function() {
    var shouldFocusDay = false;
    if (this.getTabIndex() === 0 && this.isSameDay(this.props.preSelection)) {
      if (!document.activeElement || document.activeElement === document.body) {
        shouldFocusDay = true;
      }
      if (this.props.inline && !this.props.shouldFocusDayInline) {
        shouldFocusDay = false;
      }
      if (this.isDayActiveElement()) {
        shouldFocusDay = true;
      }
      if (this.isDuplicateDay()) {
        shouldFocusDay = false;
      }
    }
    return shouldFocusDay;
  };
  Day2.prototype.isDayActiveElement = function() {
    var _a2, _b, _c;
    return ((_b = (_a2 = this.props.containerRef) === null || _a2 === void 0 ? void 0 : _a2.current) === null || _b === void 0 ? void 0 : _b.contains(document.activeElement)) && ((_c = document.activeElement) === null || _c === void 0 ? void 0 : _c.classList.contains("react-datepicker__day"));
  };
  Day2.prototype.isDuplicateDay = function() {
    return this.props.monthShowsDuplicateDaysEnd && this.isAfterMonth() || this.props.monthShowsDuplicateDaysStart && this.isBeforeMonth();
  };
  return Day2;
}(Component);
var WeekNumber = function(_super) {
  __extends(WeekNumber2, _super);
  function WeekNumber2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.weekNumberEl = createRef();
    _this.handleClick = function(event) {
      if (_this.props.onClick) {
        _this.props.onClick(event);
      }
    };
    _this.handleOnKeyDown = function(event) {
      var _a2, _b;
      var eventKey = event.key;
      if (eventKey === KeyType.Space) {
        event.preventDefault();
        event.key = KeyType.Enter;
      }
      (_b = (_a2 = _this.props).handleOnKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a2, event);
    };
    _this.isKeyboardSelected = function() {
      return !_this.props.disabledKeyboardNavigation && !isSameDay(_this.props.date, _this.props.selected) && isSameDay(_this.props.date, _this.props.preSelection);
    };
    _this.getTabIndex = function() {
      return _this.props.showWeekPicker && _this.props.showWeekNumber && (_this.isKeyboardSelected() || isSameDay(_this.props.date, _this.props.selected) && isSameDay(_this.props.preSelection, _this.props.selected)) ? 0 : -1;
    };
    _this.handleFocusWeekNumber = function(prevProps) {
      var shouldFocusWeekNumber = false;
      if (_this.getTabIndex() === 0 && !(prevProps === null || prevProps === void 0 ? void 0 : prevProps.isInputFocused) && isSameDay(_this.props.date, _this.props.preSelection)) {
        if (!document.activeElement || document.activeElement === document.body) {
          shouldFocusWeekNumber = true;
        }
        if (_this.props.inline && !_this.props.shouldFocusDayInline) {
          shouldFocusWeekNumber = false;
        }
        if (_this.props.containerRef && _this.props.containerRef.current && _this.props.containerRef.current.contains(document.activeElement) && document.activeElement && document.activeElement.classList.contains("react-datepicker__week-number")) {
          shouldFocusWeekNumber = true;
        }
      }
      shouldFocusWeekNumber && _this.weekNumberEl.current && _this.weekNumberEl.current.focus({ preventScroll: true });
    };
    return _this;
  }
  Object.defineProperty(WeekNumber2, "defaultProps", { get: function() {
    return { ariaLabelPrefix: "week " };
  }, enumerable: false, configurable: true });
  WeekNumber2.prototype.componentDidMount = function() {
    this.handleFocusWeekNumber();
  };
  WeekNumber2.prototype.componentDidUpdate = function(prevProps) {
    this.handleFocusWeekNumber(prevProps);
  };
  WeekNumber2.prototype.render = function() {
    var _a2 = this.props, weekNumber = _a2.weekNumber, _b = _a2.ariaLabelPrefix, ariaLabelPrefix = _b === void 0 ? WeekNumber2.defaultProps.ariaLabelPrefix : _b, onClick = _a2.onClick;
    var weekNumberClasses = { "react-datepicker__week-number": true, "react-datepicker__week-number--clickable": !!onClick, "react-datepicker__week-number--selected": !!onClick && isSameDay(this.props.date, this.props.selected), "react-datepicker__week-number--keyboard-selected": this.isKeyboardSelected() };
    return /* @__PURE__ */ jsx("div", { ref: this.weekNumberEl, className: clsx(weekNumberClasses), "aria-label": "".concat(ariaLabelPrefix, " ").concat(this.props.weekNumber), onClick: this.handleClick, onKeyDown: this.handleOnKeyDown, tabIndex: this.getTabIndex(), children: weekNumber });
  };
  return WeekNumber2;
}(Component);
var Week = function(_super) {
  __extends(Week2, _super);
  function Week2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.isDisabled = function(day) {
      return isDayDisabled(day, { minDate: _this.props.minDate, maxDate: _this.props.maxDate, excludeDates: _this.props.excludeDates, excludeDateIntervals: _this.props.excludeDateIntervals, includeDateIntervals: _this.props.includeDateIntervals, includeDates: _this.props.includeDates, filterDate: _this.props.filterDate });
    };
    _this.handleDayClick = function(day, event) {
      if (_this.props.onDayClick) {
        _this.props.onDayClick(day, event);
      }
    };
    _this.handleDayMouseEnter = function(day) {
      if (_this.props.onDayMouseEnter) {
        _this.props.onDayMouseEnter(day);
      }
    };
    _this.handleWeekClick = function(day, weekNumber, event) {
      var _a2, _b, _c;
      var enabledWeekDay = new Date(day);
      for (var i = 0; i < 7; i++) {
        var processingDay = new Date(day);
        processingDay.setDate(processingDay.getDate() + i);
        var isEnabled = !_this.isDisabled(processingDay);
        if (isEnabled) {
          enabledWeekDay = processingDay;
          break;
        }
      }
      if (typeof _this.props.onWeekSelect === "function") {
        _this.props.onWeekSelect(enabledWeekDay, weekNumber, event);
      }
      if (_this.props.showWeekPicker) {
        _this.handleDayClick(enabledWeekDay, event);
      }
      if ((_a2 = _this.props.shouldCloseOnSelect) !== null && _a2 !== void 0 ? _a2 : Week2.defaultProps.shouldCloseOnSelect) {
        (_c = (_b = _this.props).setOpen) === null || _c === void 0 ? void 0 : _c.call(_b, false);
      }
    };
    _this.formatWeekNumber = function(date2) {
      if (_this.props.formatWeekNumber) {
        return _this.props.formatWeekNumber(date2);
      }
      return getWeek(date2);
    };
    _this.renderDays = function() {
      var startOfWeek2 = _this.startOfWeek();
      var days2 = [];
      var weekNumber = _this.formatWeekNumber(startOfWeek2);
      if (_this.props.showWeekNumber) {
        var onClickAction = _this.props.onWeekSelect || _this.props.showWeekPicker ? _this.handleWeekClick.bind(_this, startOfWeek2, weekNumber) : void 0;
        days2.push(/* @__PURE__ */ jsx(WeekNumber, { ..._assign({ key: "W" }, Week2.defaultProps, _this.props, { weekNumber, date: startOfWeek2, onClick: onClickAction }) }));
      }
      return days2.concat([0, 1, 2, 3, 4, 5, 6].map(function(offset2) {
        var day = addDays(startOfWeek2, offset2);
        return /* @__PURE__ */ jsx(Day, { ..._assign({}, Week2.defaultProps, _this.props, { ariaLabelPrefixWhenEnabled: _this.props.chooseDayAriaLabelPrefix, ariaLabelPrefixWhenDisabled: _this.props.disabledDayAriaLabelPrefix, key: day.valueOf(), day, onClick: _this.handleDayClick.bind(_this, day), onMouseEnter: _this.handleDayMouseEnter.bind(_this, day) }) });
      }));
    };
    _this.startOfWeek = function() {
      return getStartOfWeek(_this.props.day, _this.props.locale, _this.props.calendarStartDay);
    };
    _this.isKeyboardSelected = function() {
      return !_this.props.disabledKeyboardNavigation && !isSameDay(_this.startOfWeek(), _this.props.selected) && isSameDay(_this.startOfWeek(), _this.props.preSelection);
    };
    return _this;
  }
  Object.defineProperty(Week2, "defaultProps", { get: function() {
    return { shouldCloseOnSelect: true };
  }, enumerable: false, configurable: true });
  Week2.prototype.render = function() {
    var weekNumberClasses = { "react-datepicker__week": true, "react-datepicker__week--selected": isSameDay(this.startOfWeek(), this.props.selected), "react-datepicker__week--keyboard-selected": this.isKeyboardSelected() };
    return /* @__PURE__ */ jsx("div", { className: clsx(weekNumberClasses), children: this.renderDays() });
  };
  return Week2;
}(Component);
var _a;
var FIXED_HEIGHT_STANDARD_WEEK_COUNT = 6;
var MONTH_COLUMNS_LAYOUT = { TWO_COLUMNS: "two_columns", THREE_COLUMNS: "three_columns", FOUR_COLUMNS: "four_columns" };
var MONTH_COLUMNS = (_a = {}, _a[MONTH_COLUMNS_LAYOUT.TWO_COLUMNS] = { grid: [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9], [10, 11]], verticalNavigationOffset: 2 }, _a[MONTH_COLUMNS_LAYOUT.THREE_COLUMNS] = { grid: [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]], verticalNavigationOffset: 3 }, _a[MONTH_COLUMNS_LAYOUT.FOUR_COLUMNS] = { grid: [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]], verticalNavigationOffset: 4 }, _a);
var MONTH_NAVIGATION_HORIZONTAL_OFFSET = 1;
function getMonthColumnsLayout(showFourColumnMonthYearPicker, showTwoColumnMonthYearPicker) {
  if (showFourColumnMonthYearPicker) {
    return MONTH_COLUMNS_LAYOUT.FOUR_COLUMNS;
  }
  if (showTwoColumnMonthYearPicker) {
    return MONTH_COLUMNS_LAYOUT.TWO_COLUMNS;
  }
  return MONTH_COLUMNS_LAYOUT.THREE_COLUMNS;
}
var Month = function(_super) {
  __extends(Month2, _super);
  function Month2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.MONTH_REFS = __spreadArray([], Array(12), true).map(function() {
      return createRef();
    });
    _this.QUARTER_REFS = __spreadArray([], Array(4), true).map(function() {
      return createRef();
    });
    _this.isDisabled = function(day) {
      return isDayDisabled(day, { minDate: _this.props.minDate, maxDate: _this.props.maxDate, excludeDates: _this.props.excludeDates, excludeDateIntervals: _this.props.excludeDateIntervals, includeDateIntervals: _this.props.includeDateIntervals, includeDates: _this.props.includeDates, filterDate: _this.props.filterDate });
    };
    _this.isExcluded = function(day) {
      return isDayExcluded(day, { excludeDates: _this.props.excludeDates, excludeDateIntervals: _this.props.excludeDateIntervals });
    };
    _this.handleDayClick = function(day, event) {
      var _a2, _b;
      (_b = (_a2 = _this.props).onDayClick) === null || _b === void 0 ? void 0 : _b.call(_a2, day, event, _this.props.orderInDisplay);
    };
    _this.handleDayMouseEnter = function(day) {
      var _a2, _b;
      (_b = (_a2 = _this.props).onDayMouseEnter) === null || _b === void 0 ? void 0 : _b.call(_a2, day);
    };
    _this.handleMouseLeave = function() {
      var _a2, _b;
      (_b = (_a2 = _this.props).onMouseLeave) === null || _b === void 0 ? void 0 : _b.call(_a2);
    };
    _this.isRangeStartMonth = function(m2) {
      var _a2 = _this.props, day = _a2.day, startDate = _a2.startDate, endDate = _a2.endDate;
      if (!startDate || !endDate) {
        return false;
      }
      return isSameMonth(setMonth(day, m2), startDate);
    };
    _this.isRangeStartQuarter = function(q2) {
      var _a2 = _this.props, day = _a2.day, startDate = _a2.startDate, endDate = _a2.endDate;
      if (!startDate || !endDate) {
        return false;
      }
      return isSameQuarter(setQuarter(day, q2), startDate);
    };
    _this.isRangeEndMonth = function(m2) {
      var _a2 = _this.props, day = _a2.day, startDate = _a2.startDate, endDate = _a2.endDate;
      if (!startDate || !endDate) {
        return false;
      }
      return isSameMonth(setMonth(day, m2), endDate);
    };
    _this.isRangeEndQuarter = function(q2) {
      var _a2 = _this.props, day = _a2.day, startDate = _a2.startDate, endDate = _a2.endDate;
      if (!startDate || !endDate) {
        return false;
      }
      return isSameQuarter(setQuarter(day, q2), endDate);
    };
    _this.isInSelectingRangeMonth = function(m2) {
      var _a2;
      var _b = _this.props, day = _b.day, selectsStart = _b.selectsStart, selectsEnd = _b.selectsEnd, selectsRange = _b.selectsRange, startDate = _b.startDate, endDate = _b.endDate;
      var selectingDate = (_a2 = _this.props.selectingDate) !== null && _a2 !== void 0 ? _a2 : _this.props.preSelection;
      if (!(selectsStart || selectsEnd || selectsRange) || !selectingDate) {
        return false;
      }
      if (selectsStart && endDate) {
        return isMonthInRange(selectingDate, endDate, m2, day);
      }
      if (selectsEnd && startDate) {
        return isMonthInRange(startDate, selectingDate, m2, day);
      }
      if (selectsRange && startDate && !endDate) {
        return isMonthInRange(startDate, selectingDate, m2, day);
      }
      return false;
    };
    _this.isSelectingMonthRangeStart = function(m2) {
      var _a2;
      if (!_this.isInSelectingRangeMonth(m2)) {
        return false;
      }
      var _b = _this.props, day = _b.day, startDate = _b.startDate, selectsStart = _b.selectsStart;
      var _month = setMonth(day, m2);
      var selectingDate = (_a2 = _this.props.selectingDate) !== null && _a2 !== void 0 ? _a2 : _this.props.preSelection;
      if (selectsStart) {
        return isSameMonth(_month, selectingDate);
      } else {
        return isSameMonth(_month, startDate);
      }
    };
    _this.isSelectingMonthRangeEnd = function(m2) {
      var _a2;
      if (!_this.isInSelectingRangeMonth(m2)) {
        return false;
      }
      var _b = _this.props, day = _b.day, endDate = _b.endDate, selectsEnd = _b.selectsEnd, selectsRange = _b.selectsRange;
      var _month = setMonth(day, m2);
      var selectingDate = (_a2 = _this.props.selectingDate) !== null && _a2 !== void 0 ? _a2 : _this.props.preSelection;
      if (selectsEnd || selectsRange) {
        return isSameMonth(_month, selectingDate);
      } else {
        return isSameMonth(_month, endDate);
      }
    };
    _this.isInSelectingRangeQuarter = function(q2) {
      var _a2;
      var _b = _this.props, day = _b.day, selectsStart = _b.selectsStart, selectsEnd = _b.selectsEnd, selectsRange = _b.selectsRange, startDate = _b.startDate, endDate = _b.endDate;
      var selectingDate = (_a2 = _this.props.selectingDate) !== null && _a2 !== void 0 ? _a2 : _this.props.preSelection;
      if (!(selectsStart || selectsEnd || selectsRange) || !selectingDate) {
        return false;
      }
      if (selectsStart && endDate) {
        return isQuarterInRange(selectingDate, endDate, q2, day);
      }
      if (selectsEnd && startDate) {
        return isQuarterInRange(startDate, selectingDate, q2, day);
      }
      if (selectsRange && startDate && !endDate) {
        return isQuarterInRange(startDate, selectingDate, q2, day);
      }
      return false;
    };
    _this.isWeekInMonth = function(startOfWeek2) {
      var day = _this.props.day;
      var endOfWeek2 = addDays(startOfWeek2, 6);
      return isSameMonth(startOfWeek2, day) || isSameMonth(endOfWeek2, day);
    };
    _this.isCurrentMonth = function(day, m2) {
      return getYear(day) === getYear(newDate()) && m2 === getMonth(newDate());
    };
    _this.isCurrentQuarter = function(day, q2) {
      return getYear(day) === getYear(newDate()) && q2 === getQuarter(newDate());
    };
    _this.isSelectedMonth = function(day, m2, selected) {
      return getMonth(selected) === m2 && getYear(day) === getYear(selected);
    };
    _this.isSelectMonthInList = function(day, m2, selectedDates) {
      return selectedDates.some(function(selectedDate) {
        return _this.isSelectedMonth(day, m2, selectedDate);
      });
    };
    _this.isSelectedQuarter = function(day, q2, selected) {
      return getQuarter(day) === q2 && getYear(day) === getYear(selected);
    };
    _this.renderWeeks = function() {
      var weeks2 = [];
      var isFixedHeight = _this.props.fixedHeight;
      var i = 0;
      var breakAfterNextPush = false;
      var currentWeekStart = getStartOfWeek(getStartOfMonth(_this.props.day), _this.props.locale, _this.props.calendarStartDay);
      var isPreSelected = function(preSelection2) {
        return _this.props.showWeekPicker ? getStartOfWeek(preSelection2, _this.props.locale, _this.props.calendarStartDay) : _this.props.preSelection;
      };
      var isSelected = function(selected2) {
        return _this.props.showWeekPicker ? getStartOfWeek(selected2, _this.props.locale, _this.props.calendarStartDay) : _this.props.selected;
      };
      var selected = _this.props.selected ? isSelected(_this.props.selected) : void 0;
      var preSelection = _this.props.preSelection ? isPreSelected(_this.props.preSelection) : void 0;
      while (true) {
        weeks2.push(/* @__PURE__ */ jsx(Week, { ..._assign({}, _this.props, { ariaLabelPrefix: _this.props.weekAriaLabelPrefix, key: i, day: currentWeekStart, month: getMonth(_this.props.day), onDayClick: _this.handleDayClick, onDayMouseEnter: _this.handleDayMouseEnter, selected, preSelection, showWeekNumber: _this.props.showWeekNumbers }) }));
        if (breakAfterNextPush)
          break;
        i++;
        currentWeekStart = addWeeks(currentWeekStart, 1);
        var isFixedAndFinalWeek = isFixedHeight && i >= FIXED_HEIGHT_STANDARD_WEEK_COUNT;
        var isNonFixedAndOutOfMonth = !isFixedHeight && !_this.isWeekInMonth(currentWeekStart);
        if (isFixedAndFinalWeek || isNonFixedAndOutOfMonth) {
          if (_this.props.peekNextMonth) {
            breakAfterNextPush = true;
          } else {
            break;
          }
        }
      }
      return weeks2;
    };
    _this.onMonthClick = function(event, m2) {
      var _a2 = _this.isMonthDisabledForLabelDate(m2), isDisabled = _a2.isDisabled, labelDate = _a2.labelDate;
      if (isDisabled) {
        return;
      }
      _this.handleDayClick(getStartOfMonth(labelDate), event);
    };
    _this.onMonthMouseEnter = function(m2) {
      var _a2 = _this.isMonthDisabledForLabelDate(m2), isDisabled = _a2.isDisabled, labelDate = _a2.labelDate;
      if (isDisabled) {
        return;
      }
      _this.handleDayMouseEnter(getStartOfMonth(labelDate));
    };
    _this.handleMonthNavigation = function(newMonth, newDate2) {
      var _a2, _b, _c, _d;
      (_b = (_a2 = _this.props).setPreSelection) === null || _b === void 0 ? void 0 : _b.call(_a2, newDate2);
      (_d = (_c = _this.MONTH_REFS[newMonth]) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.focus();
    };
    _this.handleKeyboardNavigation = function(event, eventKey, month) {
      var _a2;
      var _b = _this.props, selected = _b.selected, preSelection = _b.preSelection, setPreSelection = _b.setPreSelection, minDate = _b.minDate, maxDate = _b.maxDate, showFourColumnMonthYearPicker = _b.showFourColumnMonthYearPicker, showTwoColumnMonthYearPicker = _b.showTwoColumnMonthYearPicker;
      if (!preSelection)
        return;
      var monthColumnsLayout = getMonthColumnsLayout(showFourColumnMonthYearPicker, showTwoColumnMonthYearPicker);
      var verticalOffset = _this.getVerticalOffset(monthColumnsLayout);
      var monthsGrid = (_a2 = MONTH_COLUMNS[monthColumnsLayout]) === null || _a2 === void 0 ? void 0 : _a2.grid;
      var calculateNewDateAndMonth = function(eventKey2, date2, month2) {
        var _a3, _b2;
        var newCalculatedDate2 = date2;
        var newCalculatedMonth2 = month2;
        switch (eventKey2) {
          case KeyType.ArrowRight:
            newCalculatedDate2 = addMonths(date2, MONTH_NAVIGATION_HORIZONTAL_OFFSET);
            newCalculatedMonth2 = month2 === 11 ? 0 : month2 + MONTH_NAVIGATION_HORIZONTAL_OFFSET;
            break;
          case KeyType.ArrowLeft:
            newCalculatedDate2 = subMonths(date2, MONTH_NAVIGATION_HORIZONTAL_OFFSET);
            newCalculatedMonth2 = month2 === 0 ? 11 : month2 - MONTH_NAVIGATION_HORIZONTAL_OFFSET;
            break;
          case KeyType.ArrowUp:
            newCalculatedDate2 = subMonths(date2, verticalOffset);
            newCalculatedMonth2 = ((_a3 = monthsGrid === null || monthsGrid === void 0 ? void 0 : monthsGrid[0]) === null || _a3 === void 0 ? void 0 : _a3.includes(month2)) ? month2 + 12 - verticalOffset : month2 - verticalOffset;
            break;
          case KeyType.ArrowDown:
            newCalculatedDate2 = addMonths(date2, verticalOffset);
            newCalculatedMonth2 = ((_b2 = monthsGrid === null || monthsGrid === void 0 ? void 0 : monthsGrid[monthsGrid.length - 1]) === null || _b2 === void 0 ? void 0 : _b2.includes(month2)) ? month2 - 12 + verticalOffset : month2 + verticalOffset;
            break;
        }
        return { newCalculatedDate: newCalculatedDate2, newCalculatedMonth: newCalculatedMonth2 };
      };
      var getNewDateAndMonth = function(eventKey2, selectedDate, month2) {
        var MAX_ITERATIONS = 40;
        var eventKeyCopy = eventKey2;
        var validDateFound = false;
        var iterations = 0;
        var _a3 = calculateNewDateAndMonth(eventKeyCopy, selectedDate, month2), newCalculatedDate2 = _a3.newCalculatedDate, newCalculatedMonth2 = _a3.newCalculatedMonth;
        while (!validDateFound) {
          if (iterations >= MAX_ITERATIONS) {
            newCalculatedDate2 = selectedDate;
            newCalculatedMonth2 = month2;
            break;
          }
          if (minDate && newCalculatedDate2 < minDate) {
            eventKeyCopy = KeyType.ArrowRight;
            var obj = calculateNewDateAndMonth(eventKeyCopy, newCalculatedDate2, newCalculatedMonth2);
            newCalculatedDate2 = obj.newCalculatedDate;
            newCalculatedMonth2 = obj.newCalculatedMonth;
          }
          if (maxDate && newCalculatedDate2 > maxDate) {
            eventKeyCopy = KeyType.ArrowLeft;
            var obj = calculateNewDateAndMonth(eventKeyCopy, newCalculatedDate2, newCalculatedMonth2);
            newCalculatedDate2 = obj.newCalculatedDate;
            newCalculatedMonth2 = obj.newCalculatedMonth;
          }
          if (isMonthYearDisabled(newCalculatedDate2, _this.props)) {
            var obj = calculateNewDateAndMonth(eventKeyCopy, newCalculatedDate2, newCalculatedMonth2);
            newCalculatedDate2 = obj.newCalculatedDate;
            newCalculatedMonth2 = obj.newCalculatedMonth;
          } else {
            validDateFound = true;
          }
          iterations++;
        }
        return { newCalculatedDate: newCalculatedDate2, newCalculatedMonth: newCalculatedMonth2 };
      };
      if (eventKey === KeyType.Enter) {
        if (!_this.isMonthDisabled(month)) {
          _this.onMonthClick(event, month);
          setPreSelection === null || setPreSelection === void 0 ? void 0 : setPreSelection(selected);
        }
        return;
      }
      var _c = getNewDateAndMonth(eventKey, preSelection, month), newCalculatedDate = _c.newCalculatedDate, newCalculatedMonth = _c.newCalculatedMonth;
      switch (eventKey) {
        case KeyType.ArrowRight:
        case KeyType.ArrowLeft:
        case KeyType.ArrowUp:
        case KeyType.ArrowDown:
          _this.handleMonthNavigation(newCalculatedMonth, newCalculatedDate);
          break;
      }
    };
    _this.getVerticalOffset = function(monthColumnsLayout) {
      var _a2, _b;
      return (_b = (_a2 = MONTH_COLUMNS[monthColumnsLayout]) === null || _a2 === void 0 ? void 0 : _a2.verticalNavigationOffset) !== null && _b !== void 0 ? _b : 0;
    };
    _this.onMonthKeyDown = function(event, month) {
      var _a2 = _this.props, disabledKeyboardNavigation = _a2.disabledKeyboardNavigation, handleOnMonthKeyDown = _a2.handleOnMonthKeyDown;
      var eventKey = event.key;
      if (eventKey !== KeyType.Tab) {
        event.preventDefault();
      }
      if (!disabledKeyboardNavigation) {
        _this.handleKeyboardNavigation(event, eventKey, month);
      }
      handleOnMonthKeyDown && handleOnMonthKeyDown(event);
    };
    _this.onQuarterClick = function(event, q2) {
      var labelDate = setQuarter(_this.props.day, q2);
      if (isQuarterDisabled(labelDate, _this.props)) {
        return;
      }
      _this.handleDayClick(getStartOfQuarter(labelDate), event);
    };
    _this.onQuarterMouseEnter = function(q2) {
      var labelDate = setQuarter(_this.props.day, q2);
      if (isQuarterDisabled(labelDate, _this.props)) {
        return;
      }
      _this.handleDayMouseEnter(getStartOfQuarter(labelDate));
    };
    _this.handleQuarterNavigation = function(newQuarter, newDate2) {
      var _a2, _b, _c, _d;
      if (_this.isDisabled(newDate2) || _this.isExcluded(newDate2)) {
        return;
      }
      (_b = (_a2 = _this.props).setPreSelection) === null || _b === void 0 ? void 0 : _b.call(_a2, newDate2);
      (_d = (_c = _this.QUARTER_REFS[newQuarter - 1]) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.focus();
    };
    _this.onQuarterKeyDown = function(event, quarter) {
      var _a2, _b;
      var eventKey = event.key;
      if (!_this.props.disabledKeyboardNavigation) {
        switch (eventKey) {
          case KeyType.Enter:
            _this.onQuarterClick(event, quarter);
            (_b = (_a2 = _this.props).setPreSelection) === null || _b === void 0 ? void 0 : _b.call(_a2, _this.props.selected);
            break;
          case KeyType.ArrowRight:
            if (!_this.props.preSelection) {
              break;
            }
            _this.handleQuarterNavigation(quarter === 4 ? 1 : quarter + 1, addQuarters(_this.props.preSelection, 1));
            break;
          case KeyType.ArrowLeft:
            if (!_this.props.preSelection) {
              break;
            }
            _this.handleQuarterNavigation(quarter === 1 ? 4 : quarter - 1, subQuarters(_this.props.preSelection, 1));
            break;
        }
      }
    };
    _this.isMonthDisabledForLabelDate = function(month) {
      var _a2;
      var _b = _this.props, day = _b.day, minDate = _b.minDate, maxDate = _b.maxDate, excludeDates = _b.excludeDates, includeDates = _b.includeDates;
      var labelDate = setMonth(day, month);
      return { isDisabled: (_a2 = (minDate || maxDate || excludeDates || includeDates) && isMonthDisabled(labelDate, _this.props)) !== null && _a2 !== void 0 ? _a2 : false, labelDate };
    };
    _this.isMonthDisabled = function(month) {
      var isDisabled = _this.isMonthDisabledForLabelDate(month).isDisabled;
      return isDisabled;
    };
    _this.getMonthClassNames = function(m2) {
      var _a2 = _this.props, day = _a2.day, startDate = _a2.startDate, endDate = _a2.endDate, preSelection = _a2.preSelection, monthClassName = _a2.monthClassName;
      var _monthClassName = monthClassName ? monthClassName(setMonth(day, m2)) : void 0;
      var selection = _this.getSelection();
      return clsx("react-datepicker__month-text", "react-datepicker__month-".concat(m2), _monthClassName, { "react-datepicker__month-text--disabled": _this.isMonthDisabled(m2), "react-datepicker__month-text--selected": selection ? _this.isSelectMonthInList(day, m2, selection) : void 0, "react-datepicker__month-text--keyboard-selected": !_this.props.disabledKeyboardNavigation && preSelection && _this.isSelectedMonth(day, m2, preSelection) && !_this.isMonthDisabled(m2), "react-datepicker__month-text--in-selecting-range": _this.isInSelectingRangeMonth(m2), "react-datepicker__month-text--in-range": startDate && endDate ? isMonthInRange(startDate, endDate, m2, day) : void 0, "react-datepicker__month-text--range-start": _this.isRangeStartMonth(m2), "react-datepicker__month-text--range-end": _this.isRangeEndMonth(m2), "react-datepicker__month-text--selecting-range-start": _this.isSelectingMonthRangeStart(m2), "react-datepicker__month-text--selecting-range-end": _this.isSelectingMonthRangeEnd(m2), "react-datepicker__month-text--today": _this.isCurrentMonth(day, m2) });
    };
    _this.getTabIndex = function(m2) {
      if (_this.props.preSelection == null) {
        return "-1";
      }
      var preSelectedMonth = getMonth(_this.props.preSelection);
      var isPreSelectedMonthDisabled = _this.isMonthDisabledForLabelDate(preSelectedMonth).isDisabled;
      var tabIndex = m2 === preSelectedMonth && !(isPreSelectedMonthDisabled || _this.props.disabledKeyboardNavigation) ? "0" : "-1";
      return tabIndex;
    };
    _this.getQuarterTabIndex = function(q2) {
      if (_this.props.preSelection == null) {
        return "-1";
      }
      var preSelectedQuarter = getQuarter(_this.props.preSelection);
      var isCurrentQuarterDisabled = isQuarterDisabled(_this.props.day, _this.props);
      var tabIndex = q2 === preSelectedQuarter && !(isCurrentQuarterDisabled || _this.props.disabledKeyboardNavigation) ? "0" : "-1";
      return tabIndex;
    };
    _this.getAriaLabel = function(month) {
      var _a2 = _this.props, _b = _a2.chooseDayAriaLabelPrefix, chooseDayAriaLabelPrefix = _b === void 0 ? "Choose" : _b, _c = _a2.disabledDayAriaLabelPrefix, disabledDayAriaLabelPrefix = _c === void 0 ? "Not available" : _c, day = _a2.day, locale2 = _a2.locale;
      var labelDate = setMonth(day, month);
      var prefix = _this.isDisabled(labelDate) || _this.isExcluded(labelDate) ? disabledDayAriaLabelPrefix : chooseDayAriaLabelPrefix;
      return "".concat(prefix, " ").concat(formatDate(labelDate, "MMMM yyyy", locale2));
    };
    _this.getQuarterClassNames = function(q2) {
      var _a2 = _this.props, day = _a2.day, startDate = _a2.startDate, endDate = _a2.endDate, selected = _a2.selected, minDate = _a2.minDate, maxDate = _a2.maxDate, excludeDates = _a2.excludeDates, includeDates = _a2.includeDates, filterDate = _a2.filterDate, preSelection = _a2.preSelection, disabledKeyboardNavigation = _a2.disabledKeyboardNavigation;
      var isDisabled = (minDate || maxDate || excludeDates || includeDates || filterDate) && isQuarterDisabled(setQuarter(day, q2), _this.props);
      return clsx("react-datepicker__quarter-text", "react-datepicker__quarter-".concat(q2), { "react-datepicker__quarter-text--disabled": isDisabled, "react-datepicker__quarter-text--selected": selected ? _this.isSelectedQuarter(day, q2, selected) : void 0, "react-datepicker__quarter-text--keyboard-selected": !disabledKeyboardNavigation && preSelection && _this.isSelectedQuarter(day, q2, preSelection) && !isDisabled, "react-datepicker__quarter-text--in-selecting-range": _this.isInSelectingRangeQuarter(q2), "react-datepicker__quarter-text--in-range": startDate && endDate ? isQuarterInRange(startDate, endDate, q2, day) : void 0, "react-datepicker__quarter-text--range-start": _this.isRangeStartQuarter(q2), "react-datepicker__quarter-text--range-end": _this.isRangeEndQuarter(q2) });
    };
    _this.getMonthContent = function(m2) {
      var _a2 = _this.props, showFullMonthYearPicker = _a2.showFullMonthYearPicker, renderMonthContent = _a2.renderMonthContent, locale2 = _a2.locale, day = _a2.day;
      var shortMonthText = getMonthShortInLocale(m2, locale2);
      var fullMonthText = getMonthInLocale(m2, locale2);
      if (renderMonthContent) {
        return renderMonthContent(m2, shortMonthText, fullMonthText, day);
      }
      return showFullMonthYearPicker ? fullMonthText : shortMonthText;
    };
    _this.getQuarterContent = function(q2) {
      var _a2;
      var _b = _this.props, renderQuarterContent = _b.renderQuarterContent, locale2 = _b.locale;
      var shortQuarter = getQuarterShortInLocale(q2, locale2);
      return (_a2 = renderQuarterContent === null || renderQuarterContent === void 0 ? void 0 : renderQuarterContent(q2, shortQuarter)) !== null && _a2 !== void 0 ? _a2 : shortQuarter;
    };
    _this.renderMonths = function() {
      var _a2;
      var _b = _this.props, showTwoColumnMonthYearPicker = _b.showTwoColumnMonthYearPicker, showFourColumnMonthYearPicker = _b.showFourColumnMonthYearPicker, day = _b.day, selected = _b.selected;
      var monthColumns = (_a2 = MONTH_COLUMNS[getMonthColumnsLayout(showFourColumnMonthYearPicker, showTwoColumnMonthYearPicker)]) === null || _a2 === void 0 ? void 0 : _a2.grid;
      return monthColumns === null || monthColumns === void 0 ? void 0 : monthColumns.map(function(month, i) {
        return /* @__PURE__ */ jsx("div", { className: "react-datepicker__month-wrapper", children: month.map(function(m2, j) {
          return /* @__PURE__ */ jsx("div", { ref: _this.MONTH_REFS[m2], onClick: function(event) {
            _this.onMonthClick(event, m2);
          }, onKeyDown: function(event) {
            if (isSpaceKeyDown(event)) {
              event.preventDefault();
              event.key = KeyType.Enter;
            }
            _this.onMonthKeyDown(event, m2);
          }, onMouseEnter: !_this.props.usePointerEvent ? function() {
            return _this.onMonthMouseEnter(m2);
          } : void 0, onPointerEnter: _this.props.usePointerEvent ? function() {
            return _this.onMonthMouseEnter(m2);
          } : void 0, tabIndex: Number(_this.getTabIndex(m2)), className: _this.getMonthClassNames(m2), "aria-disabled": _this.isMonthDisabled(m2), role: "option", "aria-label": _this.getAriaLabel(m2), "aria-current": _this.isCurrentMonth(day, m2) ? "date" : void 0, "aria-selected": selected ? _this.isSelectedMonth(day, m2, selected) : void 0, children: _this.getMonthContent(m2) }, j);
        }) }, i);
      });
    };
    _this.renderQuarters = function() {
      var _a2 = _this.props, day = _a2.day, selected = _a2.selected;
      var quarters = [1, 2, 3, 4];
      return /* @__PURE__ */ jsx("div", { className: "react-datepicker__quarter-wrapper", children: quarters.map(function(q2, j) {
        return /* @__PURE__ */ jsx("div", { ref: _this.QUARTER_REFS[j], role: "option", onClick: function(event) {
          _this.onQuarterClick(event, q2);
        }, onKeyDown: function(event) {
          _this.onQuarterKeyDown(event, q2);
        }, onMouseEnter: !_this.props.usePointerEvent ? function() {
          return _this.onQuarterMouseEnter(q2);
        } : void 0, onPointerEnter: _this.props.usePointerEvent ? function() {
          return _this.onQuarterMouseEnter(q2);
        } : void 0, className: _this.getQuarterClassNames(q2), "aria-selected": selected ? _this.isSelectedQuarter(day, q2, selected) : void 0, tabIndex: Number(_this.getQuarterTabIndex(q2)), "aria-current": _this.isCurrentQuarter(day, q2) ? "date" : void 0, children: _this.getQuarterContent(q2) }, j);
      }) });
    };
    _this.getClassNames = function() {
      var _a2 = _this.props, selectingDate = _a2.selectingDate, selectsStart = _a2.selectsStart, selectsEnd = _a2.selectsEnd, showMonthYearPicker = _a2.showMonthYearPicker, showQuarterYearPicker = _a2.showQuarterYearPicker, showWeekPicker = _a2.showWeekPicker;
      return clsx("react-datepicker__month", { "react-datepicker__month--selecting-range": selectingDate && (selectsStart || selectsEnd) }, { "react-datepicker__monthPicker": showMonthYearPicker }, { "react-datepicker__quarterPicker": showQuarterYearPicker }, { "react-datepicker__weekPicker": showWeekPicker });
    };
    return _this;
  }
  Month2.prototype.getSelection = function() {
    var _a2 = this.props, selected = _a2.selected, selectedDates = _a2.selectedDates, selectsMultiple = _a2.selectsMultiple;
    if (selectsMultiple) {
      return selectedDates;
    }
    if (selected) {
      return [selected];
    }
    return void 0;
  };
  Month2.prototype.render = function() {
    var _a2 = this.props, showMonthYearPicker = _a2.showMonthYearPicker, showQuarterYearPicker = _a2.showQuarterYearPicker, day = _a2.day, _b = _a2.ariaLabelPrefix, ariaLabelPrefix = _b === void 0 ? "Month " : _b;
    var formattedAriaLabelPrefix = ariaLabelPrefix ? ariaLabelPrefix.trim() + " " : "";
    return /* @__PURE__ */ jsx("div", { className: this.getClassNames(), onMouseLeave: !this.props.usePointerEvent ? this.handleMouseLeave : void 0, onPointerLeave: this.props.usePointerEvent ? this.handleMouseLeave : void 0, "aria-label": "".concat(formattedAriaLabelPrefix).concat(formatDate(day, "MMMM, yyyy", this.props.locale)), role: "listbox", children: showMonthYearPicker ? this.renderMonths() : showQuarterYearPicker ? this.renderQuarters() : this.renderWeeks() });
  };
  return Month2;
}(Component);
var MonthDropdownOptions = function(_super) {
  __extends(MonthDropdownOptions2, _super);
  function MonthDropdownOptions2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.isSelectedMonth = function(i) {
      return _this.props.month === i;
    };
    _this.renderOptions = function() {
      return _this.props.monthNames.map(function(month, i) {
        return /* @__PURE__ */ jsxs("div", { className: _this.isSelectedMonth(i) ? "react-datepicker__month-option react-datepicker__month-option--selected_month" : "react-datepicker__month-option", onClick: _this.onChange.bind(_this, i), "aria-selected": _this.isSelectedMonth(i) ? "true" : void 0, children: [_this.isSelectedMonth(i) ? /* @__PURE__ */ jsx("span", { className: "react-datepicker__month-option--selected", children: "\u2713" }) : "", month] }, month);
      });
    };
    _this.onChange = function(month) {
      return _this.props.onChange(month);
    };
    _this.handleClickOutside = function() {
      return _this.props.onCancel();
    };
    return _this;
  }
  MonthDropdownOptions2.prototype.render = function() {
    return /* @__PURE__ */ jsx(ClickOutsideWrapper, { className: "react-datepicker__month-dropdown", onClickOutside: this.handleClickOutside, children: this.renderOptions() });
  };
  return MonthDropdownOptions2;
}(Component);
var MonthDropdown = function(_super) {
  __extends(MonthDropdown2, _super);
  function MonthDropdown2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = { dropdownVisible: false };
    _this.renderSelectOptions = function(monthNames) {
      return monthNames.map(function(m2, i) {
        return /* @__PURE__ */ jsx("option", { value: i, children: m2 }, m2);
      });
    };
    _this.renderSelectMode = function(monthNames) {
      return /* @__PURE__ */ jsx("select", { value: _this.props.month, className: "react-datepicker__month-select", onChange: function(e) {
        return _this.onChange(parseInt(e.target.value));
      }, children: _this.renderSelectOptions(monthNames) });
    };
    _this.renderReadView = function(visible, monthNames) {
      return /* @__PURE__ */ jsxs("div", { style: { visibility: visible ? "visible" : "hidden" }, className: "react-datepicker__month-read-view", onClick: _this.toggleDropdown, children: [/* @__PURE__ */ jsx("span", { className: "react-datepicker__month-read-view--down-arrow" }), /* @__PURE__ */ jsx("span", { className: "react-datepicker__month-read-view--selected-month", children: monthNames[_this.props.month] })] }, "read");
    };
    _this.renderDropdown = function(monthNames) {
      return /* @__PURE__ */ jsx(MonthDropdownOptions, { ..._assign({ key: "dropdown" }, _this.props, { monthNames, onChange: _this.onChange, onCancel: _this.toggleDropdown }) });
    };
    _this.renderScrollMode = function(monthNames) {
      var dropdownVisible = _this.state.dropdownVisible;
      var result = [_this.renderReadView(!dropdownVisible, monthNames)];
      if (dropdownVisible) {
        result.unshift(_this.renderDropdown(monthNames));
      }
      return result;
    };
    _this.onChange = function(month) {
      _this.toggleDropdown();
      if (month !== _this.props.month) {
        _this.props.onChange(month);
      }
    };
    _this.toggleDropdown = function() {
      return _this.setState({ dropdownVisible: !_this.state.dropdownVisible });
    };
    return _this;
  }
  MonthDropdown2.prototype.render = function() {
    var _this = this;
    var monthNames = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(this.props.useShortMonthInDropdown ? function(m2) {
      return getMonthShortInLocale(m2, _this.props.locale);
    } : function(m2) {
      return getMonthInLocale(m2, _this.props.locale);
    });
    var renderedDropdown;
    switch (this.props.dropdownMode) {
      case "scroll":
        renderedDropdown = this.renderScrollMode(monthNames);
        break;
      case "select":
        renderedDropdown = this.renderSelectMode(monthNames);
        break;
    }
    return /* @__PURE__ */ jsx("div", { className: "react-datepicker__month-dropdown-container react-datepicker__month-dropdown-container--".concat(this.props.dropdownMode), children: renderedDropdown });
  };
  return MonthDropdown2;
}(Component);
function generateMonthYears(minDate, maxDate) {
  var list = [];
  var currDate = getStartOfMonth(minDate);
  var lastDate = getStartOfMonth(maxDate);
  while (!isAfter(currDate, lastDate)) {
    list.push(newDate(currDate));
    currDate = addMonths(currDate, 1);
  }
  return list;
}
var MonthYearDropdownOptions = function(_super) {
  __extends(MonthYearDropdownOptions2, _super);
  function MonthYearDropdownOptions2(props) {
    var _this = _super.call(this, props) || this;
    _this.renderOptions = function() {
      return _this.state.monthYearsList.map(function(monthYear) {
        var monthYearPoint = getTime(monthYear);
        var isSameMonthYear = isSameYear(_this.props.date, monthYear) && isSameMonth(_this.props.date, monthYear);
        return /* @__PURE__ */ jsxs("div", { className: isSameMonthYear ? "react-datepicker__month-year-option--selected_month-year" : "react-datepicker__month-year-option", onClick: _this.onChange.bind(_this, monthYearPoint), "aria-selected": isSameMonthYear ? "true" : void 0, children: [isSameMonthYear ? /* @__PURE__ */ jsx("span", { className: "react-datepicker__month-year-option--selected", children: "\u2713" }) : "", formatDate(monthYear, _this.props.dateFormat, _this.props.locale)] }, monthYearPoint);
      });
    };
    _this.onChange = function(monthYear) {
      return _this.props.onChange(monthYear);
    };
    _this.handleClickOutside = function() {
      _this.props.onCancel();
    };
    _this.state = { monthYearsList: generateMonthYears(_this.props.minDate, _this.props.maxDate) };
    return _this;
  }
  MonthYearDropdownOptions2.prototype.render = function() {
    var dropdownClass = clsx({ "react-datepicker__month-year-dropdown": true, "react-datepicker__month-year-dropdown--scrollable": this.props.scrollableMonthYearDropdown });
    return /* @__PURE__ */ jsx(ClickOutsideWrapper, { className: dropdownClass, onClickOutside: this.handleClickOutside, children: this.renderOptions() });
  };
  return MonthYearDropdownOptions2;
}(Component);
var MonthYearDropdown = function(_super) {
  __extends(MonthYearDropdown2, _super);
  function MonthYearDropdown2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = { dropdownVisible: false };
    _this.renderSelectOptions = function() {
      var currDate = getStartOfMonth(_this.props.minDate);
      var lastDate = getStartOfMonth(_this.props.maxDate);
      var options = [];
      while (!isAfter(currDate, lastDate)) {
        var timePoint = getTime(currDate);
        options.push(/* @__PURE__ */ jsx("option", { value: timePoint, children: formatDate(currDate, _this.props.dateFormat, _this.props.locale) }, timePoint));
        currDate = addMonths(currDate, 1);
      }
      return options;
    };
    _this.onSelectChange = function(event) {
      _this.onChange(parseInt(event.target.value));
    };
    _this.renderSelectMode = function() {
      return /* @__PURE__ */ jsx("select", { value: getTime(getStartOfMonth(_this.props.date)), className: "react-datepicker__month-year-select", onChange: _this.onSelectChange, children: _this.renderSelectOptions() });
    };
    _this.renderReadView = function(visible) {
      var yearMonth = formatDate(_this.props.date, _this.props.dateFormat, _this.props.locale);
      return /* @__PURE__ */ jsxs("div", { style: { visibility: visible ? "visible" : "hidden" }, className: "react-datepicker__month-year-read-view", onClick: _this.toggleDropdown, children: [/* @__PURE__ */ jsx("span", { className: "react-datepicker__month-year-read-view--down-arrow" }), /* @__PURE__ */ jsx("span", { className: "react-datepicker__month-year-read-view--selected-month-year", children: yearMonth })] }, "read");
    };
    _this.renderDropdown = function() {
      return /* @__PURE__ */ jsx(MonthYearDropdownOptions, { ..._assign({ key: "dropdown" }, _this.props, { onChange: _this.onChange, onCancel: _this.toggleDropdown }) });
    };
    _this.renderScrollMode = function() {
      var dropdownVisible = _this.state.dropdownVisible;
      var result = [_this.renderReadView(!dropdownVisible)];
      if (dropdownVisible) {
        result.unshift(_this.renderDropdown());
      }
      return result;
    };
    _this.onChange = function(monthYearPoint) {
      _this.toggleDropdown();
      var changedDate = newDate(monthYearPoint);
      if (isSameYear(_this.props.date, changedDate) && isSameMonth(_this.props.date, changedDate)) {
        return;
      }
      _this.props.onChange(changedDate);
    };
    _this.toggleDropdown = function() {
      return _this.setState({ dropdownVisible: !_this.state.dropdownVisible });
    };
    return _this;
  }
  MonthYearDropdown2.prototype.render = function() {
    var renderedDropdown;
    switch (this.props.dropdownMode) {
      case "scroll":
        renderedDropdown = this.renderScrollMode();
        break;
      case "select":
        renderedDropdown = this.renderSelectMode();
        break;
    }
    return /* @__PURE__ */ jsx("div", { className: "react-datepicker__month-year-dropdown-container react-datepicker__month-year-dropdown-container--".concat(this.props.dropdownMode), children: renderedDropdown });
  };
  return MonthYearDropdown2;
}(Component);
var Time = function(_super) {
  __extends(Time2, _super);
  function Time2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = { height: null };
    _this.scrollToTheSelectedTime = function() {
      requestAnimationFrame(function() {
        var _a2, _b, _c;
        if (!_this.list)
          return;
        _this.list.scrollTop = (_c = _this.centerLi && Time2.calcCenterPosition(_this.props.monthRef ? _this.props.monthRef.clientHeight - ((_b = (_a2 = _this.header) === null || _a2 === void 0 ? void 0 : _a2.clientHeight) !== null && _b !== void 0 ? _b : 0) : _this.list.clientHeight, _this.centerLi)) !== null && _c !== void 0 ? _c : 0;
      });
    };
    _this.handleClick = function(time) {
      var _a2, _b;
      if ((_this.props.minTime || _this.props.maxTime) && isTimeInDisabledRange(time, _this.props) || (_this.props.excludeTimes || _this.props.includeTimes || _this.props.filterTime) && isTimeDisabled(time, _this.props)) {
        return;
      }
      (_b = (_a2 = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a2, time);
    };
    _this.isSelectedTime = function(time) {
      return _this.props.selected && isSameMinute(_this.props.selected, time);
    };
    _this.isDisabledTime = function(time) {
      return (_this.props.minTime || _this.props.maxTime) && isTimeInDisabledRange(time, _this.props) || (_this.props.excludeTimes || _this.props.includeTimes || _this.props.filterTime) && isTimeDisabled(time, _this.props);
    };
    _this.liClasses = function(time) {
      var _a2;
      var classes = ["react-datepicker__time-list-item", _this.props.timeClassName ? _this.props.timeClassName(time) : void 0];
      if (_this.isSelectedTime(time)) {
        classes.push("react-datepicker__time-list-item--selected");
      }
      if (_this.isDisabledTime(time)) {
        classes.push("react-datepicker__time-list-item--disabled");
      }
      if (_this.props.injectTimes && (getHours(time) * 3600 + getMinutes(time) * 60 + getSeconds(time)) % (((_a2 = _this.props.intervals) !== null && _a2 !== void 0 ? _a2 : Time2.defaultProps.intervals) * 60) !== 0) {
        classes.push("react-datepicker__time-list-item--injected");
      }
      return classes.join(" ");
    };
    _this.handleOnKeyDown = function(event, time) {
      var _a2, _b;
      if (event.key === KeyType.Space) {
        event.preventDefault();
        event.key = KeyType.Enter;
      }
      if ((event.key === KeyType.ArrowUp || event.key === KeyType.ArrowLeft) && event.target instanceof HTMLElement && event.target.previousSibling) {
        event.preventDefault();
        event.target.previousSibling instanceof HTMLElement && event.target.previousSibling.focus();
      }
      if ((event.key === KeyType.ArrowDown || event.key === KeyType.ArrowRight) && event.target instanceof HTMLElement && event.target.nextSibling) {
        event.preventDefault();
        event.target.nextSibling instanceof HTMLElement && event.target.nextSibling.focus();
      }
      if (event.key === KeyType.Enter) {
        _this.handleClick(time);
      }
      (_b = (_a2 = _this.props).handleOnKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a2, event);
    };
    _this.renderTimes = function() {
      var _a2;
      var times = [];
      var format2 = typeof _this.props.format === "string" ? _this.props.format : "p";
      var intervals = (_a2 = _this.props.intervals) !== null && _a2 !== void 0 ? _a2 : Time2.defaultProps.intervals;
      var activeDate = _this.props.selected || _this.props.openToDate || newDate();
      var base = getStartOfDay(activeDate);
      var sortedInjectTimes = _this.props.injectTimes && _this.props.injectTimes.sort(function(a, b) {
        return a.getTime() - b.getTime();
      });
      var minutesInDay = 60 * getHoursInDay(activeDate);
      var multiplier = minutesInDay / intervals;
      for (var i = 0; i < multiplier; i++) {
        var currentTime = addMinutes(base, i * intervals);
        times.push(currentTime);
        if (sortedInjectTimes) {
          var timesToInject = timesToInjectAfter(base, currentTime, i, intervals, sortedInjectTimes);
          times = times.concat(timesToInject);
        }
      }
      var timeToFocus = times.reduce(function(prev, time) {
        if (time.getTime() <= activeDate.getTime()) {
          return time;
        }
        return prev;
      }, times[0]);
      return times.map(function(time) {
        return /* @__PURE__ */ jsx("li", { onClick: _this.handleClick.bind(_this, time), className: _this.liClasses(time), ref: function(li) {
          if (time === timeToFocus) {
            _this.centerLi = li;
          }
        }, onKeyDown: function(event) {
          _this.handleOnKeyDown(event, time);
        }, tabIndex: time === timeToFocus ? 0 : -1, role: "option", "aria-selected": _this.isSelectedTime(time) ? "true" : void 0, "aria-disabled": _this.isDisabledTime(time) ? "true" : void 0, children: formatDate(time, format2, _this.props.locale) }, time.valueOf());
      });
    };
    _this.renderTimeCaption = function() {
      if (_this.props.showTimeCaption === false) {
        return /* @__PURE__ */ jsx(Fragment, {});
      }
      return /* @__PURE__ */ jsx("div", { className: "react-datepicker__header react-datepicker__header--time ".concat(_this.props.showTimeSelectOnly ? "react-datepicker__header--time--only" : ""), ref: function(header) {
        _this.header = header;
      }, children: /* @__PURE__ */ jsx("div", { className: "react-datepicker-time__header", children: _this.props.timeCaption }) });
    };
    return _this;
  }
  Object.defineProperty(Time2, "defaultProps", { get: function() {
    return { intervals: 30, todayButton: null, timeCaption: "Time", showTimeCaption: true };
  }, enumerable: false, configurable: true });
  Time2.prototype.componentDidMount = function() {
    this.scrollToTheSelectedTime();
    if (this.props.monthRef && this.header) {
      this.setState({ height: this.props.monthRef.clientHeight - this.header.clientHeight });
    }
  };
  Time2.prototype.render = function() {
    var _this = this;
    var _a2;
    var height = this.state.height;
    return /* @__PURE__ */ jsxs("div", { className: "react-datepicker__time-container ".concat(((_a2 = this.props.todayButton) !== null && _a2 !== void 0 ? _a2 : Time2.defaultProps.todayButton) ? "react-datepicker__time-container--with-today-button" : ""), children: [this.renderTimeCaption(), /* @__PURE__ */ jsx("div", { className: "react-datepicker__time", children: /* @__PURE__ */ jsx("div", { className: "react-datepicker__time-box", children: /* @__PURE__ */ jsx("ul", { className: "react-datepicker__time-list", ref: function(list) {
      _this.list = list;
    }, style: height ? { height } : {}, role: "listbox", "aria-label": this.props.timeCaption, children: this.renderTimes() }) }) })] });
  };
  Time2.calcCenterPosition = function(listHeight, centerLiRef) {
    return centerLiRef.offsetTop - (listHeight / 2 - centerLiRef.clientHeight / 2);
  };
  return Time2;
}(Component);
var VERTICAL_NAVIGATION_OFFSET = 3;
var Year = function(_super) {
  __extends(Year2, _super);
  function Year2(props) {
    var _this = _super.call(this, props) || this;
    _this.YEAR_REFS = __spreadArray([], Array(_this.props.yearItemNumber), true).map(function() {
      return createRef();
    });
    _this.isDisabled = function(date2) {
      return isDayDisabled(date2, { minDate: _this.props.minDate, maxDate: _this.props.maxDate, excludeDates: _this.props.excludeDates, includeDates: _this.props.includeDates, filterDate: _this.props.filterDate });
    };
    _this.isExcluded = function(date2) {
      return isDayExcluded(date2, { excludeDates: _this.props.excludeDates });
    };
    _this.selectingDate = function() {
      var _a2;
      return (_a2 = _this.props.selectingDate) !== null && _a2 !== void 0 ? _a2 : _this.props.preSelection;
    };
    _this.updateFocusOnPaginate = function(refIndex) {
      var waitForReRender = function() {
        var _a2, _b;
        (_b = (_a2 = _this.YEAR_REFS[refIndex]) === null || _a2 === void 0 ? void 0 : _a2.current) === null || _b === void 0 ? void 0 : _b.focus();
      };
      window.requestAnimationFrame(waitForReRender);
    };
    _this.handleYearClick = function(day, event) {
      if (_this.props.onDayClick) {
        _this.props.onDayClick(day, event);
      }
    };
    _this.handleYearNavigation = function(newYear, newDate2) {
      var _a2, _b, _c, _d;
      var _e = _this.props, date2 = _e.date, yearItemNumber = _e.yearItemNumber;
      if (date2 === void 0 || yearItemNumber === void 0) {
        return;
      }
      var startPeriod = getYearsPeriod(date2, yearItemNumber).startPeriod;
      if (_this.isDisabled(newDate2) || _this.isExcluded(newDate2)) {
        return;
      }
      (_b = (_a2 = _this.props).setPreSelection) === null || _b === void 0 ? void 0 : _b.call(_a2, newDate2);
      if (newYear - startPeriod < 0) {
        _this.updateFocusOnPaginate(yearItemNumber - (startPeriod - newYear));
      } else if (newYear - startPeriod >= yearItemNumber) {
        _this.updateFocusOnPaginate(Math.abs(yearItemNumber - (newYear - startPeriod)));
      } else
        (_d = (_c = _this.YEAR_REFS[newYear - startPeriod]) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.focus();
    };
    _this.isSameDay = function(y, other) {
      return isSameDay(y, other);
    };
    _this.isCurrentYear = function(y) {
      return y === getYear(newDate());
    };
    _this.isRangeStart = function(y) {
      return _this.props.startDate && _this.props.endDate && isSameYear(setYear(newDate(), y), _this.props.startDate);
    };
    _this.isRangeEnd = function(y) {
      return _this.props.startDate && _this.props.endDate && isSameYear(setYear(newDate(), y), _this.props.endDate);
    };
    _this.isInRange = function(y) {
      return isYearInRange(y, _this.props.startDate, _this.props.endDate);
    };
    _this.isInSelectingRange = function(y) {
      var _a2 = _this.props, selectsStart = _a2.selectsStart, selectsEnd = _a2.selectsEnd, selectsRange = _a2.selectsRange, startDate = _a2.startDate, endDate = _a2.endDate;
      if (!(selectsStart || selectsEnd || selectsRange) || !_this.selectingDate()) {
        return false;
      }
      if (selectsStart && endDate) {
        return isYearInRange(y, _this.selectingDate(), endDate);
      }
      if (selectsEnd && startDate) {
        return isYearInRange(y, startDate, _this.selectingDate());
      }
      if (selectsRange && startDate && !endDate) {
        return isYearInRange(y, startDate, _this.selectingDate());
      }
      return false;
    };
    _this.isSelectingRangeStart = function(y) {
      var _a2;
      if (!_this.isInSelectingRange(y)) {
        return false;
      }
      var _b = _this.props, startDate = _b.startDate, selectsStart = _b.selectsStart;
      var _year = setYear(newDate(), y);
      if (selectsStart) {
        return isSameYear(_year, (_a2 = _this.selectingDate()) !== null && _a2 !== void 0 ? _a2 : null);
      }
      return isSameYear(_year, startDate !== null && startDate !== void 0 ? startDate : null);
    };
    _this.isSelectingRangeEnd = function(y) {
      var _a2;
      if (!_this.isInSelectingRange(y)) {
        return false;
      }
      var _b = _this.props, endDate = _b.endDate, selectsEnd = _b.selectsEnd, selectsRange = _b.selectsRange;
      var _year = setYear(newDate(), y);
      if (selectsEnd || selectsRange) {
        return isSameYear(_year, (_a2 = _this.selectingDate()) !== null && _a2 !== void 0 ? _a2 : null);
      }
      return isSameYear(_year, endDate !== null && endDate !== void 0 ? endDate : null);
    };
    _this.isKeyboardSelected = function(y) {
      if (_this.props.date === void 0 || _this.props.selected == null || _this.props.preSelection == null) {
        return;
      }
      var _a2 = _this.props, minDate = _a2.minDate, maxDate = _a2.maxDate, excludeDates = _a2.excludeDates, includeDates = _a2.includeDates, filterDate = _a2.filterDate;
      var date2 = getStartOfYear(setYear(_this.props.date, y));
      var isDisabled = (minDate || maxDate || excludeDates || includeDates || filterDate) && isYearDisabled(y, _this.props);
      return !_this.props.disabledKeyboardNavigation && !_this.props.inline && !isSameDay(date2, getStartOfYear(_this.props.selected)) && isSameDay(date2, getStartOfYear(_this.props.preSelection)) && !isDisabled;
    };
    _this.onYearClick = function(event, y) {
      var date2 = _this.props.date;
      if (date2 === void 0) {
        return;
      }
      _this.handleYearClick(getStartOfYear(setYear(date2, y)), event);
    };
    _this.onYearKeyDown = function(event, y) {
      var _a2, _b;
      var key = event.key;
      var _c = _this.props, date2 = _c.date, yearItemNumber = _c.yearItemNumber, handleOnKeyDown = _c.handleOnKeyDown;
      if (key !== KeyType.Tab) {
        event.preventDefault();
      }
      if (!_this.props.disabledKeyboardNavigation) {
        switch (key) {
          case KeyType.Enter:
            if (_this.props.selected == null) {
              break;
            }
            _this.onYearClick(event, y);
            (_b = (_a2 = _this.props).setPreSelection) === null || _b === void 0 ? void 0 : _b.call(_a2, _this.props.selected);
            break;
          case KeyType.ArrowRight:
            if (_this.props.preSelection == null) {
              break;
            }
            _this.handleYearNavigation(y + 1, addYears(_this.props.preSelection, 1));
            break;
          case KeyType.ArrowLeft:
            if (_this.props.preSelection == null) {
              break;
            }
            _this.handleYearNavigation(y - 1, subYears(_this.props.preSelection, 1));
            break;
          case KeyType.ArrowUp: {
            if (date2 === void 0 || yearItemNumber === void 0 || _this.props.preSelection == null) {
              break;
            }
            var startPeriod = getYearsPeriod(date2, yearItemNumber).startPeriod;
            var offset2 = VERTICAL_NAVIGATION_OFFSET;
            var newYear = y - offset2;
            if (newYear < startPeriod) {
              var leftOverOffset = yearItemNumber % offset2;
              if (y >= startPeriod && y < startPeriod + leftOverOffset) {
                offset2 = leftOverOffset;
              } else {
                offset2 += leftOverOffset;
              }
              newYear = y - offset2;
            }
            _this.handleYearNavigation(newYear, subYears(_this.props.preSelection, offset2));
            break;
          }
          case KeyType.ArrowDown: {
            if (date2 === void 0 || yearItemNumber === void 0 || _this.props.preSelection == null) {
              break;
            }
            var endPeriod = getYearsPeriod(date2, yearItemNumber).endPeriod;
            var offset2 = VERTICAL_NAVIGATION_OFFSET;
            var newYear = y + offset2;
            if (newYear > endPeriod) {
              var leftOverOffset = yearItemNumber % offset2;
              if (y <= endPeriod && y > endPeriod - leftOverOffset) {
                offset2 = leftOverOffset;
              } else {
                offset2 += leftOverOffset;
              }
              newYear = y + offset2;
            }
            _this.handleYearNavigation(newYear, addYears(_this.props.preSelection, offset2));
            break;
          }
        }
      }
      handleOnKeyDown && handleOnKeyDown(event);
    };
    _this.getYearClassNames = function(y) {
      var _a2 = _this.props, date2 = _a2.date, minDate = _a2.minDate, maxDate = _a2.maxDate, selected = _a2.selected, excludeDates = _a2.excludeDates, includeDates = _a2.includeDates, filterDate = _a2.filterDate, yearClassName = _a2.yearClassName;
      return clsx("react-datepicker__year-text", "react-datepicker__year-".concat(y), date2 ? yearClassName === null || yearClassName === void 0 ? void 0 : yearClassName(setYear(date2, y)) : void 0, { "react-datepicker__year-text--selected": selected ? y === getYear(selected) : void 0, "react-datepicker__year-text--disabled": (minDate || maxDate || excludeDates || includeDates || filterDate) && isYearDisabled(y, _this.props), "react-datepicker__year-text--keyboard-selected": _this.isKeyboardSelected(y), "react-datepicker__year-text--range-start": _this.isRangeStart(y), "react-datepicker__year-text--range-end": _this.isRangeEnd(y), "react-datepicker__year-text--in-range": _this.isInRange(y), "react-datepicker__year-text--in-selecting-range": _this.isInSelectingRange(y), "react-datepicker__year-text--selecting-range-start": _this.isSelectingRangeStart(y), "react-datepicker__year-text--selecting-range-end": _this.isSelectingRangeEnd(y), "react-datepicker__year-text--today": _this.isCurrentYear(y) });
    };
    _this.getYearTabIndex = function(y) {
      if (_this.props.disabledKeyboardNavigation || _this.props.preSelection == null) {
        return "-1";
      }
      var preSelected = getYear(_this.props.preSelection);
      var isPreSelectedYearDisabled = isYearDisabled(y, _this.props);
      return y === preSelected && !isPreSelectedYearDisabled ? "0" : "-1";
    };
    _this.getYearContainerClassNames = function() {
      var _a2 = _this.props, selectingDate = _a2.selectingDate, selectsStart = _a2.selectsStart, selectsEnd = _a2.selectsEnd, selectsRange = _a2.selectsRange;
      return clsx("react-datepicker__year", { "react-datepicker__year--selecting-range": selectingDate && (selectsStart || selectsEnd || selectsRange) });
    };
    _this.getYearContent = function(y) {
      return _this.props.renderYearContent ? _this.props.renderYearContent(y) : y;
    };
    return _this;
  }
  Year2.prototype.render = function() {
    var _this = this;
    var yearsList = [];
    var _a2 = this.props, date2 = _a2.date, yearItemNumber = _a2.yearItemNumber, onYearMouseEnter = _a2.onYearMouseEnter, onYearMouseLeave = _a2.onYearMouseLeave;
    if (date2 === void 0) {
      return null;
    }
    var _b = getYearsPeriod(date2, yearItemNumber), startPeriod = _b.startPeriod, endPeriod = _b.endPeriod;
    var _loop_1 = function(y2) {
      yearsList.push(/* @__PURE__ */ jsx("div", { ref: this_1.YEAR_REFS[y2 - startPeriod], onClick: function(event) {
        _this.onYearClick(event, y2);
      }, onKeyDown: function(event) {
        if (isSpaceKeyDown(event)) {
          event.preventDefault();
          event.key = KeyType.Enter;
        }
        _this.onYearKeyDown(event, y2);
      }, tabIndex: Number(this_1.getYearTabIndex(y2)), className: this_1.getYearClassNames(y2), onMouseEnter: !this_1.props.usePointerEvent ? function(event) {
        return onYearMouseEnter(event, y2);
      } : void 0, onPointerEnter: this_1.props.usePointerEvent ? function(event) {
        return onYearMouseEnter(event, y2);
      } : void 0, onMouseLeave: !this_1.props.usePointerEvent ? function(event) {
        return onYearMouseLeave(event, y2);
      } : void 0, onPointerLeave: this_1.props.usePointerEvent ? function(event) {
        return onYearMouseLeave(event, y2);
      } : void 0, "aria-current": this_1.isCurrentYear(y2) ? "date" : void 0, children: this_1.getYearContent(y2) }, y2));
    };
    var this_1 = this;
    for (var y = startPeriod; y <= endPeriod; y++) {
      _loop_1(y);
    }
    return /* @__PURE__ */ jsx("div", { className: this.getYearContainerClassNames(), children: /* @__PURE__ */ jsx("div", { className: "react-datepicker__year-wrapper", onMouseLeave: !this.props.usePointerEvent ? this.props.clearSelectingDate : void 0, onPointerLeave: this.props.usePointerEvent ? this.props.clearSelectingDate : void 0, children: yearsList }) });
  };
  return Year2;
}(Component);
function generateYears(year, noOfYear, minDate, maxDate) {
  var list = [];
  for (var i = 0; i < 2 * noOfYear + 1; i++) {
    var newYear = year + noOfYear - i;
    var isInRange = true;
    if (minDate) {
      isInRange = getYear(minDate) <= newYear;
    }
    if (maxDate && isInRange) {
      isInRange = getYear(maxDate) >= newYear;
    }
    if (isInRange) {
      list.push(newYear);
    }
  }
  return list;
}
var YearDropdownOptions = function(_super) {
  __extends(YearDropdownOptions2, _super);
  function YearDropdownOptions2(props) {
    var _this = _super.call(this, props) || this;
    _this.renderOptions = function() {
      var selectedYear = _this.props.year;
      var options = _this.state.yearsList.map(function(year) {
        return /* @__PURE__ */ jsxs("div", { className: selectedYear === year ? "react-datepicker__year-option react-datepicker__year-option--selected_year" : "react-datepicker__year-option", onClick: _this.onChange.bind(_this, year), "aria-selected": selectedYear === year ? "true" : void 0, children: [selectedYear === year ? /* @__PURE__ */ jsx("span", { className: "react-datepicker__year-option--selected", children: "\u2713" }) : "", year] }, year);
      });
      var minYear = _this.props.minDate ? getYear(_this.props.minDate) : null;
      var maxYear = _this.props.maxDate ? getYear(_this.props.maxDate) : null;
      if (!maxYear || !_this.state.yearsList.find(function(year) {
        return year === maxYear;
      })) {
        options.unshift(/* @__PURE__ */ jsx("div", { className: "react-datepicker__year-option", onClick: _this.incrementYears, children: /* @__PURE__ */ jsx("a", { className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-upcoming" }) }, "upcoming"));
      }
      if (!minYear || !_this.state.yearsList.find(function(year) {
        return year === minYear;
      })) {
        options.push(/* @__PURE__ */ jsx("div", { className: "react-datepicker__year-option", onClick: _this.decrementYears, children: /* @__PURE__ */ jsx("a", { className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-previous" }) }, "previous"));
      }
      return options;
    };
    _this.onChange = function(year) {
      _this.props.onChange(year);
    };
    _this.handleClickOutside = function() {
      _this.props.onCancel();
    };
    _this.shiftYears = function(amount) {
      var years2 = _this.state.yearsList.map(function(year) {
        return year + amount;
      });
      _this.setState({ yearsList: years2 });
    };
    _this.incrementYears = function() {
      return _this.shiftYears(1);
    };
    _this.decrementYears = function() {
      return _this.shiftYears(-1);
    };
    var yearDropdownItemNumber = props.yearDropdownItemNumber, scrollableYearDropdown = props.scrollableYearDropdown;
    var noOfYear = yearDropdownItemNumber || (scrollableYearDropdown ? 10 : 5);
    _this.state = { yearsList: generateYears(_this.props.year, noOfYear, _this.props.minDate, _this.props.maxDate) };
    _this.dropdownRef = createRef();
    return _this;
  }
  YearDropdownOptions2.prototype.componentDidMount = function() {
    var dropdownCurrent = this.dropdownRef.current;
    if (dropdownCurrent) {
      var dropdownCurrentChildren = dropdownCurrent.children ? Array.from(dropdownCurrent.children) : null;
      var selectedYearOptionEl = dropdownCurrentChildren ? dropdownCurrentChildren.find(function(childEl) {
        return childEl.ariaSelected;
      }) : null;
      dropdownCurrent.scrollTop = selectedYearOptionEl && selectedYearOptionEl instanceof HTMLElement ? selectedYearOptionEl.offsetTop + (selectedYearOptionEl.clientHeight - dropdownCurrent.clientHeight) / 2 : (dropdownCurrent.scrollHeight - dropdownCurrent.clientHeight) / 2;
    }
  };
  YearDropdownOptions2.prototype.render = function() {
    var dropdownClass = clsx({ "react-datepicker__year-dropdown": true, "react-datepicker__year-dropdown--scrollable": this.props.scrollableYearDropdown });
    return /* @__PURE__ */ jsx(ClickOutsideWrapper, { className: dropdownClass, containerRef: this.dropdownRef, onClickOutside: this.handleClickOutside, children: this.renderOptions() });
  };
  return YearDropdownOptions2;
}(Component);
var YearDropdown = function(_super) {
  __extends(YearDropdown2, _super);
  function YearDropdown2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = { dropdownVisible: false };
    _this.renderSelectOptions = function() {
      var minYear = _this.props.minDate ? getYear(_this.props.minDate) : 1900;
      var maxYear = _this.props.maxDate ? getYear(_this.props.maxDate) : 2100;
      var options = [];
      for (var i = minYear; i <= maxYear; i++) {
        options.push(/* @__PURE__ */ jsx("option", { value: i, children: i }, i));
      }
      return options;
    };
    _this.onSelectChange = function(event) {
      _this.onChange(parseInt(event.target.value));
    };
    _this.renderSelectMode = function() {
      return /* @__PURE__ */ jsx("select", { value: _this.props.year, className: "react-datepicker__year-select", onChange: _this.onSelectChange, children: _this.renderSelectOptions() });
    };
    _this.renderReadView = function(visible) {
      return /* @__PURE__ */ jsxs("div", { style: { visibility: visible ? "visible" : "hidden" }, className: "react-datepicker__year-read-view", onClick: function(event) {
        return _this.toggleDropdown(event);
      }, children: [/* @__PURE__ */ jsx("span", { className: "react-datepicker__year-read-view--down-arrow" }), /* @__PURE__ */ jsx("span", { className: "react-datepicker__year-read-view--selected-year", children: _this.props.year })] }, "read");
    };
    _this.renderDropdown = function() {
      return /* @__PURE__ */ jsx(YearDropdownOptions, { ..._assign({ key: "dropdown" }, _this.props, { onChange: _this.onChange, onCancel: _this.toggleDropdown }) });
    };
    _this.renderScrollMode = function() {
      var dropdownVisible = _this.state.dropdownVisible;
      var result = [_this.renderReadView(!dropdownVisible)];
      if (dropdownVisible) {
        result.unshift(_this.renderDropdown());
      }
      return result;
    };
    _this.onChange = function(year) {
      _this.toggleDropdown();
      if (year === _this.props.year)
        return;
      _this.props.onChange(year);
    };
    _this.toggleDropdown = function(event) {
      _this.setState({ dropdownVisible: !_this.state.dropdownVisible }, function() {
        if (_this.props.adjustDateOnChange) {
          _this.handleYearChange(_this.props.date, event);
        }
      });
    };
    _this.handleYearChange = function(date2, event) {
      var _a2;
      (_a2 = _this.onSelect) === null || _a2 === void 0 ? void 0 : _a2.call(_this, date2, event);
      _this.setOpen();
    };
    _this.onSelect = function(date2, event) {
      var _a2, _b;
      (_b = (_a2 = _this.props).onSelect) === null || _b === void 0 ? void 0 : _b.call(_a2, date2, event);
    };
    _this.setOpen = function() {
      var _a2, _b;
      (_b = (_a2 = _this.props).setOpen) === null || _b === void 0 ? void 0 : _b.call(_a2, true);
    };
    return _this;
  }
  YearDropdown2.prototype.render = function() {
    var renderedDropdown;
    switch (this.props.dropdownMode) {
      case "scroll":
        renderedDropdown = this.renderScrollMode();
        break;
      case "select":
        renderedDropdown = this.renderSelectMode();
        break;
    }
    return /* @__PURE__ */ jsx("div", { className: "react-datepicker__year-dropdown-container react-datepicker__year-dropdown-container--".concat(this.props.dropdownMode), children: renderedDropdown });
  };
  return YearDropdown2;
}(Component);
var DROPDOWN_FOCUS_CLASSNAMES = ["react-datepicker__year-select", "react-datepicker__month-select", "react-datepicker__month-year-select"];
var isDropdownSelect = function(element) {
  var classNames = (element.className || "").split(/\s+/);
  return DROPDOWN_FOCUS_CLASSNAMES.some(function(testClassname) {
    return classNames.indexOf(testClassname) >= 0;
  });
};
var Calendar = function(_super) {
  __extends(Calendar2, _super);
  function Calendar2(props) {
    var _this = _super.call(this, props) || this;
    _this.monthContainer = void 0;
    _this.handleClickOutside = function(event) {
      _this.props.onClickOutside(event);
    };
    _this.setClickOutsideRef = function() {
      return _this.containerRef.current;
    };
    _this.handleDropdownFocus = function(event) {
      var _a2, _b;
      if (isDropdownSelect(event.target)) {
        (_b = (_a2 = _this.props).onDropdownFocus) === null || _b === void 0 ? void 0 : _b.call(_a2, event);
      }
    };
    _this.getDateInView = function() {
      var _a2 = _this.props, preSelection = _a2.preSelection, selected = _a2.selected, openToDate = _a2.openToDate;
      var minDate = getEffectiveMinDate(_this.props);
      var maxDate = getEffectiveMaxDate(_this.props);
      var current = newDate();
      var initialDate = openToDate || selected || preSelection;
      if (initialDate) {
        return initialDate;
      } else {
        if (minDate && isBefore(current, minDate)) {
          return minDate;
        } else if (maxDate && isAfter(current, maxDate)) {
          return maxDate;
        }
      }
      return current;
    };
    _this.increaseMonth = function() {
      _this.setState(function(_a2) {
        var date2 = _a2.date;
        return { date: addMonths(date2, 1) };
      }, function() {
        return _this.handleMonthChange(_this.state.date);
      });
    };
    _this.decreaseMonth = function() {
      _this.setState(function(_a2) {
        var date2 = _a2.date;
        return { date: subMonths(date2, 1) };
      }, function() {
        return _this.handleMonthChange(_this.state.date);
      });
    };
    _this.handleDayClick = function(day, event, monthSelectedIn) {
      _this.props.onSelect(day, event, monthSelectedIn);
      _this.props.setPreSelection && _this.props.setPreSelection(day);
    };
    _this.handleDayMouseEnter = function(day) {
      _this.setState({ selectingDate: day });
      _this.props.onDayMouseEnter && _this.props.onDayMouseEnter(day);
    };
    _this.handleMonthMouseLeave = function() {
      _this.setState({ selectingDate: void 0 });
      _this.props.onMonthMouseLeave && _this.props.onMonthMouseLeave();
    };
    _this.handleYearMouseEnter = function(event, year) {
      _this.setState({ selectingDate: setYear(newDate(), year) });
      !!_this.props.onYearMouseEnter && _this.props.onYearMouseEnter(event, year);
    };
    _this.handleYearMouseLeave = function(event, year) {
      !!_this.props.onYearMouseLeave && _this.props.onYearMouseLeave(event, year);
    };
    _this.handleYearChange = function(date2) {
      var _a2, _b, _c, _d;
      (_b = (_a2 = _this.props).onYearChange) === null || _b === void 0 ? void 0 : _b.call(_a2, date2);
      _this.setState({ isRenderAriaLiveMessage: true });
      if (_this.props.adjustDateOnChange) {
        _this.props.onSelect(date2);
        (_d = (_c = _this.props).setOpen) === null || _d === void 0 ? void 0 : _d.call(_c, true);
      }
      _this.props.setPreSelection && _this.props.setPreSelection(date2);
    };
    _this.getEnabledPreSelectionDateForMonth = function(date2) {
      if (!isDayDisabled(date2, _this.props)) {
        return date2;
      }
      var startOfMonth2 = getStartOfMonth(date2);
      var endOfMonth2 = getEndOfMonth(date2);
      var totalDays = differenceInDays(endOfMonth2, startOfMonth2);
      var preSelectedDate = null;
      for (var dayIdx = 0; dayIdx <= totalDays; dayIdx++) {
        var processingDate = addDays(startOfMonth2, dayIdx);
        if (!isDayDisabled(processingDate, _this.props)) {
          preSelectedDate = processingDate;
          break;
        }
      }
      return preSelectedDate;
    };
    _this.handleMonthChange = function(date2) {
      var _a2, _b, _c;
      var enabledPreSelectionDate = (_a2 = _this.getEnabledPreSelectionDateForMonth(date2)) !== null && _a2 !== void 0 ? _a2 : date2;
      _this.handleCustomMonthChange(enabledPreSelectionDate);
      if (_this.props.adjustDateOnChange) {
        _this.props.onSelect(enabledPreSelectionDate);
        (_c = (_b = _this.props).setOpen) === null || _c === void 0 ? void 0 : _c.call(_b, true);
      }
      _this.props.setPreSelection && _this.props.setPreSelection(enabledPreSelectionDate);
    };
    _this.handleCustomMonthChange = function(date2) {
      var _a2, _b;
      (_b = (_a2 = _this.props).onMonthChange) === null || _b === void 0 ? void 0 : _b.call(_a2, date2);
      _this.setState({ isRenderAriaLiveMessage: true });
    };
    _this.handleMonthYearChange = function(date2) {
      _this.handleYearChange(date2);
      _this.handleMonthChange(date2);
    };
    _this.changeYear = function(year) {
      _this.setState(function(_a2) {
        var date2 = _a2.date;
        return { date: setYear(date2, Number(year)) };
      }, function() {
        return _this.handleYearChange(_this.state.date);
      });
    };
    _this.changeMonth = function(month) {
      _this.setState(function(_a2) {
        var date2 = _a2.date;
        return { date: setMonth(date2, Number(month)) };
      }, function() {
        return _this.handleMonthChange(_this.state.date);
      });
    };
    _this.changeMonthYear = function(monthYear) {
      _this.setState(function(_a2) {
        var date2 = _a2.date;
        return { date: setYear(setMonth(date2, getMonth(monthYear)), getYear(monthYear)) };
      }, function() {
        return _this.handleMonthYearChange(_this.state.date);
      });
    };
    _this.header = function(date2) {
      if (date2 === void 0) {
        date2 = _this.state.date;
      }
      var startOfWeek2 = getStartOfWeek(date2, _this.props.locale, _this.props.calendarStartDay);
      var dayNames = [];
      if (_this.props.showWeekNumbers) {
        dayNames.push(/* @__PURE__ */ jsx("div", { className: "react-datepicker__day-name", children: _this.props.weekLabel || "#" }, "W"));
      }
      return dayNames.concat([0, 1, 2, 3, 4, 5, 6].map(function(offset2) {
        var day = addDays(startOfWeek2, offset2);
        var weekDayName = _this.formatWeekday(day, _this.props.locale);
        var weekDayClassName = _this.props.weekDayClassName ? _this.props.weekDayClassName(day) : void 0;
        return /* @__PURE__ */ jsx("div", { "aria-label": formatDate(day, "EEEE", _this.props.locale), className: clsx("react-datepicker__day-name", weekDayClassName), children: weekDayName }, offset2);
      }));
    };
    _this.formatWeekday = function(day, locale2) {
      if (_this.props.formatWeekDay) {
        return getFormattedWeekdayInLocale(day, _this.props.formatWeekDay, locale2);
      }
      return _this.props.useWeekdaysShort ? getWeekdayShortInLocale(day, locale2) : getWeekdayMinInLocale(day, locale2);
    };
    _this.decreaseYear = function() {
      _this.setState(function(_a2) {
        var _b;
        var date2 = _a2.date;
        return { date: subYears(date2, _this.props.showYearPicker ? (_b = _this.props.yearItemNumber) !== null && _b !== void 0 ? _b : Calendar2.defaultProps.yearItemNumber : 1) };
      }, function() {
        return _this.handleYearChange(_this.state.date);
      });
    };
    _this.clearSelectingDate = function() {
      _this.setState({ selectingDate: void 0 });
    };
    _this.renderPreviousButton = function() {
      var _a2;
      if (_this.props.renderCustomHeader) {
        return;
      }
      var allPrevDaysDisabled;
      switch (true) {
        case _this.props.showMonthYearPicker:
          allPrevDaysDisabled = yearDisabledBefore(_this.state.date, _this.props);
          break;
        case _this.props.showYearPicker:
          allPrevDaysDisabled = yearsDisabledBefore(_this.state.date, _this.props);
          break;
        case _this.props.showQuarterYearPicker:
          allPrevDaysDisabled = quarterDisabledBefore(_this.state.date, _this.props);
          break;
        default:
          allPrevDaysDisabled = monthDisabledBefore(_this.state.date, _this.props);
          break;
      }
      if (!((_a2 = _this.props.forceShowMonthNavigation) !== null && _a2 !== void 0 ? _a2 : Calendar2.defaultProps.forceShowMonthNavigation) && !_this.props.showDisabledMonthNavigation && allPrevDaysDisabled || _this.props.showTimeSelectOnly) {
        return;
      }
      var iconClasses = ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--previous"];
      var classes = ["react-datepicker__navigation", "react-datepicker__navigation--previous"];
      var clickHandler = _this.decreaseMonth;
      if (_this.props.showMonthYearPicker || _this.props.showQuarterYearPicker || _this.props.showYearPicker) {
        clickHandler = _this.decreaseYear;
      }
      if (allPrevDaysDisabled && _this.props.showDisabledMonthNavigation) {
        classes.push("react-datepicker__navigation--previous--disabled");
        clickHandler = void 0;
      }
      var isForYear = _this.props.showMonthYearPicker || _this.props.showQuarterYearPicker || _this.props.showYearPicker;
      var _b = _this.props, _c = _b.previousMonthButtonLabel, previousMonthButtonLabel = _c === void 0 ? Calendar2.defaultProps.previousMonthButtonLabel : _c, _d = _b.previousYearButtonLabel, previousYearButtonLabel = _d === void 0 ? Calendar2.defaultProps.previousYearButtonLabel : _d;
      var _e = _this.props, _f = _e.previousMonthAriaLabel, previousMonthAriaLabel = _f === void 0 ? typeof previousMonthButtonLabel === "string" ? previousMonthButtonLabel : "Previous Month" : _f, _g = _e.previousYearAriaLabel, previousYearAriaLabel = _g === void 0 ? typeof previousYearButtonLabel === "string" ? previousYearButtonLabel : "Previous Year" : _g;
      return /* @__PURE__ */ jsx("button", { type: "button", className: classes.join(" "), onClick: clickHandler, onKeyDown: _this.props.handleOnKeyDown, "aria-label": isForYear ? previousYearAriaLabel : previousMonthAriaLabel, children: /* @__PURE__ */ jsx("span", { className: iconClasses.join(" "), children: isForYear ? previousYearButtonLabel : previousMonthButtonLabel }) });
    };
    _this.increaseYear = function() {
      _this.setState(function(_a2) {
        var _b;
        var date2 = _a2.date;
        return { date: addYears(date2, _this.props.showYearPicker ? (_b = _this.props.yearItemNumber) !== null && _b !== void 0 ? _b : Calendar2.defaultProps.yearItemNumber : 1) };
      }, function() {
        return _this.handleYearChange(_this.state.date);
      });
    };
    _this.renderNextButton = function() {
      var _a2;
      if (_this.props.renderCustomHeader) {
        return;
      }
      var allNextDaysDisabled;
      switch (true) {
        case _this.props.showMonthYearPicker:
          allNextDaysDisabled = yearDisabledAfter(_this.state.date, _this.props);
          break;
        case _this.props.showYearPicker:
          allNextDaysDisabled = yearsDisabledAfter(_this.state.date, _this.props);
          break;
        case _this.props.showQuarterYearPicker:
          allNextDaysDisabled = quarterDisabledAfter(_this.state.date, _this.props);
          break;
        default:
          allNextDaysDisabled = monthDisabledAfter(_this.state.date, _this.props);
          break;
      }
      if (!((_a2 = _this.props.forceShowMonthNavigation) !== null && _a2 !== void 0 ? _a2 : Calendar2.defaultProps.forceShowMonthNavigation) && !_this.props.showDisabledMonthNavigation && allNextDaysDisabled || _this.props.showTimeSelectOnly) {
        return;
      }
      var classes = ["react-datepicker__navigation", "react-datepicker__navigation--next"];
      var iconClasses = ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--next"];
      if (_this.props.showTimeSelect) {
        classes.push("react-datepicker__navigation--next--with-time");
      }
      if (_this.props.todayButton) {
        classes.push("react-datepicker__navigation--next--with-today-button");
      }
      var clickHandler = _this.increaseMonth;
      if (_this.props.showMonthYearPicker || _this.props.showQuarterYearPicker || _this.props.showYearPicker) {
        clickHandler = _this.increaseYear;
      }
      if (allNextDaysDisabled && _this.props.showDisabledMonthNavigation) {
        classes.push("react-datepicker__navigation--next--disabled");
        clickHandler = void 0;
      }
      var isForYear = _this.props.showMonthYearPicker || _this.props.showQuarterYearPicker || _this.props.showYearPicker;
      var _b = _this.props, _c = _b.nextMonthButtonLabel, nextMonthButtonLabel = _c === void 0 ? Calendar2.defaultProps.nextMonthButtonLabel : _c, _d = _b.nextYearButtonLabel, nextYearButtonLabel = _d === void 0 ? Calendar2.defaultProps.nextYearButtonLabel : _d;
      var _e = _this.props, _f = _e.nextMonthAriaLabel, nextMonthAriaLabel = _f === void 0 ? typeof nextMonthButtonLabel === "string" ? nextMonthButtonLabel : "Next Month" : _f, _g = _e.nextYearAriaLabel, nextYearAriaLabel = _g === void 0 ? typeof nextYearButtonLabel === "string" ? nextYearButtonLabel : "Next Year" : _g;
      return /* @__PURE__ */ jsx("button", { type: "button", className: classes.join(" "), onClick: clickHandler, onKeyDown: _this.props.handleOnKeyDown, "aria-label": isForYear ? nextYearAriaLabel : nextMonthAriaLabel, children: /* @__PURE__ */ jsx("span", { className: iconClasses.join(" "), children: isForYear ? nextYearButtonLabel : nextMonthButtonLabel }) });
    };
    _this.renderCurrentMonth = function(date2) {
      if (date2 === void 0) {
        date2 = _this.state.date;
      }
      var classes = ["react-datepicker__current-month"];
      if (_this.props.showYearDropdown) {
        classes.push("react-datepicker__current-month--hasYearDropdown");
      }
      if (_this.props.showMonthDropdown) {
        classes.push("react-datepicker__current-month--hasMonthDropdown");
      }
      if (_this.props.showMonthYearDropdown) {
        classes.push("react-datepicker__current-month--hasMonthYearDropdown");
      }
      return /* @__PURE__ */ jsx("h2", { className: classes.join(" "), children: formatDate(date2, _this.props.dateFormat, _this.props.locale) });
    };
    _this.renderYearDropdown = function(overrideHide) {
      if (overrideHide === void 0) {
        overrideHide = false;
      }
      if (!_this.props.showYearDropdown || overrideHide) {
        return;
      }
      return /* @__PURE__ */ jsx(YearDropdown, { ..._assign({}, Calendar2.defaultProps, _this.props, { date: _this.state.date, onChange: _this.changeYear, year: getYear(_this.state.date) }) });
    };
    _this.renderMonthDropdown = function(overrideHide) {
      if (overrideHide === void 0) {
        overrideHide = false;
      }
      if (!_this.props.showMonthDropdown || overrideHide) {
        return;
      }
      return /* @__PURE__ */ jsx(MonthDropdown, { ..._assign({}, Calendar2.defaultProps, _this.props, { month: getMonth(_this.state.date), onChange: _this.changeMonth }) });
    };
    _this.renderMonthYearDropdown = function(overrideHide) {
      if (overrideHide === void 0) {
        overrideHide = false;
      }
      if (!_this.props.showMonthYearDropdown || overrideHide) {
        return;
      }
      return /* @__PURE__ */ jsx(MonthYearDropdown, { ..._assign({}, Calendar2.defaultProps, _this.props, { date: _this.state.date, onChange: _this.changeMonthYear }) });
    };
    _this.handleTodayButtonClick = function(event) {
      _this.props.onSelect(getStartOfToday(), event);
      _this.props.setPreSelection && _this.props.setPreSelection(getStartOfToday());
    };
    _this.renderTodayButton = function() {
      if (!_this.props.todayButton || _this.props.showTimeSelectOnly) {
        return;
      }
      return /* @__PURE__ */ jsx("div", { className: "react-datepicker__today-button", onClick: _this.handleTodayButtonClick, children: _this.props.todayButton });
    };
    _this.renderDefaultHeader = function(_a2) {
      var monthDate = _a2.monthDate, i = _a2.i;
      return /* @__PURE__ */ jsxs("div", { className: "react-datepicker__header ".concat(_this.props.showTimeSelect ? "react-datepicker__header--has-time-select" : ""), children: [_this.renderCurrentMonth(monthDate), /* @__PURE__ */ jsxs("div", { className: "react-datepicker__header__dropdown react-datepicker__header__dropdown--".concat(_this.props.dropdownMode), onFocus: _this.handleDropdownFocus, children: [_this.renderMonthDropdown(i !== 0), _this.renderMonthYearDropdown(i !== 0), _this.renderYearDropdown(i !== 0)] }), /* @__PURE__ */ jsx("div", { className: "react-datepicker__day-names", children: _this.header(monthDate) })] });
    };
    _this.renderCustomHeader = function(headerArgs) {
      var _a2, _b;
      var monthDate = headerArgs.monthDate, i = headerArgs.i;
      if (_this.props.showTimeSelect && !_this.state.monthContainer || _this.props.showTimeSelectOnly) {
        return null;
      }
      var prevMonthButtonDisabled = monthDisabledBefore(_this.state.date, _this.props);
      var nextMonthButtonDisabled = monthDisabledAfter(_this.state.date, _this.props);
      var prevYearButtonDisabled = yearDisabledBefore(_this.state.date, _this.props);
      var nextYearButtonDisabled = yearDisabledAfter(_this.state.date, _this.props);
      var showDayNames = !_this.props.showMonthYearPicker && !_this.props.showQuarterYearPicker && !_this.props.showYearPicker;
      return /* @__PURE__ */ jsxs("div", { className: "react-datepicker__header react-datepicker__header--custom", onFocus: _this.props.onDropdownFocus, children: [(_b = (_a2 = _this.props).renderCustomHeader) === null || _b === void 0 ? void 0 : _b.call(_a2, _assign(_assign({}, _this.state), { customHeaderCount: i, monthDate, changeMonth: _this.changeMonth, changeYear: _this.changeYear, decreaseMonth: _this.decreaseMonth, increaseMonth: _this.increaseMonth, decreaseYear: _this.decreaseYear, increaseYear: _this.increaseYear, prevMonthButtonDisabled, nextMonthButtonDisabled, prevYearButtonDisabled, nextYearButtonDisabled })), showDayNames && /* @__PURE__ */ jsx("div", { className: "react-datepicker__day-names", children: _this.header(monthDate) })] });
    };
    _this.renderYearHeader = function(_a2) {
      var monthDate = _a2.monthDate;
      var _b = _this.props, showYearPicker = _b.showYearPicker, _c = _b.yearItemNumber, yearItemNumber = _c === void 0 ? Calendar2.defaultProps.yearItemNumber : _c;
      var _d = getYearsPeriod(monthDate, yearItemNumber), startPeriod = _d.startPeriod, endPeriod = _d.endPeriod;
      return /* @__PURE__ */ jsx("div", { className: "react-datepicker__header react-datepicker-year-header", children: showYearPicker ? "".concat(startPeriod, " - ").concat(endPeriod) : getYear(monthDate) });
    };
    _this.renderHeader = function(_a2) {
      var monthDate = _a2.monthDate, _b = _a2.i, i = _b === void 0 ? 0 : _b;
      var headerArgs = { monthDate, i };
      switch (true) {
        case _this.props.renderCustomHeader !== void 0:
          return _this.renderCustomHeader(headerArgs);
        case (_this.props.showMonthYearPicker || _this.props.showQuarterYearPicker || _this.props.showYearPicker):
          return _this.renderYearHeader(headerArgs);
        default:
          return _this.renderDefaultHeader(headerArgs);
      }
    };
    _this.renderMonths = function() {
      var _a2, _b;
      if (_this.props.showTimeSelectOnly || _this.props.showYearPicker) {
        return;
      }
      var monthList = [];
      var monthsShown = (_a2 = _this.props.monthsShown) !== null && _a2 !== void 0 ? _a2 : Calendar2.defaultProps.monthsShown;
      var monthsToSubtract = _this.props.showPreviousMonths ? monthsShown - 1 : 0;
      var fromMonthDate = _this.props.showMonthYearPicker || _this.props.showQuarterYearPicker ? addYears(_this.state.date, monthsToSubtract) : subMonths(_this.state.date, monthsToSubtract);
      var monthSelectedIn = (_b = _this.props.monthSelectedIn) !== null && _b !== void 0 ? _b : monthsToSubtract;
      for (var i = 0; i < monthsShown; ++i) {
        var monthsToAdd = i - monthSelectedIn + monthsToSubtract;
        var monthDate = _this.props.showMonthYearPicker || _this.props.showQuarterYearPicker ? addYears(fromMonthDate, monthsToAdd) : addMonths(fromMonthDate, monthsToAdd);
        var monthKey = "month-".concat(i);
        var monthShowsDuplicateDaysEnd = i < monthsShown - 1;
        var monthShowsDuplicateDaysStart = i > 0;
        monthList.push(/* @__PURE__ */ jsxs("div", { ref: function(div) {
          _this.monthContainer = div !== null && div !== void 0 ? div : void 0;
        }, className: "react-datepicker__month-container", children: [_this.renderHeader({ monthDate, i }), /* @__PURE__ */ jsx(Month, { ..._assign({}, Calendar2.defaultProps, _this.props, { ariaLabelPrefix: _this.props.monthAriaLabelPrefix, day: monthDate, onDayClick: _this.handleDayClick, handleOnKeyDown: _this.props.handleOnDayKeyDown, handleOnMonthKeyDown: _this.props.handleOnKeyDown, onDayMouseEnter: _this.handleDayMouseEnter, onMouseLeave: _this.handleMonthMouseLeave, orderInDisplay: i, selectingDate: _this.state.selectingDate, monthShowsDuplicateDaysEnd, monthShowsDuplicateDaysStart }) })] }, monthKey));
      }
      return monthList;
    };
    _this.renderYears = function() {
      if (_this.props.showTimeSelectOnly) {
        return;
      }
      if (_this.props.showYearPicker) {
        return /* @__PURE__ */ jsxs("div", { className: "react-datepicker__year--container", children: [_this.renderHeader({ monthDate: _this.state.date }), /* @__PURE__ */ jsx(Year, { ..._assign({}, Calendar2.defaultProps, _this.props, { selectingDate: _this.state.selectingDate, date: _this.state.date, onDayClick: _this.handleDayClick, clearSelectingDate: _this.clearSelectingDate, onYearMouseEnter: _this.handleYearMouseEnter, onYearMouseLeave: _this.handleYearMouseLeave }) })] });
      }
      return;
    };
    _this.renderTimeSection = function() {
      if (_this.props.showTimeSelect && (_this.state.monthContainer || _this.props.showTimeSelectOnly)) {
        return /* @__PURE__ */ jsx(Time, { ..._assign({}, Calendar2.defaultProps, _this.props, { onChange: _this.props.onTimeChange, format: _this.props.timeFormat, intervals: _this.props.timeIntervals, monthRef: _this.state.monthContainer }) });
      }
      return;
    };
    _this.renderInputTimeSection = function() {
      var time = _this.props.selected ? new Date(_this.props.selected) : void 0;
      var timeValid = time && isValid2(time) && Boolean(_this.props.selected);
      var timeString = timeValid ? "".concat(addZero(time.getHours()), ":").concat(addZero(time.getMinutes())) : "";
      if (_this.props.showTimeInput) {
        return /* @__PURE__ */ jsx(InputTime, { ..._assign({}, Calendar2.defaultProps, _this.props, { date: time, timeString, onChange: _this.props.onTimeChange }) });
      }
      return;
    };
    _this.renderAriaLiveRegion = function() {
      var _a2;
      var _b = getYearsPeriod(_this.state.date, (_a2 = _this.props.yearItemNumber) !== null && _a2 !== void 0 ? _a2 : Calendar2.defaultProps.yearItemNumber), startPeriod = _b.startPeriod, endPeriod = _b.endPeriod;
      var ariaLiveMessage;
      if (_this.props.showYearPicker) {
        ariaLiveMessage = "".concat(startPeriod, " - ").concat(endPeriod);
      } else if (_this.props.showMonthYearPicker || _this.props.showQuarterYearPicker) {
        ariaLiveMessage = getYear(_this.state.date);
      } else {
        ariaLiveMessage = "".concat(getMonthInLocale(getMonth(_this.state.date), _this.props.locale), " ").concat(getYear(_this.state.date));
      }
      return /* @__PURE__ */ jsx("span", { role: "alert", "aria-live": "polite", className: "react-datepicker__aria-live", children: _this.state.isRenderAriaLiveMessage && ariaLiveMessage });
    };
    _this.renderChildren = function() {
      if (_this.props.children) {
        return /* @__PURE__ */ jsx("div", { className: "react-datepicker__children-container", children: _this.props.children });
      }
      return;
    };
    _this.containerRef = createRef();
    _this.state = { date: _this.getDateInView(), selectingDate: void 0, monthContainer: void 0, isRenderAriaLiveMessage: false };
    return _this;
  }
  Object.defineProperty(Calendar2, "defaultProps", { get: function() {
    return { monthsShown: 1, forceShowMonthNavigation: false, timeCaption: "Time", previousYearButtonLabel: "Previous Year", nextYearButtonLabel: "Next Year", previousMonthButtonLabel: "Previous Month", nextMonthButtonLabel: "Next Month", yearItemNumber: DEFAULT_YEAR_ITEM_NUMBER };
  }, enumerable: false, configurable: true });
  Calendar2.prototype.componentDidMount = function() {
    var _this = this;
    if (this.props.showTimeSelect) {
      this.assignMonthContainer = function() {
        _this.setState({ monthContainer: _this.monthContainer });
      }();
    }
  };
  Calendar2.prototype.componentDidUpdate = function(prevProps) {
    var _this = this;
    if (this.props.preSelection && (!isSameDay(this.props.preSelection, prevProps.preSelection) || this.props.monthSelectedIn !== prevProps.monthSelectedIn)) {
      var hasMonthChanged_1 = !isSameMonth(this.state.date, this.props.preSelection);
      this.setState({ date: this.props.preSelection }, function() {
        return hasMonthChanged_1 && _this.handleCustomMonthChange(_this.state.date);
      });
    } else if (this.props.openToDate && !isSameDay(this.props.openToDate, prevProps.openToDate)) {
      this.setState({ date: this.props.openToDate });
    }
  };
  Calendar2.prototype.render = function() {
    var Container = this.props.container || CalendarContainer;
    return /* @__PURE__ */ jsx(ClickOutsideWrapper, { onClickOutside: this.handleClickOutside, style: { display: "contents" }, containerRef: this.containerRef, ignoreClass: this.props.outsideClickIgnoreClass, children: /* @__PURE__ */ jsxs(Container, { className: clsx("react-datepicker", this.props.className, { "react-datepicker--time-only": this.props.showTimeSelectOnly }), showTime: this.props.showTimeSelect || this.props.showTimeInput, showTimeSelectOnly: this.props.showTimeSelectOnly, children: [this.renderAriaLiveRegion(), this.renderPreviousButton(), this.renderNextButton(), this.renderMonths(), this.renderYears(), this.renderTodayButton(), this.renderTimeSection(), this.renderInputTimeSection(), this.renderChildren()] }) });
  };
  return Calendar2;
}(Component);
var CalendarIcon = function(_a2) {
  var icon = _a2.icon, _b = _a2.className, className = _b === void 0 ? "" : _b, onClick = _a2.onClick;
  var defaultClass = "react-datepicker__calendar-icon";
  if (typeof icon === "string") {
    return /* @__PURE__ */ jsx("i", { className: "".concat(defaultClass, " ").concat(icon, " ").concat(className), "aria-hidden": "true", onClick });
  }
  if (React__default.isValidElement(icon)) {
    return React__default.cloneElement(icon, { className: "".concat(icon.props.className || "", " ").concat(defaultClass, " ").concat(className), onClick: function(event) {
      if (typeof icon.props.onClick === "function") {
        icon.props.onClick(event);
      }
      if (typeof onClick === "function") {
        onClick(event);
      }
    } });
  }
  return /* @__PURE__ */ jsx("svg", { className: "".concat(defaultClass, " ").concat(className), xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 448 512", onClick, children: /* @__PURE__ */ jsx("path", { d: "M96 32V64H48C21.5 64 0 85.5 0 112v48H448V112c0-26.5-21.5-48-48-48H352V32c0-17.7-14.3-32-32-32s-32 14.3-32 32V64H160V32c0-17.7-14.3-32-32-32S96 14.3 96 32zM448 192H0V464c0 26.5 21.5 48 48 48H400c26.5 0 48-21.5 48-48V192z" }) });
};
var Portal = function(_super) {
  __extends(Portal2, _super);
  function Portal2(props) {
    var _this = _super.call(this, props) || this;
    _this.portalRoot = null;
    _this.el = document.createElement("div");
    return _this;
  }
  Portal2.prototype.componentDidMount = function() {
    this.portalRoot = (this.props.portalHost || document).getElementById(this.props.portalId);
    if (!this.portalRoot) {
      this.portalRoot = document.createElement("div");
      this.portalRoot.setAttribute("id", this.props.portalId);
      (this.props.portalHost || document.body).appendChild(this.portalRoot);
    }
    this.portalRoot.appendChild(this.el);
  };
  Portal2.prototype.componentWillUnmount = function() {
    if (this.portalRoot) {
      this.portalRoot.removeChild(this.el);
    }
  };
  Portal2.prototype.render = function() {
    return ReactDOM__default.createPortal(this.props.children, this.el);
  };
  return Portal2;
}(Component);
var focusableElementsSelector = "[tabindex], a, button, input, select, textarea";
var focusableFilter = function(node) {
  if (node instanceof HTMLAnchorElement) {
    return node.tabIndex !== -1;
  }
  return !node.disabled && node.tabIndex !== -1;
};
var TabLoop = function(_super) {
  __extends(TabLoop2, _super);
  function TabLoop2(props) {
    var _this = _super.call(this, props) || this;
    _this.getTabChildren = function() {
      var _a2;
      return Array.prototype.slice.call((_a2 = _this.tabLoopRef.current) === null || _a2 === void 0 ? void 0 : _a2.querySelectorAll(focusableElementsSelector), 1, -1).filter(focusableFilter);
    };
    _this.handleFocusStart = function() {
      var tabChildren = _this.getTabChildren();
      tabChildren && tabChildren.length > 1 && tabChildren[tabChildren.length - 1].focus();
    };
    _this.handleFocusEnd = function() {
      var tabChildren = _this.getTabChildren();
      tabChildren && tabChildren.length > 1 && tabChildren[0].focus();
    };
    _this.tabLoopRef = createRef();
    return _this;
  }
  TabLoop2.prototype.render = function() {
    var _a2;
    if (!((_a2 = this.props.enableTabLoop) !== null && _a2 !== void 0 ? _a2 : TabLoop2.defaultProps.enableTabLoop)) {
      return this.props.children;
    }
    return /* @__PURE__ */ jsxs("div", { className: "react-datepicker__tab-loop", ref: this.tabLoopRef, children: [/* @__PURE__ */ jsx("div", { className: "react-datepicker__tab-loop__start", tabIndex: 0, onFocus: this.handleFocusStart }), this.props.children, /* @__PURE__ */ jsx("div", { className: "react-datepicker__tab-loop__end", tabIndex: 0, onFocus: this.handleFocusEnd })] });
  };
  TabLoop2.defaultProps = { enableTabLoop: true };
  return TabLoop2;
}(Component);
function withFloating(Component2) {
  var WithFloating = function(props) {
    var _a2;
    var hidePopper = typeof props.hidePopper === "boolean" ? props.hidePopper : true;
    var arrowRef = useRef(null);
    var floatingProps = useFloating(_assign({ open: !hidePopper, whileElementsMounted: autoUpdate, placement: props.popperPlacement, middleware: __spreadArray([flip({ padding: 15 }), offset(10), arrow({ element: arrowRef })], (_a2 = props.popperModifiers) !== null && _a2 !== void 0 ? _a2 : [], true) }, props.popperProps));
    var componentProps = _assign(_assign({}, props), { hidePopper, popperProps: _assign(_assign({}, floatingProps), { arrowRef }) });
    return /* @__PURE__ */ jsx(Component2, { ..._assign({}, componentProps) });
  };
  return WithFloating;
}
var PopperComponent = function(_super) {
  __extends(PopperComponent2, _super);
  function PopperComponent2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Object.defineProperty(PopperComponent2, "defaultProps", { get: function() {
    return { hidePopper: true };
  }, enumerable: false, configurable: true });
  PopperComponent2.prototype.render = function() {
    var _a2 = this.props, className = _a2.className, wrapperClassName = _a2.wrapperClassName, _b = _a2.hidePopper, hidePopper = _b === void 0 ? PopperComponent2.defaultProps.hidePopper : _b, popperComponent = _a2.popperComponent, targetComponent = _a2.targetComponent, enableTabLoop = _a2.enableTabLoop, popperOnKeyDown = _a2.popperOnKeyDown, portalId = _a2.portalId, portalHost = _a2.portalHost, popperProps = _a2.popperProps, showArrow = _a2.showArrow;
    var popper = void 0;
    if (!hidePopper) {
      var classes = clsx("react-datepicker-popper", className);
      popper = /* @__PURE__ */ jsx(TabLoop, { enableTabLoop, children: /* @__PURE__ */ jsxs("div", { ref: popperProps.refs.setFloating, style: popperProps.floatingStyles, className: classes, "data-placement": popperProps.placement, onKeyDown: popperOnKeyDown, children: [popperComponent, showArrow && /* @__PURE__ */ jsx(FloatingArrow, { ref: popperProps.arrowRef, context: popperProps.context, fill: "currentColor", strokeWidth: 1, height: 8, width: 16, style: { transform: "translateY(-1px)" }, className: "react-datepicker__triangle" })] }) });
    }
    if (this.props.popperContainer) {
      popper = createElement(this.props.popperContainer, {}, popper);
    }
    if (portalId && !hidePopper) {
      popper = /* @__PURE__ */ jsx(Portal, { portalId, portalHost, children: popper });
    }
    var wrapperClasses = clsx("react-datepicker-wrapper", wrapperClassName);
    return /* @__PURE__ */ jsxs(Fragment, { children: [/* @__PURE__ */ jsx("div", { ref: popperProps.refs.setReference, className: wrapperClasses, children: targetComponent }), popper] });
  };
  return PopperComponent2;
}(Component);
var PopperComponent$1 = withFloating(PopperComponent);
var outsideClickIgnoreClass = "react-datepicker-ignore-onclickoutside";
function hasPreSelectionChanged(date1, date2) {
  if (date1 && date2) {
    return getMonth(date1) !== getMonth(date2) || getYear(date1) !== getYear(date2);
  }
  return date1 !== date2;
}
var INPUT_ERR_1 = "Date input not valid.";
var DatePicker = function(_super) {
  __extends(DatePicker2, _super);
  function DatePicker2(props) {
    var _this = _super.call(this, props) || this;
    _this.calendar = null;
    _this.input = null;
    _this.getPreSelection = function() {
      return _this.props.openToDate ? _this.props.openToDate : _this.props.selectsEnd && _this.props.startDate ? _this.props.startDate : _this.props.selectsStart && _this.props.endDate ? _this.props.endDate : newDate();
    };
    _this.modifyHolidays = function() {
      var _a2;
      return (_a2 = _this.props.holidays) === null || _a2 === void 0 ? void 0 : _a2.reduce(function(accumulator, holiday) {
        var date2 = new Date(holiday.date);
        if (!isValid2(date2)) {
          return accumulator;
        }
        return __spreadArray(__spreadArray([], accumulator, true), [_assign(_assign({}, holiday), { date: date2 })], false);
      }, []);
    };
    _this.calcInitialState = function() {
      var _a2;
      var defaultPreSelection = _this.getPreSelection();
      var minDate = getEffectiveMinDate(_this.props);
      var maxDate = getEffectiveMaxDate(_this.props);
      var boundedPreSelection = minDate && isBefore(defaultPreSelection, getStartOfDay(minDate)) ? minDate : maxDate && isAfter(defaultPreSelection, getEndOfDay(maxDate)) ? maxDate : defaultPreSelection;
      return {
        open: _this.props.startOpen || false,
        preventFocus: false,
        inputValue: null,
        preSelection: (_a2 = _this.props.selectsRange ? _this.props.startDate : _this.props.selected) !== null && _a2 !== void 0 ? _a2 : boundedPreSelection,
        highlightDates: getHighLightDaysMap(_this.props.highlightDates),
        focused: false,
        shouldFocusDayInline: false,
        isRenderAriaLiveMessage: false,
        wasHidden: false
      };
    };
    _this.resetHiddenStatus = function() {
      _this.setState(_assign(_assign({}, _this.state), { wasHidden: false }));
    };
    _this.setHiddenStatus = function() {
      _this.setState(_assign(_assign({}, _this.state), { wasHidden: true }));
    };
    _this.setHiddenStateOnVisibilityHidden = function() {
      if (document.visibilityState !== "hidden") {
        return;
      }
      _this.setHiddenStatus();
    };
    _this.clearPreventFocusTimeout = function() {
      if (_this.preventFocusTimeout) {
        clearTimeout(_this.preventFocusTimeout);
      }
    };
    _this.setFocus = function() {
      if (_this.input && _this.input.focus) {
        _this.input.focus({ preventScroll: true });
      }
    };
    _this.setBlur = function() {
      if (_this.input && _this.input.blur) {
        _this.input.blur();
      }
      _this.cancelFocusInput();
    };
    _this.setOpen = function(open, skipSetBlur) {
      if (skipSetBlur === void 0) {
        skipSetBlur = false;
      }
      _this.setState({ open, preSelection: open && _this.state.open ? _this.state.preSelection : _this.calcInitialState().preSelection, lastPreSelectChange: PRESELECT_CHANGE_VIA_NAVIGATE }, function() {
        if (!open) {
          _this.setState(function(prev) {
            return { focused: skipSetBlur ? prev.focused : false };
          }, function() {
            !skipSetBlur && _this.setBlur();
            _this.setState({ inputValue: null });
          });
        }
      });
    };
    _this.inputOk = function() {
      return isDate(_this.state.preSelection);
    };
    _this.isCalendarOpen = function() {
      return _this.props.open === void 0 ? _this.state.open && !_this.props.disabled && !_this.props.readOnly : _this.props.open;
    };
    _this.handleFocus = function(event) {
      var _a2, _b;
      var isAutoReFocus = _this.state.wasHidden;
      var isOpenAllowed = isAutoReFocus ? _this.state.open : true;
      if (isAutoReFocus) {
        _this.resetHiddenStatus();
      }
      if (!_this.state.preventFocus && isOpenAllowed) {
        (_b = (_a2 = _this.props).onFocus) === null || _b === void 0 ? void 0 : _b.call(_a2, event);
        if (!_this.props.preventOpenOnFocus && !_this.props.readOnly) {
          _this.setOpen(true);
        }
      }
      _this.setState({ focused: true });
    };
    _this.sendFocusBackToInput = function() {
      if (_this.preventFocusTimeout) {
        _this.clearPreventFocusTimeout();
      }
      _this.setState({ preventFocus: true }, function() {
        _this.preventFocusTimeout = setTimeout(function() {
          _this.setFocus();
          _this.setState({ preventFocus: false });
        });
      });
    };
    _this.cancelFocusInput = function() {
      clearTimeout(_this.inputFocusTimeout);
      _this.inputFocusTimeout = void 0;
    };
    _this.deferFocusInput = function() {
      _this.cancelFocusInput();
      _this.inputFocusTimeout = setTimeout(function() {
        return _this.setFocus();
      }, 1);
    };
    _this.handleDropdownFocus = function() {
      _this.cancelFocusInput();
    };
    _this.handleBlur = function(event) {
      var _a2, _b;
      if (!_this.state.open || _this.props.withPortal || _this.props.showTimeInput) {
        (_b = (_a2 = _this.props).onBlur) === null || _b === void 0 ? void 0 : _b.call(_a2, event);
      }
      _this.setState({ focused: false });
    };
    _this.handleCalendarClickOutside = function(event) {
      var _a2, _b;
      if (!_this.props.inline) {
        _this.setOpen(false);
      }
      (_b = (_a2 = _this.props).onClickOutside) === null || _b === void 0 ? void 0 : _b.call(_a2, event);
      if (_this.props.withPortal) {
        event.preventDefault();
      }
    };
    _this.handleChange = function() {
      var _a2, _b;
      var allArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        allArgs[_i] = arguments[_i];
      }
      var event = allArgs[0];
      if (_this.props.onChangeRaw) {
        _this.props.onChangeRaw.apply(_this, allArgs);
        if (!event || typeof event.isDefaultPrevented !== "function" || event.isDefaultPrevented()) {
          return;
        }
      }
      _this.setState({ inputValue: (event === null || event === void 0 ? void 0 : event.target) instanceof HTMLInputElement ? event.target.value : null, lastPreSelectChange: PRESELECT_CHANGE_VIA_INPUT });
      var _c = _this.props, _d = _c.dateFormat, dateFormat = _d === void 0 ? DatePicker2.defaultProps.dateFormat : _d, _e = _c.strictParsing, strictParsing = _e === void 0 ? DatePicker2.defaultProps.strictParsing : _e, selectsRange = _c.selectsRange, startDate = _c.startDate, endDate = _c.endDate;
      var value = (event === null || event === void 0 ? void 0 : event.target) instanceof HTMLInputElement ? event.target.value : "";
      if (selectsRange) {
        var _f = value.split("-", 2).map(function(val) {
          return val.trim();
        }), valueStart = _f[0], valueEnd = _f[1];
        var startDateNew = parseDate(valueStart !== null && valueStart !== void 0 ? valueStart : "", dateFormat, _this.props.locale, strictParsing);
        var endDateNew = parseDate(valueEnd !== null && valueEnd !== void 0 ? valueEnd : "", dateFormat, _this.props.locale, strictParsing);
        var startChanged = (startDate === null || startDate === void 0 ? void 0 : startDate.getTime()) !== (startDateNew === null || startDateNew === void 0 ? void 0 : startDateNew.getTime());
        var endChanged = (endDate === null || endDate === void 0 ? void 0 : endDate.getTime()) !== (endDateNew === null || endDateNew === void 0 ? void 0 : endDateNew.getTime());
        if (!startChanged && !endChanged) {
          return;
        }
        if (startDateNew && isDayDisabled(startDateNew, _this.props)) {
          return;
        }
        if (endDateNew && isDayDisabled(endDateNew, _this.props)) {
          return;
        }
        (_b = (_a2 = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a2, [startDateNew, endDateNew], event);
      } else {
        var date2 = parseDate(value, dateFormat, _this.props.locale, strictParsing, _this.props.minDate);
        if (_this.props.showTimeSelectOnly && _this.props.selected && date2 && !isSameDay(date2, _this.props.selected)) {
          date2 = set4(_this.props.selected, { hours: getHours(date2), minutes: getMinutes(date2), seconds: getSeconds(date2) });
        }
        if (date2 || !value) {
          _this.setSelected(date2, event, true);
        }
      }
    };
    _this.handleSelect = function(date2, event, monthSelectedIn) {
      if (_this.props.shouldCloseOnSelect && !_this.props.showTimeSelect) {
        _this.sendFocusBackToInput();
      }
      if (_this.props.onChangeRaw) {
        _this.props.onChangeRaw(event);
      }
      _this.setSelected(date2, event, false, monthSelectedIn);
      if (_this.props.showDateSelect) {
        _this.setState({ isRenderAriaLiveMessage: true });
      }
      if (!_this.props.shouldCloseOnSelect || _this.props.showTimeSelect) {
        _this.setPreSelection(date2);
      } else if (!_this.props.inline) {
        if (!_this.props.selectsRange) {
          _this.setOpen(false);
        }
        var _a2 = _this.props, startDate = _a2.startDate, endDate = _a2.endDate;
        if (startDate && !endDate && (_this.props.swapRange || !isDateBefore(date2, startDate))) {
          _this.setOpen(false);
        }
      }
    };
    _this.setSelected = function(date2, event, keepInput, monthSelectedIn) {
      var _a2, _b;
      var changedDate = date2;
      if (_this.props.showYearPicker) {
        if (changedDate !== null && isYearDisabled(getYear(changedDate), _this.props)) {
          return;
        }
      } else if (_this.props.showMonthYearPicker) {
        if (changedDate !== null && isMonthDisabled(changedDate, _this.props)) {
          return;
        }
      } else {
        if (changedDate !== null && isDayDisabled(changedDate, _this.props)) {
          return;
        }
      }
      var _c = _this.props, onChange = _c.onChange, selectsRange = _c.selectsRange, startDate = _c.startDate, endDate = _c.endDate, selectsMultiple = _c.selectsMultiple, selectedDates = _c.selectedDates, minTime = _c.minTime, swapRange = _c.swapRange;
      if (!isEqual(_this.props.selected, changedDate) || _this.props.allowSameDay || selectsRange || selectsMultiple) {
        if (changedDate !== null) {
          if (_this.props.selected && (!keepInput || !_this.props.showTimeSelect && !_this.props.showTimeSelectOnly && !_this.props.showTimeInput)) {
            changedDate = setTime(changedDate, { hour: getHours(_this.props.selected), minute: getMinutes(_this.props.selected), second: getSeconds(_this.props.selected) });
          }
          if (!keepInput && (_this.props.showTimeSelect || _this.props.showTimeSelectOnly)) {
            if (minTime) {
              changedDate = setTime(changedDate, { hour: minTime.getHours(), minute: minTime.getMinutes(), second: minTime.getSeconds() });
            }
          }
          if (!_this.props.inline) {
            _this.setState({ preSelection: changedDate });
          }
          if (!_this.props.focusSelectedMonth) {
            _this.setState({ monthSelectedIn });
          }
        }
        if (selectsRange) {
          var noRanges = !startDate && !endDate;
          var hasStartRange = startDate && !endDate;
          var isRangeFilled = startDate && endDate;
          if (noRanges) {
            onChange === null || onChange === void 0 ? void 0 : onChange([changedDate, null], event);
          } else if (hasStartRange) {
            if (changedDate === null) {
              onChange === null || onChange === void 0 ? void 0 : onChange([null, null], event);
            } else if (isDateBefore(changedDate, startDate)) {
              if (swapRange) {
                onChange === null || onChange === void 0 ? void 0 : onChange([changedDate, startDate], event);
              } else {
                onChange === null || onChange === void 0 ? void 0 : onChange([changedDate, null], event);
              }
            } else {
              onChange === null || onChange === void 0 ? void 0 : onChange([startDate, changedDate], event);
            }
          }
          if (isRangeFilled) {
            onChange === null || onChange === void 0 ? void 0 : onChange([changedDate, null], event);
          }
        } else if (selectsMultiple) {
          if (changedDate !== null) {
            if (!(selectedDates === null || selectedDates === void 0 ? void 0 : selectedDates.length)) {
              onChange === null || onChange === void 0 ? void 0 : onChange([changedDate], event);
            } else {
              var isChangedDateAlreadySelected = selectedDates.some(function(selectedDate) {
                return isSameDay(selectedDate, changedDate);
              });
              if (isChangedDateAlreadySelected) {
                var nextDates = selectedDates.filter(function(selectedDate) {
                  return !isSameDay(selectedDate, changedDate);
                });
                onChange === null || onChange === void 0 ? void 0 : onChange(nextDates, event);
              } else {
                onChange === null || onChange === void 0 ? void 0 : onChange(__spreadArray(__spreadArray([], selectedDates, true), [changedDate], false), event);
              }
            }
          }
        } else {
          onChange === null || onChange === void 0 ? void 0 : onChange(changedDate, event);
        }
      }
      if (!keepInput) {
        (_b = (_a2 = _this.props).onSelect) === null || _b === void 0 ? void 0 : _b.call(_a2, changedDate, event);
        _this.setState({ inputValue: null });
      }
    };
    _this.setPreSelection = function(date2) {
      var hasMinDate = isDate(_this.props.minDate);
      var hasMaxDate = isDate(_this.props.maxDate);
      var isValidDateSelection = true;
      if (date2) {
        var dateStartOfDay = getStartOfDay(date2);
        if (hasMinDate && hasMaxDate) {
          isValidDateSelection = isDayInRange(date2, _this.props.minDate, _this.props.maxDate);
        } else if (hasMinDate) {
          var minDateStartOfDay = getStartOfDay(_this.props.minDate);
          isValidDateSelection = isAfter(date2, minDateStartOfDay) || isEqual(dateStartOfDay, minDateStartOfDay);
        } else if (hasMaxDate) {
          var maxDateEndOfDay = getEndOfDay(_this.props.maxDate);
          isValidDateSelection = isBefore(date2, maxDateEndOfDay) || isEqual(dateStartOfDay, maxDateEndOfDay);
        }
      }
      if (isValidDateSelection) {
        _this.setState({ preSelection: date2 });
      }
    };
    _this.toggleCalendar = function() {
      _this.setOpen(!_this.state.open);
    };
    _this.handleTimeChange = function(time) {
      var _a2, _b;
      if (_this.props.selectsRange || _this.props.selectsMultiple) {
        return;
      }
      var selected = _this.props.selected ? _this.props.selected : _this.getPreSelection();
      var changedDate = _this.props.selected ? time : setTime(selected, { hour: getHours(time), minute: getMinutes(time) });
      _this.setState({ preSelection: changedDate });
      (_b = (_a2 = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a2, changedDate);
      if (_this.props.shouldCloseOnSelect && !_this.props.showTimeInput) {
        _this.sendFocusBackToInput();
        _this.setOpen(false);
      }
      if (_this.props.showTimeInput) {
        _this.setOpen(true);
      }
      if (_this.props.showTimeSelectOnly || _this.props.showTimeSelect) {
        _this.setState({ isRenderAriaLiveMessage: true });
      }
      _this.setState({ inputValue: null });
    };
    _this.onInputClick = function() {
      var _a2, _b;
      if (!_this.props.disabled && !_this.props.readOnly) {
        _this.setOpen(true);
      }
      (_b = (_a2 = _this.props).onInputClick) === null || _b === void 0 ? void 0 : _b.call(_a2);
    };
    _this.onInputKeyDown = function(event) {
      var _a2, _b, _c, _d, _e, _f;
      (_b = (_a2 = _this.props).onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a2, event);
      var eventKey = event.key;
      if (!_this.state.open && !_this.props.inline && !_this.props.preventOpenOnFocus) {
        if (eventKey === KeyType.ArrowDown || eventKey === KeyType.ArrowUp || eventKey === KeyType.Enter) {
          (_c = _this.onInputClick) === null || _c === void 0 ? void 0 : _c.call(_this);
        }
        return;
      }
      if (_this.state.open) {
        if (eventKey === KeyType.ArrowDown || eventKey === KeyType.ArrowUp) {
          event.preventDefault();
          var selectorString = _this.props.showTimeSelectOnly ? ".react-datepicker__time-list-item[tabindex='0']" : _this.props.showWeekPicker && _this.props.showWeekNumbers ? '.react-datepicker__week-number[tabindex="0"]' : _this.props.showFullMonthYearPicker || _this.props.showMonthYearPicker ? '.react-datepicker__month-text[tabindex="0"]' : '.react-datepicker__day[tabindex="0"]';
          var selectedItem = ((_d = _this.calendar) === null || _d === void 0 ? void 0 : _d.containerRef.current) instanceof Element && _this.calendar.containerRef.current.querySelector(selectorString);
          selectedItem instanceof HTMLElement && selectedItem.focus({ preventScroll: true });
          return;
        }
        var copy = newDate(_this.state.preSelection);
        if (eventKey === KeyType.Enter) {
          event.preventDefault();
          if (_this.inputOk() && _this.state.lastPreSelectChange === PRESELECT_CHANGE_VIA_NAVIGATE) {
            _this.handleSelect(copy, event);
            !_this.props.shouldCloseOnSelect && _this.setPreSelection(copy);
          } else {
            _this.setOpen(false);
          }
        } else if (eventKey === KeyType.Escape) {
          event.preventDefault();
          _this.sendFocusBackToInput();
          _this.setOpen(false);
        } else if (eventKey === KeyType.Tab) {
          _this.setOpen(false);
        }
        if (!_this.inputOk()) {
          (_f = (_e = _this.props).onInputError) === null || _f === void 0 ? void 0 : _f.call(_e, { code: 1, msg: INPUT_ERR_1 });
        }
      }
    };
    _this.onPortalKeyDown = function(event) {
      var eventKey = event.key;
      if (eventKey === KeyType.Escape) {
        event.preventDefault();
        _this.setState({ preventFocus: true }, function() {
          _this.setOpen(false);
          setTimeout(function() {
            _this.setFocus();
            _this.setState({ preventFocus: false });
          });
        });
      }
    };
    _this.onDayKeyDown = function(event) {
      var _a2, _b, _c, _d, _e, _f;
      var _g = _this.props, minDate = _g.minDate, maxDate = _g.maxDate, disabledKeyboardNavigation = _g.disabledKeyboardNavigation, showWeekPicker = _g.showWeekPicker, shouldCloseOnSelect = _g.shouldCloseOnSelect, locale2 = _g.locale, calendarStartDay = _g.calendarStartDay, adjustDateOnChange = _g.adjustDateOnChange, inline2 = _g.inline;
      (_b = (_a2 = _this.props).onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a2, event);
      if (disabledKeyboardNavigation)
        return;
      var eventKey = event.key;
      var isShiftKeyActive = event.shiftKey;
      var copy = newDate(_this.state.preSelection);
      var calculateNewDate = function(eventKey2, date2) {
        var newCalculatedDate = date2;
        switch (eventKey2) {
          case KeyType.ArrowRight:
            newCalculatedDate = showWeekPicker ? addWeeks(date2, 1) : addDays(date2, 1);
            break;
          case KeyType.ArrowLeft:
            newCalculatedDate = showWeekPicker ? subWeeks(date2, 1) : subDays(date2, 1);
            break;
          case KeyType.ArrowUp:
            newCalculatedDate = subWeeks(date2, 1);
            break;
          case KeyType.ArrowDown:
            newCalculatedDate = addWeeks(date2, 1);
            break;
          case KeyType.PageUp:
            newCalculatedDate = isShiftKeyActive ? subYears(date2, 1) : subMonths(date2, 1);
            break;
          case KeyType.PageDown:
            newCalculatedDate = isShiftKeyActive ? addYears(date2, 1) : addMonths(date2, 1);
            break;
          case KeyType.Home:
            newCalculatedDate = getStartOfWeek(date2, locale2, calendarStartDay);
            break;
          case KeyType.End:
            newCalculatedDate = getEndOfWeek(date2);
            break;
        }
        return newCalculatedDate;
      };
      var getNewDate = function(eventKey2, date2) {
        var MAX_ITERATIONS = 40;
        var eventKeyCopy = eventKey2;
        var validDateFound = false;
        var iterations = 0;
        var newSelection2 = calculateNewDate(eventKey2, date2);
        while (!validDateFound) {
          if (iterations >= MAX_ITERATIONS) {
            newSelection2 = date2;
            break;
          }
          if (minDate && newSelection2 < minDate) {
            eventKeyCopy = KeyType.ArrowRight;
            newSelection2 = isDayDisabled(minDate, _this.props) ? calculateNewDate(eventKeyCopy, newSelection2) : minDate;
          }
          if (maxDate && newSelection2 > maxDate) {
            eventKeyCopy = KeyType.ArrowLeft;
            newSelection2 = isDayDisabled(maxDate, _this.props) ? calculateNewDate(eventKeyCopy, newSelection2) : maxDate;
          }
          if (isDayDisabled(newSelection2, _this.props)) {
            if (eventKeyCopy === KeyType.PageUp || eventKeyCopy === KeyType.Home) {
              eventKeyCopy = KeyType.ArrowRight;
            }
            if (eventKeyCopy === KeyType.PageDown || eventKeyCopy === KeyType.End) {
              eventKeyCopy = KeyType.ArrowLeft;
            }
            newSelection2 = calculateNewDate(eventKeyCopy, newSelection2);
          } else {
            validDateFound = true;
          }
          iterations++;
        }
        return newSelection2;
      };
      if (eventKey === KeyType.Enter) {
        event.preventDefault();
        _this.handleSelect(copy, event);
        !shouldCloseOnSelect && _this.setPreSelection(copy);
        return;
      } else if (eventKey === KeyType.Escape) {
        event.preventDefault();
        _this.setOpen(false);
        if (!_this.inputOk()) {
          (_d = (_c = _this.props).onInputError) === null || _d === void 0 ? void 0 : _d.call(_c, { code: 1, msg: INPUT_ERR_1 });
        }
        return;
      }
      var newSelection = null;
      switch (eventKey) {
        case KeyType.ArrowLeft:
        case KeyType.ArrowRight:
        case KeyType.ArrowUp:
        case KeyType.ArrowDown:
        case KeyType.PageUp:
        case KeyType.PageDown:
        case KeyType.Home:
        case KeyType.End:
          newSelection = getNewDate(eventKey, copy);
          break;
      }
      if (!newSelection) {
        (_f = (_e = _this.props).onInputError) === null || _f === void 0 ? void 0 : _f.call(_e, { code: 1, msg: INPUT_ERR_1 });
        return;
      }
      event.preventDefault();
      _this.setState({ lastPreSelectChange: PRESELECT_CHANGE_VIA_NAVIGATE });
      if (adjustDateOnChange) {
        _this.setSelected(newSelection);
      }
      _this.setPreSelection(newSelection);
      if (inline2) {
        var prevMonth = getMonth(copy);
        var newMonth = getMonth(newSelection);
        var prevYear = getYear(copy);
        var newYear = getYear(newSelection);
        if (prevMonth !== newMonth || prevYear !== newYear) {
          _this.setState({ shouldFocusDayInline: true });
        } else {
          _this.setState({ shouldFocusDayInline: false });
        }
      }
    };
    _this.onPopperKeyDown = function(event) {
      var eventKey = event.key;
      if (eventKey === KeyType.Escape) {
        event.preventDefault();
        _this.sendFocusBackToInput();
      }
    };
    _this.onClearClick = function(event) {
      if (event) {
        if (event.preventDefault) {
          event.preventDefault();
        }
      }
      _this.sendFocusBackToInput();
      var _a2 = _this.props, selectsRange = _a2.selectsRange, onChange = _a2.onChange;
      if (selectsRange) {
        onChange === null || onChange === void 0 ? void 0 : onChange([null, null], event);
      } else {
        onChange === null || onChange === void 0 ? void 0 : onChange(null, event);
      }
      _this.setState({ inputValue: null });
    };
    _this.clear = function() {
      _this.onClearClick();
    };
    _this.onScroll = function(event) {
      if (typeof _this.props.closeOnScroll === "boolean" && _this.props.closeOnScroll) {
        if (event.target === document || event.target === document.documentElement || event.target === document.body) {
          _this.setOpen(false);
        }
      } else if (typeof _this.props.closeOnScroll === "function") {
        if (_this.props.closeOnScroll(event)) {
          _this.setOpen(false);
        }
      }
    };
    _this.renderCalendar = function() {
      var _a2, _b;
      if (!_this.props.inline && !_this.isCalendarOpen()) {
        return null;
      }
      return /* @__PURE__ */ jsx(Calendar, { ..._assign({ showMonthYearDropdown: void 0, ref: function(elem) {
        _this.calendar = elem;
      } }, _this.props, _this.state, { setOpen: _this.setOpen, dateFormat: (_a2 = _this.props.dateFormatCalendar) !== null && _a2 !== void 0 ? _a2 : DatePicker2.defaultProps.dateFormatCalendar, onSelect: _this.handleSelect, onClickOutside: _this.handleCalendarClickOutside, holidays: getHolidaysMap(_this.modifyHolidays()), outsideClickIgnoreClass, onDropdownFocus: _this.handleDropdownFocus, onTimeChange: _this.handleTimeChange, className: _this.props.calendarClassName, container: _this.props.calendarContainer, handleOnKeyDown: _this.props.onKeyDown, handleOnDayKeyDown: _this.onDayKeyDown, setPreSelection: _this.setPreSelection, dropdownMode: (_b = _this.props.dropdownMode) !== null && _b !== void 0 ? _b : DatePicker2.defaultProps.dropdownMode }), children: _this.props.children });
    };
    _this.renderAriaLiveRegion = function() {
      var _a2 = _this.props, _b = _a2.dateFormat, dateFormat = _b === void 0 ? DatePicker2.defaultProps.dateFormat : _b, locale2 = _a2.locale;
      var isContainsTime = _this.props.showTimeInput || _this.props.showTimeSelect;
      var longDateFormat2 = isContainsTime ? "PPPPp" : "PPPP";
      var ariaLiveMessage;
      if (_this.props.selectsRange) {
        ariaLiveMessage = "Selected start date: ".concat(safeDateFormat(_this.props.startDate, { dateFormat: longDateFormat2, locale: locale2 }), ". ").concat(_this.props.endDate ? "End date: " + safeDateFormat(_this.props.endDate, { dateFormat: longDateFormat2, locale: locale2 }) : "");
      } else {
        if (_this.props.showTimeSelectOnly) {
          ariaLiveMessage = "Selected time: ".concat(safeDateFormat(_this.props.selected, { dateFormat, locale: locale2 }));
        } else if (_this.props.showYearPicker) {
          ariaLiveMessage = "Selected year: ".concat(safeDateFormat(_this.props.selected, { dateFormat: "yyyy", locale: locale2 }));
        } else if (_this.props.showMonthYearPicker) {
          ariaLiveMessage = "Selected month: ".concat(safeDateFormat(_this.props.selected, { dateFormat: "MMMM yyyy", locale: locale2 }));
        } else if (_this.props.showQuarterYearPicker) {
          ariaLiveMessage = "Selected quarter: ".concat(safeDateFormat(_this.props.selected, { dateFormat: "yyyy, QQQ", locale: locale2 }));
        } else {
          ariaLiveMessage = "Selected date: ".concat(safeDateFormat(_this.props.selected, { dateFormat: longDateFormat2, locale: locale2 }));
        }
      }
      return /* @__PURE__ */ jsx("span", { role: "alert", "aria-live": "polite", className: "react-datepicker__aria-live", children: ariaLiveMessage });
    };
    _this.renderDateInput = function() {
      var _a2, _b;
      var _c;
      var className = clsx(_this.props.className, (_a2 = {}, _a2[outsideClickIgnoreClass] = _this.state.open, _a2));
      var customInput = _this.props.customInput || /* @__PURE__ */ jsx("input", { type: "text" });
      var customInputRef = _this.props.customInputRef || "ref";
      var _d = _this.props, _e = _d.dateFormat, dateFormat = _e === void 0 ? DatePicker2.defaultProps.dateFormat : _e, locale2 = _d.locale;
      var inputValue = typeof _this.props.value === "string" ? _this.props.value : typeof _this.state.inputValue === "string" ? _this.state.inputValue : _this.props.selectsRange ? safeDateRangeFormat(_this.props.startDate, _this.props.endDate, { dateFormat, locale: locale2 }) : _this.props.selectsMultiple ? safeMultipleDatesFormat((_c = _this.props.selectedDates) !== null && _c !== void 0 ? _c : [], { dateFormat, locale: locale2 }) : safeDateFormat(_this.props.selected, { dateFormat, locale: locale2 });
      return cloneElement(customInput, (_b = {}, _b[customInputRef] = function(input) {
        _this.input = input;
      }, _b.value = inputValue, _b.onBlur = _this.handleBlur, _b.onChange = _this.handleChange, _b.onClick = _this.onInputClick, _b.onFocus = _this.handleFocus, _b.onKeyDown = _this.onInputKeyDown, _b.id = _this.props.id, _b.name = _this.props.name, _b.form = _this.props.form, _b.autoFocus = _this.props.autoFocus, _b.placeholder = _this.props.placeholderText, _b.disabled = _this.props.disabled, _b.autoComplete = _this.props.autoComplete, _b.className = clsx(customInput.props.className, className), _b.title = _this.props.title, _b.readOnly = _this.props.readOnly, _b.required = _this.props.required, _b.tabIndex = _this.props.tabIndex, _b["aria-describedby"] = _this.props.ariaDescribedBy, _b["aria-invalid"] = _this.props.ariaInvalid, _b["aria-labelledby"] = _this.props.ariaLabelledBy, _b["aria-required"] = _this.props.ariaRequired, _b));
    };
    _this.renderClearButton = function() {
      var _a2 = _this.props, isClearable = _a2.isClearable, disabled = _a2.disabled, selected = _a2.selected, startDate = _a2.startDate, endDate = _a2.endDate, clearButtonTitle = _a2.clearButtonTitle, _b = _a2.clearButtonClassName, clearButtonClassName = _b === void 0 ? "" : _b, _c = _a2.ariaLabelClose, ariaLabelClose = _c === void 0 ? "Close" : _c, selectedDates = _a2.selectedDates;
      if (isClearable && (selected != null || startDate != null || endDate != null || (selectedDates === null || selectedDates === void 0 ? void 0 : selectedDates.length))) {
        return /* @__PURE__ */ jsx("button", { type: "button", className: clsx("react-datepicker__close-icon", clearButtonClassName, { "react-datepicker__close-icon--disabled": disabled }), disabled, "aria-label": ariaLabelClose, onClick: _this.onClearClick, title: clearButtonTitle, tabIndex: -1 });
      } else {
        return null;
      }
    };
    _this.state = _this.calcInitialState();
    _this.preventFocusTimeout = void 0;
    return _this;
  }
  Object.defineProperty(DatePicker2, "defaultProps", { get: function() {
    return { allowSameDay: false, dateFormat: "MM/dd/yyyy", dateFormatCalendar: "LLLL yyyy", disabled: false, disabledKeyboardNavigation: false, dropdownMode: "scroll", preventOpenOnFocus: false, monthsShown: 1, readOnly: false, withPortal: false, selectsDisabledDaysInRange: false, shouldCloseOnSelect: true, showTimeSelect: false, showTimeInput: false, showPreviousMonths: false, showMonthYearPicker: false, showFullMonthYearPicker: false, showTwoColumnMonthYearPicker: false, showFourColumnMonthYearPicker: false, showYearPicker: false, showQuarterYearPicker: false, showWeekPicker: false, strictParsing: false, swapRange: false, timeIntervals: 30, timeCaption: "Time", previousMonthAriaLabel: "Previous Month", previousMonthButtonLabel: "Previous Month", nextMonthAriaLabel: "Next Month", nextMonthButtonLabel: "Next Month", previousYearAriaLabel: "Previous Year", previousYearButtonLabel: "Previous Year", nextYearAriaLabel: "Next Year", nextYearButtonLabel: "Next Year", timeInputLabel: "Time", enableTabLoop: true, yearItemNumber: DEFAULT_YEAR_ITEM_NUMBER, focusSelectedMonth: false, showPopperArrow: true, excludeScrollbar: true, customTimeInput: null, calendarStartDay: void 0, toggleCalendarOnIconClick: false, usePointerEvent: false };
  }, enumerable: false, configurable: true });
  DatePicker2.prototype.componentDidMount = function() {
    window.addEventListener("scroll", this.onScroll, true);
    document.addEventListener("visibilitychange", this.setHiddenStateOnVisibilityHidden);
  };
  DatePicker2.prototype.componentDidUpdate = function(prevProps, prevState) {
    var _a2, _b, _c, _d;
    if (prevProps.inline && hasPreSelectionChanged(prevProps.selected, this.props.selected)) {
      this.setPreSelection(this.props.selected);
    }
    if (this.state.monthSelectedIn !== void 0 && prevProps.monthsShown !== this.props.monthsShown) {
      this.setState({ monthSelectedIn: 0 });
    }
    if (prevProps.highlightDates !== this.props.highlightDates) {
      this.setState({ highlightDates: getHighLightDaysMap(this.props.highlightDates) });
    }
    if (!prevState.focused && !isEqual(prevProps.selected, this.props.selected)) {
      this.setState({ inputValue: null });
    }
    if (prevState.open !== this.state.open) {
      if (prevState.open === false && this.state.open === true) {
        (_b = (_a2 = this.props).onCalendarOpen) === null || _b === void 0 ? void 0 : _b.call(_a2);
      }
      if (prevState.open === true && this.state.open === false) {
        (_d = (_c = this.props).onCalendarClose) === null || _d === void 0 ? void 0 : _d.call(_c);
      }
    }
  };
  DatePicker2.prototype.componentWillUnmount = function() {
    this.clearPreventFocusTimeout();
    window.removeEventListener("scroll", this.onScroll, true);
    document.removeEventListener("visibilitychange", this.setHiddenStateOnVisibilityHidden);
  };
  DatePicker2.prototype.renderInputContainer = function() {
    var _a2 = this.props, showIcon = _a2.showIcon, icon = _a2.icon, calendarIconClassname = _a2.calendarIconClassname, calendarIconClassName = _a2.calendarIconClassName, toggleCalendarOnIconClick = _a2.toggleCalendarOnIconClick;
    var open = this.state.open;
    if (calendarIconClassname) {
      console.warn("calendarIconClassname props is deprecated. should use calendarIconClassName props.");
    }
    return /* @__PURE__ */ jsxs("div", { className: "react-datepicker__input-container".concat(showIcon ? " react-datepicker__view-calendar-icon" : ""), children: [showIcon && /* @__PURE__ */ jsx(CalendarIcon, { ..._assign({ icon, className: clsx(calendarIconClassName, !calendarIconClassName && calendarIconClassname, open && "react-datepicker-ignore-onclickoutside") }, toggleCalendarOnIconClick ? { onClick: this.toggleCalendar } : null) }), this.state.isRenderAriaLiveMessage && this.renderAriaLiveRegion(), this.renderDateInput(), this.renderClearButton()] });
  };
  DatePicker2.prototype.render = function() {
    var calendar2 = this.renderCalendar();
    if (this.props.inline)
      return calendar2;
    if (this.props.withPortal) {
      var portalContainer = this.state.open ? /* @__PURE__ */ jsx(TabLoop, { enableTabLoop: this.props.enableTabLoop, children: /* @__PURE__ */ jsx("div", { className: "react-datepicker__portal", tabIndex: -1, onKeyDown: this.onPortalKeyDown, children: calendar2 }) }) : null;
      if (this.state.open && this.props.portalId) {
        portalContainer = /* @__PURE__ */ jsx(Portal, { ..._assign({ portalId: this.props.portalId }, this.props), children: portalContainer });
      }
      return /* @__PURE__ */ jsxs("div", { children: [this.renderInputContainer(), portalContainer] });
    }
    return /* @__PURE__ */ jsx(PopperComponent$1, { ..._assign({}, this.props, { className: this.props.popperClassName, hidePopper: !this.isCalendarOpen(), targetComponent: this.renderInputContainer(), popperComponent: calendar2, popperOnKeyDown: this.onPopperKeyDown, showArrow: this.props.showPopperArrow }) });
  };
  return DatePicker2;
}(Component);
var PRESELECT_CHANGE_VIA_INPUT = "input";
var PRESELECT_CHANGE_VIA_NAVIGATE = "navigate";
function declension(scheme, count2) {
  if (scheme.one !== void 0 && count2 === 1) {
    return scheme.one;
  }
  const rem10 = count2 % 10;
  const rem100 = count2 % 100;
  if (rem10 === 1 && rem100 !== 11) {
    return scheme.singularNominative.replace("{{count}}", String(count2));
  } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
    return scheme.singularGenitive.replace("{{count}}", String(count2));
  } else {
    return scheme.pluralGenitive.replace("{{count}}", String(count2));
  }
}
function buildLocalizeTokenFn(scheme) {
  return (count2, options) => {
    if (options == null ? void 0 : options.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        if (scheme.future) {
          return declension(scheme.future, count2);
        } else {
          return "\u0447\u0435\u0440\u0435\u0437 " + declension(scheme.regular, count2);
        }
      } else {
        if (scheme.past) {
          return declension(scheme.past, count2);
        } else {
          return declension(scheme.regular, count2) + " \u043D\u0430\u0437\u0430\u0434";
        }
      }
    } else {
      return declension(scheme.regular, count2);
    }
  };
}
const formatDistanceLocale = {
  lessThanXSeconds: buildLocalizeTokenFn({
    regular: {
      one: "\u043C\u0435\u043D\u044C\u0448\u0435 \u0441\u0435\u043A\u0443\u043D\u0434\u044B",
      singularNominative: "\u043C\u0435\u043D\u044C\u0448\u0435 {{count}} \u0441\u0435\u043A\u0443\u043D\u0434\u044B",
      singularGenitive: "\u043C\u0435\u043D\u044C\u0448\u0435 {{count}} \u0441\u0435\u043A\u0443\u043D\u0434",
      pluralGenitive: "\u043C\u0435\u043D\u044C\u0448\u0435 {{count}} \u0441\u0435\u043A\u0443\u043D\u0434"
    },
    future: {
      one: "\u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 \u0441\u0435\u043A\u0443\u043D\u0434\u0443",
      singularNominative: "\u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 {{count}} \u0441\u0435\u043A\u0443\u043D\u0434\u0443",
      singularGenitive: "\u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 {{count}} \u0441\u0435\u043A\u0443\u043D\u0434\u044B",
      pluralGenitive: "\u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 {{count}} \u0441\u0435\u043A\u0443\u043D\u0434"
    }
  }),
  xSeconds: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} \u0441\u0435\u043A\u0443\u043D\u0434\u0430",
      singularGenitive: "{{count}} \u0441\u0435\u043A\u0443\u043D\u0434\u044B",
      pluralGenitive: "{{count}} \u0441\u0435\u043A\u0443\u043D\u0434"
    },
    past: {
      singularNominative: "{{count}} \u0441\u0435\u043A\u0443\u043D\u0434\u0443 \u043D\u0430\u0437\u0430\u0434",
      singularGenitive: "{{count}} \u0441\u0435\u043A\u0443\u043D\u0434\u044B \u043D\u0430\u0437\u0430\u0434",
      pluralGenitive: "{{count}} \u0441\u0435\u043A\u0443\u043D\u0434 \u043D\u0430\u0437\u0430\u0434"
    },
    future: {
      singularNominative: "\u0447\u0435\u0440\u0435\u0437 {{count}} \u0441\u0435\u043A\u0443\u043D\u0434\u0443",
      singularGenitive: "\u0447\u0435\u0440\u0435\u0437 {{count}} \u0441\u0435\u043A\u0443\u043D\u0434\u044B",
      pluralGenitive: "\u0447\u0435\u0440\u0435\u0437 {{count}} \u0441\u0435\u043A\u0443\u043D\u0434"
    }
  }),
  halfAMinute: (_count, options) => {
    if (options == null ? void 0 : options.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        return "\u0447\u0435\u0440\u0435\u0437 \u043F\u043E\u043B\u043C\u0438\u043D\u0443\u0442\u044B";
      } else {
        return "\u043F\u043E\u043B\u043C\u0438\u043D\u0443\u0442\u044B \u043D\u0430\u0437\u0430\u0434";
      }
    }
    return "\u043F\u043E\u043B\u043C\u0438\u043D\u0443\u0442\u044B";
  },
  lessThanXMinutes: buildLocalizeTokenFn({
    regular: {
      one: "\u043C\u0435\u043D\u044C\u0448\u0435 \u043C\u0438\u043D\u0443\u0442\u044B",
      singularNominative: "\u043C\u0435\u043D\u044C\u0448\u0435 {{count}} \u043C\u0438\u043D\u0443\u0442\u044B",
      singularGenitive: "\u043C\u0435\u043D\u044C\u0448\u0435 {{count}} \u043C\u0438\u043D\u0443\u0442",
      pluralGenitive: "\u043C\u0435\u043D\u044C\u0448\u0435 {{count}} \u043C\u0438\u043D\u0443\u0442"
    },
    future: {
      one: "\u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 \u043C\u0438\u043D\u0443\u0442\u0443",
      singularNominative: "\u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 {{count}} \u043C\u0438\u043D\u0443\u0442\u0443",
      singularGenitive: "\u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 {{count}} \u043C\u0438\u043D\u0443\u0442\u044B",
      pluralGenitive: "\u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 {{count}} \u043C\u0438\u043D\u0443\u0442"
    }
  }),
  xMinutes: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} \u043C\u0438\u043D\u0443\u0442\u0430",
      singularGenitive: "{{count}} \u043C\u0438\u043D\u0443\u0442\u044B",
      pluralGenitive: "{{count}} \u043C\u0438\u043D\u0443\u0442"
    },
    past: {
      singularNominative: "{{count}} \u043C\u0438\u043D\u0443\u0442\u0443 \u043D\u0430\u0437\u0430\u0434",
      singularGenitive: "{{count}} \u043C\u0438\u043D\u0443\u0442\u044B \u043D\u0430\u0437\u0430\u0434",
      pluralGenitive: "{{count}} \u043C\u0438\u043D\u0443\u0442 \u043D\u0430\u0437\u0430\u0434"
    },
    future: {
      singularNominative: "\u0447\u0435\u0440\u0435\u0437 {{count}} \u043C\u0438\u043D\u0443\u0442\u0443",
      singularGenitive: "\u0447\u0435\u0440\u0435\u0437 {{count}} \u043C\u0438\u043D\u0443\u0442\u044B",
      pluralGenitive: "\u0447\u0435\u0440\u0435\u0437 {{count}} \u043C\u0438\u043D\u0443\u0442"
    }
  }),
  aboutXHours: buildLocalizeTokenFn({
    regular: {
      singularNominative: "\u043E\u043A\u043E\u043B\u043E {{count}} \u0447\u0430\u0441\u0430",
      singularGenitive: "\u043E\u043A\u043E\u043B\u043E {{count}} \u0447\u0430\u0441\u043E\u0432",
      pluralGenitive: "\u043E\u043A\u043E\u043B\u043E {{count}} \u0447\u0430\u0441\u043E\u0432"
    },
    future: {
      singularNominative: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u0447\u0430\u0441",
      singularGenitive: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u0447\u0430\u0441\u0430",
      pluralGenitive: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u0447\u0430\u0441\u043E\u0432"
    }
  }),
  xHours: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} \u0447\u0430\u0441",
      singularGenitive: "{{count}} \u0447\u0430\u0441\u0430",
      pluralGenitive: "{{count}} \u0447\u0430\u0441\u043E\u0432"
    }
  }),
  xDays: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} \u0434\u0435\u043D\u044C",
      singularGenitive: "{{count}} \u0434\u043D\u044F",
      pluralGenitive: "{{count}} \u0434\u043D\u0435\u0439"
    }
  }),
  aboutXWeeks: buildLocalizeTokenFn({
    regular: {
      singularNominative: "\u043E\u043A\u043E\u043B\u043E {{count}} \u043D\u0435\u0434\u0435\u043B\u0438",
      singularGenitive: "\u043E\u043A\u043E\u043B\u043E {{count}} \u043D\u0435\u0434\u0435\u043B\u044C",
      pluralGenitive: "\u043E\u043A\u043E\u043B\u043E {{count}} \u043D\u0435\u0434\u0435\u043B\u044C"
    },
    future: {
      singularNominative: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u043D\u0435\u0434\u0435\u043B\u044E",
      singularGenitive: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u043D\u0435\u0434\u0435\u043B\u0438",
      pluralGenitive: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u043D\u0435\u0434\u0435\u043B\u044C"
    }
  }),
  xWeeks: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} \u043D\u0435\u0434\u0435\u043B\u044F",
      singularGenitive: "{{count}} \u043D\u0435\u0434\u0435\u043B\u0438",
      pluralGenitive: "{{count}} \u043D\u0435\u0434\u0435\u043B\u044C"
    }
  }),
  aboutXMonths: buildLocalizeTokenFn({
    regular: {
      singularNominative: "\u043E\u043A\u043E\u043B\u043E {{count}} \u043C\u0435\u0441\u044F\u0446\u0430",
      singularGenitive: "\u043E\u043A\u043E\u043B\u043E {{count}} \u043C\u0435\u0441\u044F\u0446\u0435\u0432",
      pluralGenitive: "\u043E\u043A\u043E\u043B\u043E {{count}} \u043C\u0435\u0441\u044F\u0446\u0435\u0432"
    },
    future: {
      singularNominative: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u043C\u0435\u0441\u044F\u0446",
      singularGenitive: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u043C\u0435\u0441\u044F\u0446\u0430",
      pluralGenitive: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u043C\u0435\u0441\u044F\u0446\u0435\u0432"
    }
  }),
  xMonths: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} \u043C\u0435\u0441\u044F\u0446",
      singularGenitive: "{{count}} \u043C\u0435\u0441\u044F\u0446\u0430",
      pluralGenitive: "{{count}} \u043C\u0435\u0441\u044F\u0446\u0435\u0432"
    }
  }),
  aboutXYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: "\u043E\u043A\u043E\u043B\u043E {{count}} \u0433\u043E\u0434\u0430",
      singularGenitive: "\u043E\u043A\u043E\u043B\u043E {{count}} \u043B\u0435\u0442",
      pluralGenitive: "\u043E\u043A\u043E\u043B\u043E {{count}} \u043B\u0435\u0442"
    },
    future: {
      singularNominative: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u0433\u043E\u0434",
      singularGenitive: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u0433\u043E\u0434\u0430",
      pluralGenitive: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u043B\u0435\u0442"
    }
  }),
  xYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} \u0433\u043E\u0434",
      singularGenitive: "{{count}} \u0433\u043E\u0434\u0430",
      pluralGenitive: "{{count}} \u043B\u0435\u0442"
    }
  }),
  overXYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: "\u0431\u043E\u043B\u044C\u0448\u0435 {{count}} \u0433\u043E\u0434\u0430",
      singularGenitive: "\u0431\u043E\u043B\u044C\u0448\u0435 {{count}} \u043B\u0435\u0442",
      pluralGenitive: "\u0431\u043E\u043B\u044C\u0448\u0435 {{count}} \u043B\u0435\u0442"
    },
    future: {
      singularNominative: "\u0431\u043E\u043B\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 {{count}} \u0433\u043E\u0434",
      singularGenitive: "\u0431\u043E\u043B\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 {{count}} \u0433\u043E\u0434\u0430",
      pluralGenitive: "\u0431\u043E\u043B\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 {{count}} \u043B\u0435\u0442"
    }
  }),
  almostXYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: "\u043F\u043E\u0447\u0442\u0438 {{count}} \u0433\u043E\u0434",
      singularGenitive: "\u043F\u043E\u0447\u0442\u0438 {{count}} \u0433\u043E\u0434\u0430",
      pluralGenitive: "\u043F\u043E\u0447\u0442\u0438 {{count}} \u043B\u0435\u0442"
    },
    future: {
      singularNominative: "\u043F\u043E\u0447\u0442\u0438 \u0447\u0435\u0440\u0435\u0437 {{count}} \u0433\u043E\u0434",
      singularGenitive: "\u043F\u043E\u0447\u0442\u0438 \u0447\u0435\u0440\u0435\u0437 {{count}} \u0433\u043E\u0434\u0430",
      pluralGenitive: "\u043F\u043E\u0447\u0442\u0438 \u0447\u0435\u0440\u0435\u0437 {{count}} \u043B\u0435\u0442"
    }
  })
};
const formatDistance = (token2, count2, options) => {
  return formatDistanceLocale[token2](count2, options);
};
const dateFormats = {
  full: "EEEE, d MMMM y '\u0433.'",
  long: "d MMMM y '\u0433.'",
  medium: "d MMM y '\u0433.'",
  short: "dd.MM.y"
};
const timeFormats = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
const dateTimeFormats = {
  any: "{{date}}, {{time}}"
};
const formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "any"
  })
};
const accusativeWeekdays = [
  "\u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435",
  "\u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A",
  "\u0432\u0442\u043E\u0440\u043D\u0438\u043A",
  "\u0441\u0440\u0435\u0434\u0443",
  "\u0447\u0435\u0442\u0432\u0435\u0440\u0433",
  "\u043F\u044F\u0442\u043D\u0438\u0446\u0443",
  "\u0441\u0443\u0431\u0431\u043E\u0442\u0443"
];
function lastWeek(day) {
  const weekday = accusativeWeekdays[day];
  switch (day) {
    case 0:
      return "'\u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u0435 " + weekday + " \u0432' p";
    case 1:
    case 2:
    case 4:
      return "'\u0432 \u043F\u0440\u043E\u0448\u043B\u044B\u0439 " + weekday + " \u0432' p";
    case 3:
    case 5:
    case 6:
      return "'\u0432 \u043F\u0440\u043E\u0448\u043B\u0443\u044E " + weekday + " \u0432' p";
  }
}
function thisWeek(day) {
  const weekday = accusativeWeekdays[day];
  if (day === 2) {
    return "'\u0432\u043E " + weekday + " \u0432' p";
  } else {
    return "'\u0432 " + weekday + " \u0432' p";
  }
}
function nextWeek(day) {
  const weekday = accusativeWeekdays[day];
  switch (day) {
    case 0:
      return "'\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0435 " + weekday + " \u0432' p";
    case 1:
    case 2:
    case 4:
      return "'\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0439 " + weekday + " \u0432' p";
    case 3:
    case 5:
    case 6:
      return "'\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E " + weekday + " \u0432' p";
  }
}
const formatRelativeLocale = {
  lastWeek: (date2, baseDate, options) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options)) {
      return thisWeek(day);
    } else {
      return lastWeek(day);
    }
  },
  yesterday: "'\u0432\u0447\u0435\u0440\u0430 \u0432' p",
  today: "'\u0441\u0435\u0433\u043E\u0434\u043D\u044F \u0432' p",
  tomorrow: "'\u0437\u0430\u0432\u0442\u0440\u0430 \u0432' p",
  nextWeek: (date2, baseDate, options) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options)) {
      return thisWeek(day);
    } else {
      return nextWeek(day);
    }
  },
  other: "P"
};
const formatRelative = (token2, date2, baseDate, options) => {
  const format2 = formatRelativeLocale[token2];
  if (typeof format2 === "function") {
    return format2(date2, baseDate, options);
  }
  return format2;
};
const eraValues = {
  narrow: ["\u0434\u043E \u043D.\u044D.", "\u043D.\u044D."],
  abbreviated: ["\u0434\u043E \u043D. \u044D.", "\u043D. \u044D."],
  wide: ["\u0434\u043E \u043D\u0430\u0448\u0435\u0439 \u044D\u0440\u044B", "\u043D\u0430\u0448\u0435\u0439 \u044D\u0440\u044B"]
};
const quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-\u0439 \u043A\u0432.", "2-\u0439 \u043A\u0432.", "3-\u0439 \u043A\u0432.", "4-\u0439 \u043A\u0432."],
  wide: ["1-\u0439 \u043A\u0432\u0430\u0440\u0442\u0430\u043B", "2-\u0439 \u043A\u0432\u0430\u0440\u0442\u0430\u043B", "3-\u0439 \u043A\u0432\u0430\u0440\u0442\u0430\u043B", "4-\u0439 \u043A\u0432\u0430\u0440\u0442\u0430\u043B"]
};
const monthValues = {
  narrow: ["\u042F", "\u0424", "\u041C", "\u0410", "\u041C", "\u0418", "\u0418", "\u0410", "\u0421", "\u041E", "\u041D", "\u0414"],
  abbreviated: [
    "\u044F\u043D\u0432.",
    "\u0444\u0435\u0432.",
    "\u043C\u0430\u0440\u0442",
    "\u0430\u043F\u0440.",
    "\u043C\u0430\u0439",
    "\u0438\u044E\u043D\u044C",
    "\u0438\u044E\u043B\u044C",
    "\u0430\u0432\u0433.",
    "\u0441\u0435\u043D\u0442.",
    "\u043E\u043A\u0442.",
    "\u043D\u043E\u044F\u0431.",
    "\u0434\u0435\u043A."
  ],
  wide: [
    "\u044F\u043D\u0432\u0430\u0440\u044C",
    "\u0444\u0435\u0432\u0440\u0430\u043B\u044C",
    "\u043C\u0430\u0440\u0442",
    "\u0430\u043F\u0440\u0435\u043B\u044C",
    "\u043C\u0430\u0439",
    "\u0438\u044E\u043D\u044C",
    "\u0438\u044E\u043B\u044C",
    "\u0430\u0432\u0433\u0443\u0441\u0442",
    "\u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044C",
    "\u043E\u043A\u0442\u044F\u0431\u0440\u044C",
    "\u043D\u043E\u044F\u0431\u0440\u044C",
    "\u0434\u0435\u043A\u0430\u0431\u0440\u044C"
  ]
};
const formattingMonthValues = {
  narrow: ["\u042F", "\u0424", "\u041C", "\u0410", "\u041C", "\u0418", "\u0418", "\u0410", "\u0421", "\u041E", "\u041D", "\u0414"],
  abbreviated: [
    "\u044F\u043D\u0432.",
    "\u0444\u0435\u0432.",
    "\u043C\u0430\u0440.",
    "\u0430\u043F\u0440.",
    "\u043C\u0430\u044F",
    "\u0438\u044E\u043D.",
    "\u0438\u044E\u043B.",
    "\u0430\u0432\u0433.",
    "\u0441\u0435\u043D\u0442.",
    "\u043E\u043A\u0442.",
    "\u043D\u043E\u044F\u0431.",
    "\u0434\u0435\u043A."
  ],
  wide: [
    "\u044F\u043D\u0432\u0430\u0440\u044F",
    "\u0444\u0435\u0432\u0440\u0430\u043B\u044F",
    "\u043C\u0430\u0440\u0442\u0430",
    "\u0430\u043F\u0440\u0435\u043B\u044F",
    "\u043C\u0430\u044F",
    "\u0438\u044E\u043D\u044F",
    "\u0438\u044E\u043B\u044F",
    "\u0430\u0432\u0433\u0443\u0441\u0442\u0430",
    "\u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044F",
    "\u043E\u043A\u0442\u044F\u0431\u0440\u044F",
    "\u043D\u043E\u044F\u0431\u0440\u044F",
    "\u0434\u0435\u043A\u0430\u0431\u0440\u044F"
  ]
};
const dayValues = {
  narrow: ["\u0412", "\u041F", "\u0412", "\u0421", "\u0427", "\u041F", "\u0421"],
  short: ["\u0432\u0441", "\u043F\u043D", "\u0432\u0442", "\u0441\u0440", "\u0447\u0442", "\u043F\u0442", "\u0441\u0431"],
  abbreviated: ["\u0432\u0441\u043A", "\u043F\u043D\u0434", "\u0432\u0442\u0440", "\u0441\u0440\u0434", "\u0447\u0442\u0432", "\u043F\u0442\u043D", "\u0441\u0443\u0431"],
  wide: [
    "\u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435",
    "\u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A",
    "\u0432\u0442\u043E\u0440\u043D\u0438\u043A",
    "\u0441\u0440\u0435\u0434\u0430",
    "\u0447\u0435\u0442\u0432\u0435\u0440\u0433",
    "\u043F\u044F\u0442\u043D\u0438\u0446\u0430",
    "\u0441\u0443\u0431\u0431\u043E\u0442\u0430"
  ]
};
const dayPeriodValues = {
  narrow: {
    am: "\u0414\u041F",
    pm: "\u041F\u041F",
    midnight: "\u043F\u043E\u043B\u043D.",
    noon: "\u043F\u043E\u043B\u0434.",
    morning: "\u0443\u0442\u0440\u043E",
    afternoon: "\u0434\u0435\u043D\u044C",
    evening: "\u0432\u0435\u0447.",
    night: "\u043D\u043E\u0447\u044C"
  },
  abbreviated: {
    am: "\u0414\u041F",
    pm: "\u041F\u041F",
    midnight: "\u043F\u043E\u043B\u043D.",
    noon: "\u043F\u043E\u043B\u0434.",
    morning: "\u0443\u0442\u0440\u043E",
    afternoon: "\u0434\u0435\u043D\u044C",
    evening: "\u0432\u0435\u0447.",
    night: "\u043D\u043E\u0447\u044C"
  },
  wide: {
    am: "\u0414\u041F",
    pm: "\u041F\u041F",
    midnight: "\u043F\u043E\u043B\u043D\u043E\u0447\u044C",
    noon: "\u043F\u043E\u043B\u0434\u0435\u043D\u044C",
    morning: "\u0443\u0442\u0440\u043E",
    afternoon: "\u0434\u0435\u043D\u044C",
    evening: "\u0432\u0435\u0447\u0435\u0440",
    night: "\u043D\u043E\u0447\u044C"
  }
};
const formattingDayPeriodValues = {
  narrow: {
    am: "\u0414\u041F",
    pm: "\u041F\u041F",
    midnight: "\u043F\u043E\u043B\u043D.",
    noon: "\u043F\u043E\u043B\u0434.",
    morning: "\u0443\u0442\u0440\u0430",
    afternoon: "\u0434\u043D\u044F",
    evening: "\u0432\u0435\u0447.",
    night: "\u043D\u043E\u0447\u0438"
  },
  abbreviated: {
    am: "\u0414\u041F",
    pm: "\u041F\u041F",
    midnight: "\u043F\u043E\u043B\u043D.",
    noon: "\u043F\u043E\u043B\u0434.",
    morning: "\u0443\u0442\u0440\u0430",
    afternoon: "\u0434\u043D\u044F",
    evening: "\u0432\u0435\u0447.",
    night: "\u043D\u043E\u0447\u0438"
  },
  wide: {
    am: "\u0414\u041F",
    pm: "\u041F\u041F",
    midnight: "\u043F\u043E\u043B\u043D\u043E\u0447\u044C",
    noon: "\u043F\u043E\u043B\u0434\u0435\u043D\u044C",
    morning: "\u0443\u0442\u0440\u0430",
    afternoon: "\u0434\u043D\u044F",
    evening: "\u0432\u0435\u0447\u0435\u0440\u0430",
    night: "\u043D\u043E\u0447\u0438"
  }
};
const ordinalNumber = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);
  const unit = options == null ? void 0 : options.unit;
  let suffix;
  if (unit === "date") {
    suffix = "-\u0435";
  } else if (unit === "week" || unit === "minute" || unit === "second") {
    suffix = "-\u044F";
  } else {
    suffix = "-\u0439";
  }
  return number + suffix;
};
const localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern = /^(\d+)(-?(||||||||||))?/i;
const parseOrdinalNumberPattern = /\d+/i;
const matchEraPatterns = {
  narrow: /^(( )?\.?\s?\.?)/i,
  abbreviated: /^(( )?\.?\s?\.?)/i,
  wide: /^(  | | )/i
};
const parseEraPatterns = {
  any: [/^/i, /^/i]
};
const matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[]??)? .?/i,
  wide: /^[1234](-?[]??)? /i
};
const parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns = {
  narrow: /^[]/i,
  abbreviated: /^(||?||[]|[]?|[]?||?||?|)\.?/i,
  wide: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[]|[])/i
};
const parseMonthPatterns = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^[]/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns = {
  narrow: /^[]/i,
  short: /^(|||||||||||)\.?/i,
  abbreviated: /^(||||||||||||).?/i,
  wide: /^([]|?|?|[]|?|[]|[])/i
};
const parseDayPatterns = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^[]/i, /^[]/i, /^/i, /^/i, /^/i, /^[]/i, /^[]/i]
};
const matchDayPeriodPatterns = {
  narrow: /^([]|\.?|\.?|[]|||\.?|[])/i,
  abbreviated: /^([]|\.?|\.?|[]|||\.?|[])/i,
  wide: /^([]|||[]|||?|[])/i
};
const parseDayPeriodPatterns = {
  any: {
    am: /^/i,
    pm: /^/i,
    midnight: /^/i,
    noon: /^/i,
    morning: /^/i,
    afternoon: /^[]/i,
    evening: /^/i,
    night: /^/i
  }
};
const match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
const ru = {
  code: "ru",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
var UTILS$1 = {};
UTILS$1.range = function(start, size2, step) {
  var arr = Array.from(Array(size2));
  step = step === void 0 ? 1 : step;
  return arr.map(function(el, i) {
    var d = step;
    if (typeof step === "function") {
      d = step(i, start, size2);
    }
    return start + i * d;
  });
};
UTILS$1.renderCustomHeader = function(props) {
  var date2 = props.date, changeYear = props.changeYear, changeMonth = props.changeMonth, decreaseMonth = props.decreaseMonth, increaseMonth = props.increaseMonth, prevMonthButtonDisabled = props.prevMonthButtonDisabled, nextMonthButtonDisabled = props.nextMonthButtonDisabled;
  var years2 = UTILS$1.range(1990, getYear(new Date()) + 1, 1);
  var months2 = ["\u042F\u043D\u0432\u0430\u0440\u044C", "\u0424\u0435\u0432\u0440\u0430\u043B\u044C", "\u041C\u0430\u0440\u0442", "\u0410\u043F\u0440\u0435\u043B\u044C", "\u041C\u0430\u0439", "\u0418\u044E\u043D\u044C", "\u0418\u044E\u043B\u044C", "\u0410\u0432\u0433\u0443\u0441\u0442", "\u0421\u0435\u043D\u0442\u044F\u0431\u0440\u044C", "\u041E\u043A\u0442\u044F\u0431\u0440\u044C", "\u041D\u043E\u044F\u0431\u0440\u044C", "\u0414\u0435\u043A\u0430\u0431\u0440\u044C"];
  return /* @__PURE__ */ React__default.createElement("div", {
    style: {
      margin: 10,
      display: "flex",
      justifyContent: "center"
    }
  }, /* @__PURE__ */ React__default.createElement("button", {
    className: "date-arrow-style",
    onClick: decreaseMonth,
    disabled: prevMonthButtonDisabled
  }, "<"), /* @__PURE__ */ React__default.createElement("select", {
    className: "date-select-style",
    value: getYear(date2),
    onChange: function onChange(_ref) {
      var value = _ref.target.value;
      return changeYear(value);
    }
  }, years2.map(function(option) {
    return /* @__PURE__ */ React__default.createElement("option", {
      key: option,
      value: option
    }, option);
  })), /* @__PURE__ */ React__default.createElement("select", {
    className: "date-select-style",
    value: months2[getMonth(date2)],
    onChange: function onChange(_ref2) {
      var value = _ref2.target.value;
      return changeMonth(months2.indexOf(value));
    }
  }, months2.map(function(option) {
    return /* @__PURE__ */ React__default.createElement("option", {
      key: option,
      value: option
    }, option);
  })), /* @__PURE__ */ React__default.createElement("button", {
    className: "date-arrow-style",
    onClick: increaseMonth,
    disabled: nextMonthButtonDisabled
  }, ">"));
};
var reactDatepicker = "";
var datePicker = "";
var DateTimePicker = function DateTimePicker2(props) {
  var value = props.value, _props$onChange = props.onChange, _onChange = _props$onChange === void 0 ? function() {
  } : _props$onChange, _props$className = props.className, className = _props$className === void 0 ? "" : _props$className, _props$withTime = props.withTime, withTime = _props$withTime === void 0 ? false : _props$withTime;
  var format2 = withTime ? UTILS$2.formats.dateTime : UTILS$2.formats.date;
  var validator2 = withTime ? UTILS$2.validators.dateTime : UTILS$2.validators.date;
  var startDate;
  var calendar2;
  if (validator2(value)) {
    startDate = new Date(hooks(value, format2).format());
  } else {
    startDate = new Date();
  }
  var _useState = useState(startDate), _useState2 = _slicedToArray(_useState, 2), date2 = _useState2[0], setDate = _useState2[1];
  useEffect(function() {
    calendar2.setOpen(true);
  });
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "rct-date-picker".concat(className ? " " + className : "")
  }, /* @__PURE__ */ React__default.createElement(DatePicker, {
    popperPlacement: "top-end",
    dateFormat: withTime ? "Pp" : "P",
    locale: ru,
    selected: date2,
    onChange: function onChange(date3) {
      setDate(date3);
      _onChange(hooks(date3).format(format2));
    },
    showTimeInput: withTime,
    timeFormat: "p",
    ref: function ref(c) {
      return calendar2 = c;
    },
    renderCustomHeader: UTILS$1.renderCustomHeader
  }));
};
var PeriodPicker = function PeriodPicker2(props) {
  var value = props.value, _props$onClick = props.onClick, onClick = _props$onClick === void 0 ? function() {
  } : _props$onClick, _props$onChange = props.onChange, onChange = _props$onChange === void 0 ? function() {
  } : _props$onChange, _props$className = props.className, className = _props$className === void 0 ? "" : _props$className;
  var formatPeriodArray = function formatPeriodArray2(periodArr2) {
    return periodArr2.map(function(date2) {
      if (UTILS$2.validators.date(date2)) {
        return new Date(hooks(date2, UTILS$2.formats.date).format());
      }
      return void 0;
    });
  };
  var periodArr = value.split(UTILS$2.formats.datesSeparator);
  var formattedPeriodArr = formatPeriodArray(periodArr);
  var _useState = useState(formattedPeriodArr), _useState2 = _slicedToArray(_useState, 2), dateRange = _useState2[0], setDateRange = _useState2[1];
  var _ref = Array.isArray(dateRange) ? dateRange : formattedPeriodArr, _ref2 = _slicedToArray(_ref, 2), startDate = _ref2[0], endDate = _ref2[1];
  var calendar2;
  var _onChange = function _onChange2(update) {
    setDateRange(update);
    if (!update[0] || !update[1]) {
      onClick();
      return;
    }
    var valueArr = update.map(function(date2) {
      return hooks(date2).format(UTILS$2.formats.date);
    });
    onChange(valueArr.join(UTILS$2.formats.datesSeparator));
  };
  useEffect(function() {
    calendar2.setOpen(true);
  });
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "rct-period-picker".concat(className ? " " + className : "")
  }, /* @__PURE__ */ React__default.createElement(DatePicker, {
    selectsRange: true,
    startDate,
    endDate,
    dateFormat: "dd.MM.yyyy",
    onChange: _onChange,
    isClearable: true,
    locale: ru,
    ref: function ref(c) {
      return calendar2 = c;
    },
    renderCustomHeader: UTILS$1.renderCustomHeader
  }));
};
var File = function File2(props) {
  var fileName = props.fileName, files = props.files, index2 = props.index, setFiles = props.setFiles, filesDataCurrent = props.filesDataCurrent;
  var inputRef = React__default.useRef(null);
  var replaceFile = function replaceFile2(e) {
    var file = e.target.files[0];
    var fileName2 = file.name;
    filesDataCurrent.current[fileName2] = file;
    var out = _toConsumableArray(files);
    out[index2] = fileName2;
    setTimeout(function() {
      setFiles(out);
    }, 0);
  };
  var deleteFile = function deleteFile2() {
    var out = _toConsumableArray(files);
    out.splice(index2, 1);
    setTimeout(function() {
      setFiles(out);
    }, 0);
  };
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "rct-file".concat(filesDataCurrent.current[fileName] ? " is-new-file" : "")
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "rct-file-name",
    title: fileName
  }, fileName), /* @__PURE__ */ React__default.createElement("input", {
    type: "file",
    style: {
      display: "none"
    },
    ref: inputRef,
    onChange: replaceFile
  }), /* @__PURE__ */ React__default.createElement("i", {
    className: "fas fa-sync-alt fa-fw",
    title: "\u0437\u0430\u043C\u0435\u043D\u0438\u0442\u044C \u043D\u0430 \u0434\u0440\u0443\u0433\u043E\u0439 \u0444\u0430\u0439\u043B",
    onClick: function onClick() {
      return inputRef.current.click();
    }
  }), /* @__PURE__ */ React__default.createElement("i", {
    className: "fas fa-trash fa-fw",
    title: "\u0443\u0434\u0430\u043B\u0438\u0442\u044C \u0444\u0430\u0439\u043B \u0438\u0437 \u0441\u043F\u0438\u0441\u043A\u0430",
    onClick: deleteFile
  }));
};
var filesPicker = "";
var FilesPicker = function FilesPicker2(props) {
  var className = props.className, _props$value = props.value, value = _props$value === void 0 ? "" : _props$value, _props$isMultiple = props.isMultiple, isMultiple = _props$isMultiple === void 0 ? false : _props$isMultiple, onChange = props.onChange;
  var filesStringToArray = function filesStringToArray2(list) {
    var out = list.split(", ");
    return out.length === 1 && !out[0] ? [] : out;
  };
  var _useCurrentState = useCurrentState(filesStringToArray(value)), _useCurrentState2 = _slicedToArray(_useCurrentState, 3), files = _useCurrentState2[0], filesCurrent = _useCurrentState2[1], setFiles = _useCurrentState2[2];
  var filesDataCurrent = React__default.useRef({});
  var inputRef = React__default.useRef(null);
  var timeoutId = React__default.useRef(0);
  var onChoiceIsOver = function onChoiceIsOver2() {
    timeoutId.current = setTimeout(function() {
      timeoutId.current = 0;
    }, 100);
    onChange({
      value: filesCurrent.current.join(", "),
      files: filesCurrent.current,
      newFilesData: filesDataCurrent.current
    });
  };
  React__default.useEffect(function() {
    if (!isMultiple || !files.length) {
      inputRef.current.click();
    }
    return function() {
      if (!timeoutId.current)
        onChoiceIsOver();
    };
  }, []);
  var addFiles = function addFiles2(e) {
    var newFiles = e.target.files;
    var out = isMultiple ? _toConsumableArray(files) : [];
    if (!(newFiles !== null && newFiles !== void 0 && newFiles.length))
      return;
    var _iterator = _createForOfIteratorHelper(newFiles), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var newFile = _step.value;
        var fileName = newFile.name;
        filesDataCurrent.current[fileName] = newFile;
        out.push(fileName);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    setTimeout(function() {
      setFiles(out);
      if (!isMultiple) {
        onChoiceIsOver();
      }
    }, 0);
  };
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, isMultiple && /* @__PURE__ */ React__default.createElement("div", {
    className: "rct-files-picker".concat(className ? " " + className : "")
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "rct-files-wrapper"
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "rct-files"
  }, files.map(function(fileName, index2) {
    return /* @__PURE__ */ React__default.createElement(File, {
      fileName,
      index: index2,
      files,
      setFiles,
      filesDataCurrent
    });
  }), !files.length && /* @__PURE__ */ React__default.createElement("div", {
    className: "empty-files-list"
  }, "\u041F\u043E\u043A\u0430 \u043D\u0438\u0447\u0435\u0433\u043E \u043D\u0435 \u0432\u044B\u0431\u0440\u0430\u043D\u043E"))), /* @__PURE__ */ React__default.createElement("div", {
    className: "p-1 rct-files-menu"
  }, /* @__PURE__ */ React__default.createElement("button", {
    className: "tf_btn tf_btn-transparent tf_btn-sm tf_btn-icon add-file",
    title: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0435\u0449\u0435 \u0444\u0430\u0439\u043B\u043E\u0432"
  }, /* @__PURE__ */ React__default.createElement("i", {
    className: "fas fa-plus fa-fw",
    onClick: function onClick() {
      return inputRef.current.click();
    }
  })), /* @__PURE__ */ React__default.createElement("button", {
    className: "tf_btn tf_btn-sm tf_btn-primary ok",
    onClick: onChoiceIsOver
  }, "OK"))), /* @__PURE__ */ React__default.createElement("input", {
    type: "file",
    style: {
      display: "none"
    },
    ref: inputRef,
    onChange: addFiles,
    multiple: isMultiple
  }));
};
var tableHeaderCellMenu = "";
var TableHeaderCellMenu = function TableHeaderCellMenu2(props) {
  var _cell$_;
  var utils2 = props.utils, connector = props.connector, parentCh = props.parentCh, parentChildren = props.parentChildren, parent = props.parent, showColumn = props.showColumn, isRight = props.isRight, cell = props.cell, onSortCurrent = props.onSortCurrent;
  var header = connector.header, searchContext = connector.searchContext, _connector$onChangeCo = connector.onChangeComponentState.onChangeFilterOrSort, onChangeFilterOrSort = _connector$onChangeCo === void 0 ? function() {
  } : _connector$onChangeCo, _connector$options = connector.options, options = _connector$options === void 0 ? {} : _connector$options;
  var _options$columnsMenu = options.columnsMenu, _options$columnsMenu$ = _options$columnsMenu.hasHideIcon, hasHideIcon = _options$columnsMenu$ === void 0 ? false : _options$columnsMenu$, _options$columnsMenu$2 = _options$columnsMenu.hasOrderIcon, hasOrderIcon = _options$columnsMenu$2 === void 0 ? false : _options$columnsMenu$2, _options$columnsMenu$3 = _options$columnsMenu.hasFormatIcon, hasFormatIcon = _options$columnsMenu$3 === void 0 ? false : _options$columnsMenu$3, _options$columnsMenu$4 = _options$columnsMenu.hasSearchIcon, hasSearchIcon = _options$columnsMenu$4 === void 0 ? false : _options$columnsMenu$4, _options$columnsMenu$5 = _options$columnsMenu.hasSortIcon, hasSortIcon = _options$columnsMenu$5 === void 0 ? false : _options$columnsMenu$5;
  var orderPanelInitiator = React__default.useRef(null);
  var formatPanelInitiator = React__default.useRef(null);
  var _React$useState = React__default.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), showFilter = _React$useState2[0], setShowFilter = _React$useState2[1];
  var _React$useState3 = React__default.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), showFormatter = _React$useState4[0], setShowFormatter = _React$useState4[1];
  var openOrderPanel = function openOrderPanel2() {
    var list = [];
    var _iterator = _createForOfIteratorHelper(parentCh), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var item = _step.value;
        var index2 = item.i;
        list.push({
          index: index2,
          value: parentChildren[index2].value,
          isLeft: !!parentChildren[index2]._.isLeft
        });
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var removePopupFunction = function removePopupFunction2() {
    };
    var removePopup = function removePopup2() {
      return removePopupFunction();
    };
    var _callPopup = callPopup({
      initiator: orderPanelInitiator.current,
      id: "unitable-order-panel",
      minWidth: 0,
      minHeight: 0,
      onOutsideClick: removePopup,
      notResize: true,
      autoSize: true,
      children: /* @__PURE__ */ React__default.createElement(TableSettingsPanelOrder, _extends$h({}, props, {
        list,
        root: parent !== null && parent !== void 0 && parent.value ? parent.value : "ROOT",
        onChange: function onChange(list2) {
          var tmp = {};
          var _iterator2 = _createForOfIteratorHelper(parentCh), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var item2 = _step2.value;
              tmp[item2.i] = item2;
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          for (var i in list2)
            parentCh[i] = tmp[list2[i].index];
          utils2.orderTreeToOrderEnds();
          connector.refresh.headerAndBody();
          utils2.saveTableSettingsToLocaleStorage();
        }
      }))
    }), removeComponent = _callPopup.removeComponent;
    removePopupFunction = removeComponent;
  };
  var onSort = function onSort2() {
    if (cell._.sort) {
      if (cell._.sort === "down") {
        cell._.sort = "up";
      } else {
        delete cell._.sort;
        connector.sortCell = null;
      }
    } else {
      var _connector$sortCell;
      if ((_connector$sortCell = connector.sortCell) !== null && _connector$sortCell !== void 0 && (_connector$sortCell = _connector$sortCell._) !== null && _connector$sortCell !== void 0 && _connector$sortCell.sort) {
        delete connector.sortCell._.sort;
        connector.sortCell._.refresh();
      }
      cell._.sort = "down";
    }
    if (cell._.sort)
      connector.sortCell = cell;
    cell._.refresh();
    var rowsFromStore = utils2.storeGetPage({
      pageNum: 0
    });
    if (!rowsFromStore) {
      onChangeFilterOrSort({
        header,
        searchContext,
        sortCell: connector.sortCell
      });
      return;
    }
    console.log("################### GET PAGE FROM STORE", 0);
    utils2.refreshBodyWithNewRows({
      newRows: rowsFromStore,
      newPageNum: 0
    });
  };
  onSortCurrent.current = onSort;
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, ((_cell$_ = cell._) === null || _cell$_ === void 0 ? void 0 : _cell$_.format) && /* @__PURE__ */ React__default.createElement("div", {
    className: "uhc-format-label"
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "uhc-menu".concat(showFilter ? " show-search-bar" : "").concat(showFormatter ? " show-formatter" : "")
  }, showFilter || showFormatter ? /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, showFilter ? /* @__PURE__ */ React__default.createElement(TableHeaderCellMenuSearchBar, _extends$h({}, props, {
    setShowFilter
  })) : /* @__PURE__ */ React__default.createElement(TableHeaderCellMenuFormatter, _extends$h({}, props, {
    setShowFormatter
  }))) : /* @__PURE__ */ React__default.createElement("div", {
    className: "uhc-menu-inner"
  }, hasSortIcon && cell._.isEnd && /* @__PURE__ */ React__default.createElement("i", {
    className: "sort-button fas fa-sort-amount-".concat(cell._.sort === "up" ? "up" : "down", "-alt").concat(cell._.sort ? " is-present" : ""),
    title: "\u0421\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u043A\u0430 \u043F\u043E \u0441\u0442\u043E\u043B\u0431\u0446\u0443",
    onClick: onSort
  }), hasSearchIcon && /* @__PURE__ */ React__default.createElement("i", {
    className: "search-button fas fa-search",
    title: "\u041F\u043E\u0438\u0441\u043A \u043F\u043E \u0441\u0442\u043E\u043B\u0431\u0446\u0443",
    onClick: function onClick() {
      return setShowFilter(true);
    }
  }), hasHideIcon && isRight && /* @__PURE__ */ React__default.createElement("i", {
    className: "show-column-button fas fa-eye",
    title: "\u0421\u043A\u0440\u044B\u0442\u044C \u0441\u0442\u043E\u043B\u0431\u0435\u0446",
    onClick: showColumn(false)
  }), hasOrderIcon && isRight && /* @__PURE__ */ React__default.createElement("i", {
    className: "order-column-button fas fa-exchange-alt",
    title: "\u041F\u043E\u0440\u044F\u0434\u043E\u043A \u0441\u0442\u043E\u043B\u0431\u0446\u043E\u0432",
    onClick: openOrderPanel,
    ref: orderPanelInitiator
  }), hasFormatIcon && /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("i", {
    className: "format-button fas fa-paragraph",
    title: "\u0424\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u0441\u0442\u043E\u043B\u0431\u0446\u0430",
    onClick: function onClick() {
      return setShowFormatter(true);
    }
  }), /* @__PURE__ */ React__default.createElement("div", {
    ref: formatPanelInitiator
  })))));
};
var tableHeaderCellMenuSearchBar = "";
var TableHeaderCellMenuSearchBar = function TableHeaderCellMenuSearchBar2(props) {
  var connector = props.connector, cell = props.cell, utils2 = props.utils, setShowFilter = props.setShowFilter;
  var header = connector.header, sortCell = connector.sortCell, _connector$onChangeCo = connector.onChangeComponentState.onChangeFilterOrSort, onChangeFilterOrSort = _connector$onChangeCo === void 0 ? function() {
  } : _connector$onChangeCo;
  var _useCurrentState = useCurrentState(""), _useCurrentState2 = _slicedToArray(_useCurrentState, 3), searchContext = _useCurrentState2[0], searchContextCurrent = _useCurrentState2[1], _setSearchContext = _useCurrentState2[2];
  var setSearchContext = function setSearchContext2(text) {
    _setSearchContext(text);
    utils2.refreshColumnsTree({
      data: text,
      cell,
      connectorIndex: "searchContext",
      isObject: false
    });
  };
  var clickToFilter = function clickToFilter2() {
    if (searchContextCurrent.current)
      cell._.searchContext = searchContextCurrent.current;
    else
      delete cell._.searchContext;
    var rowsFromStore = utils2.storeGetPage({
      pageNum: 0
    });
    if (!rowsFromStore) {
      onChangeFilterOrSort({
        header,
        searchContext: connector.searchContext,
        sortCell
      });
      return;
    }
    console.log("################### GET PAGE FROM STORE", 0);
    utils2.refreshBodyWithNewRows({
      newRows: rowsFromStore,
      newPageNum: 0,
      openAllLevels: true
    });
  };
  var clickToCloseFilter = function clickToCloseFilter2() {
    setSearchContext(null);
    clickToFilter();
    setShowFilter(false);
  };
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("input", {
    className: "search-input",
    type: "text",
    value: searchContext,
    onChange: function onChange(e) {
      return setSearchContext(e.target.value);
    },
    autoFocus: true
  }), searchContext && /* @__PURE__ */ React__default.createElement("i", {
    className: "search-button fas fa-filter",
    title: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0442\u043E\u043B\u044C\u043A\u043E \u043D\u0430\u0439\u0434\u0435\u043D\u043D\u044B\u0435",
    onClick: clickToFilter
  }), /* @__PURE__ */ React__default.createElement("i", {
    className: "cancel-search-button fas fa-times",
    title: "\u041E\u0442\u043C\u0435\u043D\u0438\u0442\u044C \u043F\u043E\u0438\u0441\u043A",
    onClick: clickToCloseFilter
  }));
};
var tableHeaderCellMenuFormatter = "";
var TableHeaderCellMenuFormatter = function TableHeaderCellMenuFormatter2(props) {
  var cell = props.cell, setShowFormatter = props.setShowFormatter, utils2 = props.utils;
  var _React$useState = React__default.useState(true), _React$useState2 = _slicedToArray(_React$useState, 2), isActual = _React$useState2[0], setIsActual = _React$useState2[1];
  var _React$useState3 = React__default.useState(0), _React$useState4 = _slicedToArray(_React$useState3, 2), _ = _React$useState4[0], setRefresh = _React$useState4[1];
  var refresh = function refresh2() {
    setIsActual(false);
    setRefresh(UTILS$2.random16());
  };
  var format2 = React__default.useRef(cell._.format || {});
  var _format$current = format2.current, _format$current$align = _format$current.align, align = _format$current$align === void 0 ? "center" : _format$current$align, _format$current$color = _format$current.color, color = _format$current$color === void 0 ? "#000" : _format$current$color, _format$current$backg = _format$current.background, background = _format$current$backg === void 0 ? "#fff" : _format$current$backg, _format$current$wrap = _format$current.wrap, wrap = _format$current$wrap === void 0 ? false : _format$current$wrap;
  var _React$useState5 = React__default.useState(color), _React$useState6 = _slicedToArray(_React$useState5, 2), pickerColor = _React$useState6[0], _setPickerColor = _React$useState6[1];
  var setPickerColor = function setPickerColor2(color2) {
    _setPickerColor(color2);
  };
  var _React$useState7 = React__default.useState(background), _React$useState8 = _slicedToArray(_React$useState7, 2), pickerBgrnd = _React$useState8[0], setPickerBgrnd = _React$useState8[1];
  var colorPickerRef = React__default.useRef(null);
  var selectAlign = function selectAlign2(align2) {
    format2.current.align = align2;
    refresh();
  };
  var selectLeft = function selectLeft2() {
    return selectAlign("left");
  };
  var selectCenter = function selectCenter2() {
    return selectAlign("center");
  };
  var selectRight = function selectRight2() {
    return selectAlign("right");
  };
  var selectWrap = function selectWrap2() {
    format2.current.wrap = !wrap;
    refresh();
  };
  var closeFormatter = function closeFormatter2() {
    return setShowFormatter(false);
  };
  var doApplyOrTrash = function doApplyOrTrash2(format3) {
    setIsActual(true);
    utils2.refreshColumnsTree({
      data: format3,
      cell,
      connectorIndex: "format",
      isObject: true
    });
    setShowFormatter(false);
    utils2.saveTableSettingsToLocaleStorage();
  };
  var doApply = function doApply2() {
    cell._.format = _objectSpread2({}, format2.current);
    doApplyOrTrash(cell._.format);
  };
  var doTrash = function doTrash2() {
    delete cell._.format;
    format2.current = {};
    doApplyOrTrash(null);
  };
  var openPicker = function openPicker2(color2, setColor, index2) {
    var removePopupFunction = function removePopupFunction2() {
    };
    var removePopup = function removePopup2() {
      return removePopupFunction();
    };
    var _callPopup = callPopup({
      initiator: colorPickerRef.current,
      id: "",
      minWidth: 0,
      minHeight: 0,
      onOutsideClick: removePopup,
      notResize: true,
      autoSize: true,
      children: /* @__PURE__ */ React__default.createElement(ColorPicker, {
        pickerType: "sketch",
        color: color2,
        onChange: function onChange(color3) {
          setColor(color3);
          format2.current[index2] = color3;
          refresh();
        }
      })
    }), removeComponent = _callPopup.removeComponent;
    removePopupFunction = removeComponent;
  };
  var openColorPicker = function openColorPicker2() {
    return openPicker(pickerColor, setPickerColor, "color");
  };
  var openBgrndPicker = function openBgrndPicker2() {
    return openPicker(pickerBgrnd, setPickerBgrnd, "background");
  };
  var _left = {
    _class: "align-left",
    title: "\u0432\u043B\u0435\u0432\u043E",
    onClick: selectLeft,
    checked: align === "left",
    color: "#000",
    r: 0
  };
  var _center = {
    _class: "align-center",
    title: "\u043F\u043E \u0446\u0435\u043D\u0442\u0440\u0443",
    onClick: selectCenter,
    checked: align === "center",
    color: "#000",
    r: 0
  };
  var _right = {
    _class: "align-right",
    title: "\u0432\u043F\u0440\u0430\u0432\u043E",
    onClick: selectRight,
    checked: align === "right",
    color: "#000",
    r: 5
  };
  var _color = {
    _class: "pencil-alt",
    title: "\u0446\u0432\u0435\u0442 \u0442\u0435\u043A\u0441\u0442\u0430",
    onClick: openColorPicker,
    checked: !!format2.current.color,
    color: "#000",
    r: 0
  };
  var _bgrnd = {
    _class: "paint-roller",
    title: "\u0446\u0432\u0435\u0442 \u0444\u043E\u043D\u0430",
    onClick: openBgrndPicker,
    checked: !!format2.current.background,
    color: "#000",
    r: 5
  };
  var _wrap = {
    _class: "align-justify",
    title: "\u043F\u0435\u0440\u0435\u043D\u043E\u0441 \u043F\u043E \u0441\u0442\u0440\u043E\u043A\u0430\u043C",
    onClick: selectWrap,
    checked: wrap,
    color: "#000",
    r: 10
  };
  var _apply = {
    _class: "check",
    title: "\u043F\u0440\u0438\u043C\u0435\u043D\u0438\u0442\u044C",
    onClick: doApply,
    checked: isActual,
    r: 0
  };
  var _trash = {
    _class: "trash",
    title: "\u043E\u0447\u0438\u0441\u0442\u0438\u0442\u044C",
    onClick: doTrash,
    checked: false,
    r: 0
  };
  var _close = {
    _class: "times",
    title: "\u0437\u0430\u043A\u0440\u044B\u0442\u044C \u043F\u0430\u043D\u0435\u043B\u044C",
    onClick: closeFormatter,
    checked: false,
    r: 5
  };
  var icons = [_left, _center, _right, _color, _bgrnd, _wrap, _apply, _trash, _close];
  _color.color = color;
  _color.background = background;
  _bgrnd.color = background;
  _bgrnd.background = color;
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, icons.map(function(icon) {
    return /* @__PURE__ */ React__default.createElement(FormatterIcon, _extends$h({}, icon, {
      _
    }));
  }), /* @__PURE__ */ React__default.createElement("div", {
    ref: colorPickerRef
  }));
};
var FormatterIcon = function FormatterIcon2(props) {
  var _class = props._class, onClick = props.onClick, checked = props.checked, title = props.title, color = props.color, background = props.background, r2 = props.r;
  var style = {
    "margin-right": "".concat(r2, "px")
  };
  if (color) {
    style.color = color;
    style.background = background;
  }
  return /* @__PURE__ */ React__default.createElement("i", {
    className: "format-icon fas fa-".concat(_class).concat(checked ? " checked" : ""),
    onClick: onClick ? onClick : function() {
    },
    title,
    style
  });
};
var tableHeaderCellRowsTreeMenu = "";
var TableHeaderCellRowsTreeMenu = function TableHeaderCellRowsTreeMenu2(props) {
  var utils2 = props.utils, connector = props.connector;
  var refreshRow = connector.refresh.row, showRows = connector.showRows;
  var getLevelsInfo = function getLevelsInfo2() {
    var out = [];
    for (var index2 in showRows) {
      var _showRows$index = showRows[index2], show = _showRows$index.show, level = _showRows$index.level;
      out[level] = out[level] || {};
      if (show)
        out[level].show = true;
      else
        out[level].hide = true;
    }
    return out;
  };
  var openAll = function openAll2() {
    return utils2.setShowToAllRows(true);
  };
  var closeAll = function closeAll2() {
    return utils2.setShowToAllRows(false);
  };
  var openOne = function openOne2() {
    var info = getLevelsInfo();
    for (var level in info) {
      var item = info[level];
      if (item.hide) {
        for (var index2 in showRows) {
          var row = showRows[index2];
          if (row.level === Number(level) - 1 && !row.showChildren) {
            row.showChildren = true;
            refreshRow[index2]();
          }
          if (row.level === Number(level) && !row.show) {
            row.show = true;
            refreshRow[index2]();
          }
        }
        return;
      }
    }
  };
  var closeOne = function closeOne2() {
    var info = getLevelsInfo();
    for (var level = info.length - 1; level > 0; level--) {
      var item = info[level];
      if (item.show) {
        for (var index2 in showRows) {
          var row = showRows[index2];
          if (row.level === Number(level) - 1 && row.showChildren) {
            row.showChildren = false;
            refreshRow[index2]();
          }
          if (row.level === Number(level) && row.show) {
            row.show = false;
            refreshRow[index2]();
          }
        }
        return;
      }
    }
  };
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "rows-tree-menu"
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "rtm-open rtm-all rtm-open-all",
    title: "\u0420\u0430\u0437\u0432\u0435\u0440\u043D\u0443\u0442\u044C \u0432\u0441\u0451",
    onClick: openAll
  }, "+"), /* @__PURE__ */ React__default.createElement("div", {
    className: "rtm-open rtm-open-one",
    title: "\u0420\u0430\u0437\u0432\u0435\u0440\u043D\u0443\u0442\u044C \u043E\u0434\u0438\u043D \u0443\u0440\u043E\u0432\u0435\u043D\u044C",
    onClick: openOne
  }, "+"), /* @__PURE__ */ React__default.createElement("div", {
    className: "rtm-close rtm-close-one",
    title: "\u0421\u0432\u0435\u0440\u043D\u0443\u0442\u044C \u043E\u0434\u0438\u043D \u0443\u0440\u043E\u0432\u0435\u043D\u044C",
    onClick: closeOne
  }, "-"), /* @__PURE__ */ React__default.createElement("div", {
    className: "rtm-close rtm-all rtm-close-all",
    title: "\u0421\u0432\u0435\u0440\u043D\u0443\u0442\u044C \u0432\u0441\u0451",
    onClick: closeAll
  }, "-"));
};
var tableBody = "";
var TableBody = function TableBody2(props) {
  var utils2 = props.utils, connector = props.connector;
  var rows = connector.rows;
  var refUnitableBody = React__default.useRef(null);
  var refUnitableBodyInner = React__default.useRef(null);
  var refUnitableRowsWrapper = React__default.useRef(null);
  var _React$useState = React__default.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), _ = _React$useState2[0], setRefresh = _React$useState2[1];
  var refresh = function refresh2() {
    refUnitableBodyInner.current.scrollTop = 0;
    setRefresh(UTILS$2.random16());
  };
  var refreshHard = function refreshHard2() {
    refUnitableBodyInner.current.scrollTop = 0;
    setRefresh(null);
    setTimeout(function() {
      setRefresh(UTILS$2.random16());
    }, 1e3);
  };
  React__default.useEffect(function() {
    connector.refs.unitableBody = refUnitableBody.current;
    connector.refs.unitableBodyInner = refUnitableBodyInner.current;
    connector.refs.unitableRowsWrapper = refUnitableRowsWrapper.current;
    connector.refresh.body = refresh;
    connector.refresh.bodyHard = refreshHard;
    window.addEventListener("resize", onResize);
    utils2.recalcHeaderRootsPadding();
    return function() {
      window.removeEventListener("resize", onResize);
    };
  }, []);
  var onWheel = function onWheel2(e) {
    if (!connector.refs.scrollbarVertical || connector.editableCell)
      return;
    var scrollTop = refUnitableBodyInner.current.scrollTop + (e.deltaY > 0 ? 20 : -20);
    refUnitableBodyInner.current.scrollTop = scrollTop;
    connector.refs.scrollbarVertical.scrollTop = scrollTop;
  };
  var onResize = function onResize2(e) {
    connector.refresh.scrollbarHorizontal();
    connector.refresh.scrollbarVertical();
    utils2.recalcHeaderRootsPadding();
  };
  var sliding = utils2.getSliding();
  if (_ === null)
    return null;
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-body",
    style: {
      maxHeight: utils2.getBodyHeight()
    },
    onWheel,
    ref: refUnitableBody,
    onMouseLeave: function onMouseLeave() {
      return utils2.setHoveredCell(null, null);
    }
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-body-inner",
    ref: refUnitableBodyInner
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-rows-wrapper",
    ref: refUnitableRowsWrapper
  }, rows.map(function(row, index2) {
    return /* @__PURE__ */ React__default.createElement(TableRow, _extends$h({
      key: "row-".concat(index2)
    }, props, {
      row,
      rowIndex: index2,
      sliding
    }));
  }), /* @__PURE__ */ React__default.createElement("div", {
    style: {
      height: "20px",
      minHeight: "20px"
    }
  }))), /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-line bottom"
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-line right"
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-line left"
  }), /* @__PURE__ */ React__default.createElement(TableScrollbarHorizontal, props), /* @__PURE__ */ React__default.createElement(TableScrollbarVertical, props));
};
var tableScrollbarHorizontal = "";
var TableScrollbarHorizontal = function TableScrollbarHorizontal2(props) {
  var utils2 = props.utils, connector = props.connector;
  var sizes = connector.sizes, rightParts = connector.refs.rightParts, tableHas = connector.tableHas;
  var _React$useState = React__default.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2);
  _React$useState2[0];
  var setRefresh = _React$useState2[1];
  var refresh = function refresh2() {
    return setRefresh(UTILS$2.random16());
  };
  var scrollbarWrapperRef = React__default.useRef(null);
  React__default.useEffect(function() {
    connector.refresh.scrollbarHorizontal = refresh;
    connector.refs.scrollbarWrapperRef = scrollbarWrapperRef;
    setTimeout(refresh, 0);
  }, []);
  var onScroll = function onScroll2(e) {
    var scrollLeft = scrollbarWrapperRef.current.scrollLeft;
    var _iterator = _createForOfIteratorHelper(rightParts), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var ref = _step.value;
        ref.scrollLeft = scrollLeft;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    utils2.recalcHeaderRootsPadding();
  };
  var headerRight = connector.refs.headerRight;
  var scrollbarIsNeeded = headerRight ? headerRight.scrollWidth > headerRight.clientWidth : false;
  if (scrollbarIsNeeded !== tableHas.scrollbarHorizontal) {
    tableHas.scrollbarHorizontal = scrollbarIsNeeded;
    setTimeout(function() {
      connector.refresh.scrollbarVertical();
    }, 0);
  }
  if (!scrollbarIsNeeded)
    return null;
  var leftWidth = utils2.getLeftPartRowWidth();
  var rightWidth = utils2.getRightPartRowWidth();
  var scrollbarWrapperWith = headerRight.clientWidth;
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-scrollbar-horizontal",
    style: utils2.getHeightStyle(sizes.scrollbar)
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "ush-left",
    style: utils2.getWidthStyle(leftWidth)
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "ush-body-wrapper",
    style: utils2.getWidthStyle(scrollbarWrapperWith),
    ref: scrollbarWrapperRef,
    onScroll
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "ush-body-inner",
    style: utils2.getWidthStyle(rightWidth)
  })));
};
var tableScrollbarVertical = "";
var TableScrollbarVertical = function TableScrollbarVertical2(props) {
  var utils2 = props.utils, connector = props.connector;
  var sizes = connector.sizes, tableHas = connector.tableHas, showRows = connector.showRows;
  var scrollbarWrapperRef = React__default.useRef(null);
  var _React$useState = React__default.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2);
  _React$useState2[0];
  var setRefresh = _React$useState2[1];
  var refresh = function refresh2() {
    return setRefresh(UTILS$2.random16());
  };
  React__default.useEffect(function() {
    connector.refresh.scrollbarVertical = refresh;
    setTimeout(refresh, 0);
  }, []);
  if (!connector.refs.unitableBodyInner)
    return null;
  var showRowsNumber = 0;
  var _iterator = _createForOfIteratorHelper(showRows), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var row = _step.value;
      if (row.show)
        showRowsNumber++;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var heightScrollbar = connector.refs.unitableBodyInner.getBoundingClientRect().height;
  var heightInnerList = showRowsNumber * sizes.rowsHeight + 20;
  var scrollbarIsNeeded = heightScrollbar < heightInnerList;
  if (scrollbarIsNeeded !== tableHas.scrollbarVertical) {
    tableHas.scrollbarVertical = scrollbarIsNeeded;
  }
  if (!scrollbarIsNeeded) {
    connector.refs.scrollbarVertical = null;
    return null;
  }
  if (!connector.refs.scrollbarVertical) {
    setTimeout(function() {
      connector.refs.scrollbarVertical = scrollbarWrapperRef.current;
    }, 0);
  }
  var onScroll = function onScroll2(e) {
    var scrollTop = scrollbarWrapperRef.current.scrollTop;
    connector.refs.unitableBodyInner.scrollTop = scrollTop;
  };
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-scrollbar-vertical",
    style: utils2.getWidthStyle(sizes.scrollbar)
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "usv-top",
    style: utils2.getHeightStyle(sizes.headerHeight)
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "usv-body-wrapper",
    ref: scrollbarWrapperRef,
    style: utils2.getHeightStyle(heightScrollbar),
    onScroll
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "usv-body-inner",
    style: utils2.getHeightStyle(heightInnerList)
  })));
};
var tableRow = "";
var TableRow = function TableRow2(props) {
  var utils2 = props.utils, connector = props.connector, row = props.row, rowIndex = props.rowIndex, sliding = props.sliding;
  var numberFixedLeftColumnsEnds = connector.numberFixedLeftColumnsEnds, rowsHeight = connector.sizes.rowsHeight, rightParts = connector.refs.rightParts, orderEnds = connector.orderEnds, _connector$options = connector.options, options = _connector$options === void 0 ? {} : _connector$options, showRows = connector.showRows, tableHasRowsTree = connector.tableHas.rowsTree, rowsByOrdinalIndex = connector.data.rowsByOrdinalIndex;
  var _options$background = options.background, _options$background$e = _options$background.evenRows, evenRows = _options$background$e === void 0 ? false : _options$background$e, _options$background$o = _options$background.oddRows, oddRows = _options$background$o === void 0 ? false : _options$background$o, _options$resize = options.resize, resize = _options$resize === void 0 ? false : _options$resize;
  var rowTreeData = showRows[rowIndex];
  var refRightPart = React__default.useRef(null);
  var wrapperEl = React__default.useRef(null);
  var startPosition = React__default.useRef(null);
  var _React$useState = React__default.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2);
  _React$useState2[0];
  var setRefresh = _React$useState2[1];
  var refresh = function refresh2() {
    return setRefresh(UTILS$2.random16());
  };
  React__default.useEffect(function() {
    rightParts.push(refRightPart.current);
    connector.refresh.row[rowIndex] = refresh;
  }, []);
  var isEven = function isEven2(i) {
    return i % 2 === 0;
  };
  var onMouseUp = function onMouseUp2() {
    document.onmouseup = null;
    document.onmousemove = null;
    var _iterator = _createForOfIteratorHelper(connector.refresh.row), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _refresh = _step.value;
        _refresh();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    connector.refresh.scrollbarVertical();
    utils2.saveTableSettingsToLocaleStorage();
  };
  var onMouseMove = function onMouseMove2(e) {
    var _startPosition$curren = startPosition.current, cursorY = _startPosition$curren.cursorY, wrapperHeight = _startPosition$curren.wrapperHeight;
    var newHeight = Math.max(20, wrapperHeight + (e.clientY - cursorY));
    connector.sizes.rowsHeight = newHeight;
    refresh();
  };
  var onMouseDown = function onMouseDown2(e) {
    startPosition.current = {
      cursorY: e.clientY,
      wrapperHeight: wrapperEl.current.getBoundingClientRect().height
    };
    document.onmouseup = onMouseUp;
    document.onmousemove = onMouseMove;
  };
  var _utils$splitRowByLeft = utils2.splitRowByLeftAndRight(orderEnds, numberFixedLeftColumnsEnds), _utils$splitRowByLeft2 = _slicedToArray(_utils$splitRowByLeft, 2), rowLeft = _utils$splitRowByLeft2[0], rowRight = _utils$splitRowByLeft2[1];
  var style = {};
  var backgroundColor = null;
  var show = rowTreeData.show;
  if (!show) {
    style.display = "none";
  } else {
    style = utils2.getHeightStyle(rowsHeight);
    backgroundColor = isEven(rowTreeData.mainRootIndex) ? evenRows : oddRows;
    if (backgroundColor)
      style.background = backgroundColor;
  }
  var cellData = {
    rowTreeData,
    tableHasRowsTree,
    rowIndex
  };
  if (rowTreeData.isNotFind)
    cellData.isNotFind = true;
  var outOfScreen = !sliding[rowIndex];
  if (outOfScreen) {
    setTimeout(function() {
      sliding[rowIndex] = true;
      refresh();
    }, 0);
  }
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-row",
    style: _objectSpread2(_objectSpread2({}, style), rowsByOrdinalIndex[rowIndex].css || {}),
    ref: wrapperEl
  }, show && !outOfScreen && /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-row-left"
  }, rowLeft.map(function(originalIndex) {
    var cell = row[originalIndex];
    var key = "cell-".concat(rowIndex, "-").concat(originalIndex);
    return /* @__PURE__ */ React__default.createElement(TableRowCell, _extends$h({
      key
    }, props, {
      cell,
      cellIndex: originalIndex
    }, cellData));
  })), /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-row-right",
    style: {
      width: "(100% - ".concat(utils2.getLeftPartRowWidth(), "px")
    },
    ref: refRightPart
  }, show && !outOfScreen && /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, rowRight.map(function(originalIndex) {
    var cell = row[originalIndex];
    var key = "cell-".concat(rowIndex, "-").concat(originalIndex);
    return /* @__PURE__ */ React__default.createElement(TableRowCell, _extends$h({
      key
    }, props, {
      cell,
      cellIndex: originalIndex
    }, cellData));
  }))), show && !outOfScreen && resize.rowsHeight && /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-line bottom row-resize",
    onMouseDown
  }));
};
var tableRowCell = "";
var TableRowCell = function TableRowCell2(props) {
  var _connector$data$heade, _headerEndCell$_, _headerEndCell$_2, _headerEndCell$_3, _connector$hovered, _connector$hovered2, _cell$_;
  var utils2 = props.utils, connector = props.connector, cell = props.cell, rowIndex = props.rowIndex, cellIndex = props.cellIndex, rowTreeData = props.rowTreeData, tableHasRowsTree = props.tableHasRowsTree, isNotFind = props.isNotFind;
  var value = cell.value, _cell$view = cell.view, cellView = _cell$view === void 0 ? null : _cell$view;
  var columnsWidth = connector.sizes.columnsWidth, _connector$options = connector.options, options = _connector$options === void 0 ? {} : _connector$options, _connector$commonForB = connector.commonForBody, commonForBody = _connector$commonForB === void 0 ? {} : _connector$commonForB;
  var _commonForBody$view = commonForBody.view, cellsView = _commonForBody$view === void 0 ? null : _commonForBody$view, _commonForBody$css = commonForBody.css, commonCSS = _commonForBody$css === void 0 ? {} : _commonForBody$css, _commonForBody$custom = commonForBody.customizer, commonCustomizer = _commonForBody$custom === void 0 ? [] : _commonForBody$custom;
  var _ref = options.other || {}, _ref$showHints = _ref.showHints, showHints = _ref$showHints === void 0 ? false : _ref$showHints, _ref$highlightHovered = _ref.highlightHovered, highlightHovered = _ref$highlightHovered === void 0 ? false : _ref$highlightHovered;
  var _ref2 = options.background || {}, _ref2$hovered = _ref2.hovered, hoveredBackground = _ref2$hovered === void 0 ? false : _ref2$hovered;
  var headerEndCell = ((_connector$data$heade = connector.data.headerRootByEndIndex[cellIndex]) === null || _connector$data$heade === void 0 ? void 0 : _connector$data$heade.cell) || {};
  var css = ((_headerEndCell$_ = headerEndCell._) === null || _headerEndCell$_ === void 0 ? void 0 : _headerEndCell$_.css) || {};
  var columnCustomizer = (_headerEndCell$_2 = headerEndCell._) === null || _headerEndCell$_2 === void 0 ? void 0 : _headerEndCell$_2.customizer;
  var customizer = (columnCustomizer !== null && columnCustomizer !== void 0 && columnCustomizer.length ? columnCustomizer : null) || (commonCustomizer !== null && commonCustomizer !== void 0 && commonCustomizer.length ? commonCustomizer : null);
  var columnView = (_headerEndCell$_3 = headerEndCell._) === null || _headerEndCell$_3 === void 0 ? void 0 : _headerEndCell$_3.view;
  var CellView = cellView || columnView || cellsView;
  var _useCurrentState = useCurrentState(false), _useCurrentState2 = _slicedToArray(_useCurrentState, 3), hover3 = _useCurrentState2[0], hoverCurrent = _useCurrentState2[1], setHover = _useCurrentState2[2];
  var _React$useState = React__default.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2);
  _React$useState2[0];
  var setRefresh = _React$useState2[1];
  var refresh = function refresh2() {
    return setRefresh(UTILS$2.random16());
  };
  React__default.useEffect(function() {
    connector.refresh.column[cellIndex] = connector.refresh.column[cellIndex] || [];
    connector.refresh.column[cellIndex].push(refresh);
    setTimeout(refresh, 0);
  }, []);
  var cellRef = React__default.useRef(null);
  var testRef = React__default.useRef(null);
  var removePopupFunction = React__default.useRef(null);
  React__default.useEffect(function() {
    if (highlightHovered && hoverCurrent.current)
      utils2.setHoveredCell(cellIndex, rowIndex);
    if (!showHints || !hoverCurrent.current || !testRef.current)
      return;
    var _testRef$current$getB = testRef.current.getBoundingClientRect(), width = _testRef$current$getB.width;
    if (width <= columnsWidth[cellIndex])
      return;
    var popupAnswer = {};
    setTimeout(function() {
      if (removePopupFunction.current)
        removePopupFunction.current();
      if (!hoverCurrent.current)
        return;
      setHover(false);
      var removePopup = function removePopup2() {
        return removePopupFunction.current();
      };
      var _callPopup = callPopup({
        initiator: cellRef.current,
        extraClass: "table-hint",
        minWidth: columnsWidth[cellIndex],
        minHeight: 10,
        maxWidth: 400,
        onOutsideClick: removePopup,
        notResize: true,
        autoSize: true,
        children: /* @__PURE__ */ React__default.createElement("div", {
          dangerouslySetInnerHTML: {
            __html: value.replace(/, /g, "<br/>")
          }
        }),
        answer: popupAnswer
      }), removeComponent = _callPopup.removeComponent;
      removePopupFunction.current = removeComponent;
      setTimeout(function() {
        var randomClass = popupAnswer.randomClass, _popupAnswer$directio = popupAnswer.direction, up = _popupAnswer$directio.up, left = _popupAnswer$directio.left;
        var popupEl = document.querySelector(".".concat(randomClass));
        popupEl.classList.add(up ? "up" : "down");
        popupEl.classList.add(left ? "left" : "right");
      }, 0);
    }, 1e3);
  }, [hover3]);
  if (!connector.showColumns[cellIndex])
    return null;
  var onMouseEnter = function onMouseEnter2() {
    var _connector$editableCe;
    if ((_connector$editableCe = connector.editableCell) !== null && _connector$editableCe !== void 0 && _connector$editableCe.cell)
      return;
    setHover(true);
  };
  var onMouseLeave = function onMouseLeave2() {
    var _connector$editableCe2;
    if ((_connector$editableCe2 = connector.editableCell) !== null && _connector$editableCe2 !== void 0 && _connector$editableCe2.cell)
      return;
    setHover(false);
    if (removePopupFunction.current)
      removePopupFunction.current();
  };
  var toggleShowRowTree = function toggleShowRowTree2() {
    utils2.toggleShowRowTree(rowIndex);
  };
  var style = utils2.getWidthStyle(columnsWidth[cellIndex]);
  var isTreeCell = !cellIndex && tableHasRowsTree;
  var isTreeRoot = isTreeCell && rowTreeData.isRoot;
  var format2 = utils2.getFormatByCellIndex(cellIndex) || {};
  var align = format2.align, color = format2.color, background = format2.background, wrap = format2.wrap;
  if (align === "left" || align === "right")
    style["text-align"] = align;
  if (color)
    style["color"] = color;
  if (background)
    style["background"] = background;
  var valueStyle = wrap ? {
    "white-space": "normal"
  } : {};
  if (highlightHovered && (((_connector$hovered = connector.hovered) === null || _connector$hovered === void 0 ? void 0 : _connector$hovered.row) === rowIndex || ((_connector$hovered2 = connector.hovered) === null || _connector$hovered2 === void 0 ? void 0 : _connector$hovered2.column) === cellIndex)) {
    style["background"] = hoveredBackground;
  }
  var searchContext = utils2.getSearchContextByCellIndex(cellIndex);
  var _ref3 = searchContext && value && !CellView && !isNotFind ? UTILS$2.textWithSearchContext(String(value), searchContext, true) : {
    html: value
  }, html = _ref3.html, find = _ref3.find;
  var cellData = _objectSpread2(_objectSpread2({}, props), {}, {
    isTreeCell,
    isTreeRoot,
    toggleShowRowTree,
    valueStyle,
    CellView,
    cellRef,
    html,
    refreshCell: refresh
  });
  var conditionalData = customizer !== null && customizer !== void 0 && customizer.length ? utils2.getCustomizer({
    customizer,
    cell
  }) : {
    css: {},
    "class": ""
  };
  var conditionalCss = conditionalData.css, conditionalClass = conditionalData["class"];
  var className = "unitable-row-cell".concat(isTreeCell ? " is-tree-cell" : "").concat(isNotFind ? " is-not-find" : "").concat(find ? " cell-with-search-context" : "");
  if (conditionalClass)
    className += " " + conditionalClass;
  if ((_cell$_ = cell._) !== null && _cell$_ !== void 0 && _cell$_.invalidValueFormat)
    className += " invalid-format";
  return /* @__PURE__ */ React__default.createElement("div", {
    className,
    style: _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, commonCSS), style), css), conditionalCss),
    ref: cellRef,
    onMouseEnter,
    onMouseLeave
  }, /* @__PURE__ */ React__default.createElement(TableRowCellContent, cellData), hover3 && /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-row-cell unitable-row-cell-test",
    ref: testRef
  }, /* @__PURE__ */ React__default.createElement(TableRowCellContent, cellData)));
};
var tableRowCellContent = "";
var TableRowCellContent = function TableRowCellContent2(props) {
  var _connector$data$heade, _headerEndCell$_, _connector$editableCe;
  var connector = props.connector, utils2 = props.utils, cellIndex = props.cellIndex, rowIndex = props.rowIndex, isTreeCell = props.isTreeCell, isTreeRoot = props.isTreeRoot, rowTreeData = props.rowTreeData, toggleShowRowTree = props.toggleShowRowTree, cell = props.cell, valueStyle = props.valueStyle, CellView = props.CellView, cellRef = props.cellRef, html = props.html, refreshCell = props.refreshCell;
  var _connector$onChangeCo = connector.onChangeComponentState.onChangeCell, onChangeCell = _connector$onChangeCo === void 0 ? function() {
  } : _connector$onChangeCo, rowsTree = connector.rowsTree, _connector$commonForB = connector.commonForBody, commonForBody = _connector$commonForB === void 0 ? {} : _connector$commonForB;
  var isEditableCell = cell.isEditable;
  var _commonForBody$isEdit = commonForBody.isEditable, isEditableCommon = _commonForBody$isEdit === void 0 ? false : _commonForBody$isEdit;
  var headerEndCell = ((_connector$data$heade = connector.data.headerRootByEndIndex[cellIndex]) === null || _connector$data$heade === void 0 ? void 0 : _connector$data$heade.cell) || {};
  var isEditableColumn = (_headerEndCell$_ = headerEndCell._) === null || _headerEndCell$_ === void 0 ? void 0 : _headerEndCell$_.isEditable;
  var isEditable = isEditableCell === void 0 ? isEditableColumn : isEditableCell;
  isEditable = isEditable === void 0 ? isEditableCommon : isEditable;
  var oldValueBeforeEdit = React__default.useRef(null);
  var _useCurrentState = useCurrentState(cell === ((_connector$editableCe = connector.editableCell) === null || _connector$editableCe === void 0 ? void 0 : _connector$editableCe.cell)), _useCurrentState2 = _slicedToArray(_useCurrentState, 3), isEdit = _useCurrentState2[0], isEditCurrent = _useCurrentState2[1], setIsEdit = _useCurrentState2[2];
  var startEditor = function startEditor2() {
    oldValueBeforeEdit.current = cell.value;
    setIsEdit(true);
  };
  var stopEditor = function stopEditor2() {
    if (!isEditCurrent.current)
      return;
    if (cell.value !== oldValueBeforeEdit.current) {
      onChangeCell({
        cell,
        oldValue: oldValueBeforeEdit.current,
        newValue: cell.value,
        rows: rowsTree
      });
    }
    setIsEdit(false);
    connector.editableCell = null;
    refreshCell();
  };
  var clickToCell = function clickToCell2() {
    if (isTreeCell || !isEditable)
      return;
    utils2.setEditableCell({
      cell,
      stopEditor,
      cellRef: cellRef.current
    });
    startEditor();
  };
  var old_ = (cell === null || cell === void 0 ? void 0 : cell._) || {};
  cell._ = _objectSpread2(_objectSpread2({}, old_), {}, {
    cellIndex,
    rowIndex,
    isTreeCell,
    isTreeRoot,
    rowTreeData,
    wrapperRefCurrent: cellRef,
    refreshCell,
    stopEditor
  });
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, isTreeCell && /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-row-cell-tree",
    style: {
      width: "".concat(rowTreeData.level * 30 + 20, "px")
    }
  }, isTreeRoot && /* @__PURE__ */ React__default.createElement("div", {
    className: "toggle-tree",
    onClick: toggleShowRowTree
  }, rowTreeData.showChildren ? "-" : "+")), CellView ? /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-row-cell-value",
    style: valueStyle,
    onClick: isTreeCell ? null : clickToCell
  }, /* @__PURE__ */ React__default.createElement(CellView, cell)) : /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-row-cell-value",
    style: valueStyle,
    dangerouslySetInnerHTML: {
      __html: html
    },
    onClick: isTreeCell ? null : clickToCell
  }), isEdit && /* @__PURE__ */ React__default.createElement(TableRowCellContentEditor, _extends$h({}, props, {
    stopEditor
  })));
};
var UTILS = {
  texts: {
    placeholder: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u043C\u044F...",
    addFileMessage: "\u0411\u0443\u0434\u0435\u0442 \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D \u0444\u0430\u0439\u043B %s",
    removeFileMessage: "\u0424\u0430\u0439\u043B \u0431\u0443\u0434\u0435\u0442 \u0443\u0434\u0430\u043B\u0435\u043D.",
    positiveError: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0446\u0435\u043B\u043E\u0435 \u043D\u0435\u043E\u0442\u0440\u0438\u0446\u0430\u0442\u0435\u043B\u044C\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E",
    integerError: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0446\u0435\u043B\u043E\u0435 \u0447\u0438\u0441\u043B\u043E",
    floatError: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0447\u0438\u0441\u043B\u043E"
  }
};
UTILS.range = function(start, size2, step) {
  var arr = Array.from(Array(size2));
  step = step === void 0 ? 1 : step;
  return arr.map(function(el, i) {
    var d = step;
    if (typeof step === "function") {
      d = step(i, start, size2);
    }
    return start + i * d;
  });
};
UTILS.renderCustomHeader = function(props) {
  var date2 = props.date, changeYear = props.changeYear, changeMonth = props.changeMonth, decreaseMonth = props.decreaseMonth, increaseMonth = props.increaseMonth, prevMonthButtonDisabled = props.prevMonthButtonDisabled, nextMonthButtonDisabled = props.nextMonthButtonDisabled;
  var years2 = UTILS.range(1990, getYear(new Date()) + 1, 1);
  var months2 = ["\u042F\u043D\u0432\u0430\u0440\u044C", "\u0424\u0435\u0432\u0440\u0430\u043B\u044C", "\u041C\u0430\u0440\u0442", "\u0410\u043F\u0440\u0435\u043B\u044C", "\u041C\u0430\u0439", "\u0418\u044E\u043D\u044C", "\u0418\u044E\u043B\u044C", "\u0410\u0432\u0433\u0443\u0441\u0442", "\u0421\u0435\u043D\u0442\u044F\u0431\u0440\u044C", "\u041E\u043A\u0442\u044F\u0431\u0440\u044C", "\u041D\u043E\u044F\u0431\u0440\u044C", "\u0414\u0435\u043A\u0430\u0431\u0440\u044C"];
  return /* @__PURE__ */ React.createElement("div", {
    style: {
      margin: 10,
      display: "flex",
      justifyContent: "center"
    }
  }, /* @__PURE__ */ React.createElement("button", {
    className: "date-arrow-style",
    onClick: decreaseMonth,
    disabled: prevMonthButtonDisabled
  }, "<"), /* @__PURE__ */ React.createElement("select", {
    className: "date-select-style",
    value: getYear(date2),
    onChange: function onChange(_ref) {
      var value = _ref.target.value;
      return changeYear(value);
    }
  }, years2.map(function(option) {
    return /* @__PURE__ */ React.createElement("option", {
      key: option,
      value: option
    }, option);
  })), /* @__PURE__ */ React.createElement("select", {
    className: "date-select-style",
    value: months2[getMonth(date2)],
    onChange: function onChange(_ref2) {
      var value = _ref2.target.value;
      return changeMonth(months2.indexOf(value));
    }
  }, months2.map(function(option) {
    return /* @__PURE__ */ React.createElement("option", {
      key: option,
      value: option
    }, option);
  })), /* @__PURE__ */ React.createElement("button", {
    className: "date-arrow-style",
    onClick: increaseMonth,
    disabled: nextMonthButtonDisabled
  }, ">"));
};
var tableCellEditor = "";
var TableCellEditor = function TableCellEditor2(props) {
  var _CONSTANTS$fieldTypes;
  var cell = props.cell;
  var fieldTypeId = cell.fieldTypeId, value = cell.value;
  var ref = React__default.useRef(null);
  var hintRefCurrent = React__default.useRef(null);
  var startValue = React__default.useRef(value);
  var checkToEscape = function checkToEscape2(e) {
    if (e.code == "Escape") {
      setTimeout(function() {
        cell.value = startValue.current;
        setTimeout(function() {
          onCellBlur();
        }, 0);
      }, 100);
    }
  };
  React__default.useEffect(function() {
    document.addEventListener("keydown", checkToEscape);
    return function() {
      document.removeEventListener("keydown", checkToEscape);
    };
  }, []);
  var editors = {
    TableCellEditorBool,
    TableCellEditorString,
    TableCellEditorFloat,
    TableCellEditorInteger,
    TableCellEditorPositive,
    TableCellEditorDate,
    TableCellEditorPeriod,
    TableCellEditorFile,
    TableCellEditorFileMultiple,
    TableCellEditorSet,
    TableCellEditorSetMultiple
  };
  var Component2 = editors[(_CONSTANTS$fieldTypes = CONSTANTS.fieldTypesById[fieldTypeId]) === null || _CONSTANTS$fieldTypes === void 0 ? void 0 : _CONSTANTS$fieldTypes.editor] || TableCellEditorString;
  var onCellBlur = function onCellBlur2() {
    if (cell._.invalidValueFormat) {
      setTimeout(function() {
        COMMUNICATION.notify({
          isError: true,
          text: cell._.invalidValueFormat
        });
      });
    }
    cell._.stopEditor();
  };
  var setEditorHint = function setEditorHint2(text) {
    if (hintRefCurrent.current) {
      hintRefCurrent.current.textContent = text;
    }
  };
  var idClass = fieldTypeId ? " table-cell-editor-".concat(CONSTANTS.fieldTypesById[fieldTypeId].type) : "";
  return /* @__PURE__ */ React__default.createElement("div", {
    ref,
    className: "table-cell-editor selected".concat(idClass)
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "table-cell-editor-hint",
    ref: hintRefCurrent
  }), /* @__PURE__ */ React__default.createElement(Component2, _extends$h({}, props, {
    startValue: cell.value,
    onCellBlur,
    setEditorHint
  })));
};
var tableCellEditorBool = "";
var booleanItems = CONSTANTS.booleanItems;
var TableCellEditorBool = function TableCellEditorBool2(props) {
  var cell = props.cell, onCellBlur = props.onCellBlur;
  var inputRef = React__default.useRef(null);
  var onChangeValue = function onChangeValue2(data) {
    cell.value = data.selectedValues[0];
    cell.server_value = booleanItems.find(function(item) {
      return item.name === data.selectedValues[0];
    }).serverValue;
    cell._.refreshCell();
    onCellBlur();
  };
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "tce-bool",
    ref: inputRef
  }, cell.value, /* @__PURE__ */ createPortal(/* @__PURE__ */ React__default.createElement(Popup, _defineProperty$7(_defineProperty$7(_defineProperty$7({
    initiator: cell._.wrapperRefCurrent.current,
    autoSize: true,
    id: "boolean",
    minWidth: "200",
    minHeight: "55",
    maxHeight: "55"
  }, "autoSize", true), "notResize", true), "onOutsideClick", function onOutsideClick() {
  }), /* @__PURE__ */ React__default.createElement(ListPicker, _extends$h({}, props, {
    label: "boolean",
    list: booleanItems.map(function(item) {
      return item.name;
    }),
    onChange: onChangeValue,
    selectedValue: cell.value,
    hideSearchBar: true,
    hideCountersBar: true
  }))), document.body));
};
var tableCellEditorString = "";
var TableCellEditorString = function TableCellEditorString2(props) {
  var cell = props.cell, startValue = props.startValue, onCellBlur = props.onCellBlur, _props$validator = props.validator, validator2 = _props$validator === void 0 ? null : _props$validator;
  var _useCurrentState = useCurrentState(startValue), _useCurrentState2 = _slicedToArray(_useCurrentState, 3);
  _useCurrentState2[0];
  var valueCurrent = _useCurrentState2[1], setValue = _useCurrentState2[2];
  var _useCurrentState3 = useCurrentState(""), _useCurrentState4 = _slicedToArray(_useCurrentState3, 3);
  _useCurrentState4[0];
  var errorCurrent = _useCurrentState4[1], setError = _useCurrentState4[2];
  var inputRef = React__default.useRef(null);
  var onChangeValue = function onChangeValue2(e) {
    var newValue = e.target.value;
    setValue(newValue);
    cell.value = newValue;
  };
  var onKeyUp = function onKeyUp2(e) {
    if (e.code === "Enter")
      stop();
    if (e.code === "Escape") {
      setValue(startValue);
      cell.value = startValue;
      setTimeout(function() {
        checkValid(startValue);
        setTimeout(function() {
          stop();
        }, 0);
      }, 0);
    }
  };
  React__default.useEffect(function() {
    document.addEventListener("keydown", onKeyUp);
    return function() {
      document.removeEventListener("keydown", onKeyUp);
    };
  }, []);
  var stop = function stop2() {
    return onCellBlur();
  };
  var checkValid = function checkValid2(value) {
    if (validator2) {
      var _validator = validator2(value), valid = _validator.valid, msg = _validator.msg;
      var _error = valid ? "" : msg;
      if (valid) {
        delete cell._.invalidValueFormat;
      } else {
        cell._.invalidValueFormat = msg;
      }
      if (_error !== errorCurrent.current) {
        setError(_error);
      }
    }
  };
  checkValid(valueCurrent.current);
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "tce-string".concat(errorCurrent.current ? " invalid" : ""),
    ref: inputRef
  }, errorCurrent.current && /* @__PURE__ */ React__default.createElement("div", {
    className: "tce-error"
  }, errorCurrent.current), /* @__PURE__ */ React__default.createElement("input", {
    type: "text",
    value: valueCurrent.current,
    placeholder: "...",
    onChange: onChangeValue,
    autoFocus: true,
    onBlur: stop
  }));
};
var TableCellEditorFloat = function TableCellEditorFloat2(props) {
  var texts = UTILS.texts;
  var validators2 = UTILS$2.validators;
  var validator2 = function validator3(value) {
    if (validators2["float"](value)) {
      return {
        valid: true
      };
    }
    return {
      valid: false,
      msg: texts.floatError
    };
  };
  return /* @__PURE__ */ React__default.createElement(TableCellEditorString, _extends$h({}, props, {
    validator: validator2
  }));
};
var TableCellEditorInteger = function TableCellEditorInteger2(props) {
  var texts = UTILS.texts;
  var validators2 = UTILS$2.validators;
  var validator2 = function validator3(value) {
    if (validators2["int"](value)) {
      return {
        valid: true
      };
    }
    return {
      valid: false,
      msg: texts.integerError
    };
  };
  return /* @__PURE__ */ React__default.createElement(TableCellEditorString, _extends$h({}, props, {
    validator: validator2
  }));
};
var TableCellEditorPositive = function TableCellEditorPositive2(props) {
  var texts = UTILS.texts;
  var validators2 = UTILS$2.validators;
  var validator2 = function validator3(value) {
    if (validators2.positive(value)) {
      return {
        valid: true
      };
    }
    return {
      valid: false,
      msg: texts.positiveError
    };
  };
  return /* @__PURE__ */ React__default.createElement(TableCellEditorString, _extends$h({}, props, {
    validator: validator2
  }));
};
var TableCellEditorDate = function TableCellEditorDate2(props) {
  var cell = props.cell;
  var onChange = function onChange2(date2) {
    cell.value = date2;
    cell._.refreshCell();
  };
  return /* @__PURE__ */ React__default.createElement(DateTimePicker, {
    value: cell.value,
    onChange,
    withTime: true
  });
};
var TableCellEditorPeriod = function TableCellEditorPeriod2(props) {
  var cell = props.cell;
  var onChange = function onChange2(period) {
    cell.value = period;
    cell._.refreshCell();
  };
  return /* @__PURE__ */ React__default.createElement(PeriodPicker, {
    value: cell.value,
    onChange
  });
};
var TableCellEditorFileMultiple = function TableCellEditorFileMultiple2(props) {
  var cell = props.cell, onCellBlur = props.onCellBlur, _props$isNotMultiple = props.isNotMultiple, isNotMultiple = _props$isNotMultiple === void 0 ? false : _props$isNotMultiple;
  var onChange = function onChange2(props2) {
    var newFilesData = props2.newFilesData, value = props2.value;
    cell.value = value;
    cell.__ = {
      newFilesData
    };
    onCellBlur();
  };
  return /* @__PURE__ */ React__default.createElement(FilesPicker, {
    value: cell.value,
    onChange,
    isMultiple: !isNotMultiple
  });
};
var TableCellEditorFile = function TableCellEditorFile2(props) {
  return /* @__PURE__ */ React__default.createElement(TableCellEditorFileMultiple, _extends$h({}, props, {
    isNotMultiple: true
  }));
};
var tableCellEditorSet = "";
var TableCellEditorSet = function TableCellEditorSet2(props) {
  props.cell.value;
  var ref = React__default.useRef(null);
  React__default.useEffect(function() {
    callPopup({
      portal: ref.current,
      initiator: ref.current,
      children: /* @__PURE__ */ React__default.createElement(SetRoot, props),
      notResize: true,
      autoSize: true,
      style: {
        background: "beige"
      }
    });
  }, []);
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "tce-set-popup",
    ref
  });
};
var SetRoot = function SetRoot2(props) {
  var cell = props.cell, _props$isMultiSelect = props.isMultiSelect, isMultiSelect = _props$isMultiSelect === void 0 ? false : _props$isMultiSelect, setEditorHint = props.setEditorHint, onCellBlur = props.onCellBlur;
  var value = cell.value, _cell$set = cell.set, set5 = _cell$set === void 0 ? ['\u043D\u0435\u0442 \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\u0430 "set"'] : _cell$set, _cell$setValuePath = cell.setValuePath, setValuePath = _cell$setValuePath === void 0 ? "" : _cell$setValuePath;
  var getSelected = function getSelected2(value2) {
    var out = {};
    var arr = value2.split(", ");
    var _iterator = _createForOfIteratorHelper(arr), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var sel = _step.value;
        if (sel)
          out[sel] = true;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return out;
  };
  var selectedToString = function selectedToString2(selected2) {
    var out = [];
    for (var index2 in selected2)
      out.push(index2);
    return out.join(", ");
  };
  var _React$useState = React__default.useState(getSelected(value)), _React$useState2 = _slicedToArray(_React$useState, 2), selected = _React$useState2[0], _setSelected = _React$useState2[1];
  var setSelected = function setSelected2(selected2) {
    saveSelected(selected2);
    if (!isMultiSelect)
      onCellBlur();
    _setSelected(selected2);
  };
  var saveSelected = function saveSelected2(selected2) {
    cell.value = selectedToString(selected2);
    cell.__ = {
      selected: selected2
    };
  };
  React__default.useEffect(function() {
    setEditorHint(selectedToString(selected));
  }, [selected]);
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "tce-set-wrapper"
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "tce-set"
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "tce-set-inner"
  }, set5.map(function(item, index2) {
    return /* @__PURE__ */ React__default.createElement(SetItem, {
      item,
      setValuePath,
      index: index2,
      isMultiSelect,
      selected,
      setSelected
    });
  }))), isMultiSelect && /* @__PURE__ */ React__default.createElement("div", {
    className: "p-1 rct-set-menu"
  }, /* @__PURE__ */ React__default.createElement("button", {
    className: "tf_btn tf_btn-sm tf_btn-primary ok",
    onClick: onCellBlur
  }, "OK")));
};
var SetItem = function SetItem2(props) {
  var item = props.item, setValuePath = props.setValuePath, isMultiSelect = props.isMultiSelect, selected = props.selected, setSelected = props.setSelected;
  var checkRadioClass = isMultiSelect ? "check" : "radio";
  var checkRadioType = isMultiSelect ? "checkbox" : "radio";
  var label = typeof item === "string" ? item : UTILS$2.getValueByPath(item, setValuePath);
  var onChange = function onChange2() {
    var out = isMultiSelect ? _objectSpread2({}, selected) : {};
    if (out[label]) {
      delete out[label];
    } else {
      out[label] = item;
    }
    setTimeout(function() {
      setSelected(out);
    }, 0);
  };
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "tce-set-item"
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "tce-set-item-checkbox tf_form-".concat(checkRadioClass)
  }, /* @__PURE__ */ React__default.createElement("input", {
    className: "tf_form-".concat(checkRadioClass, "-input"),
    name: "selectedGroup",
    type: checkRadioType,
    checked: !!selected[label],
    onChange
  })), /* @__PURE__ */ React__default.createElement("div", {
    className: "tce-set-item-value"
  }, label));
};
var TableCellEditorSetMultiple = function TableCellEditorSetMultiple2(props) {
  return /* @__PURE__ */ React__default.createElement(TableCellEditorSet, _extends$h({}, props, {
    isMultiSelect: true
  }));
};
var tableRowCellContentEditor = "";
var TableRowCellContentEditor = function TableRowCellContentEditor2(props) {
  var connector = props.connector, utils2 = props.utils, cell = props.cell, cellRef = props.cellRef, stopEditor = props.stopEditor;
  var _connector$editors = connector.editors, editors = _connector$editors === void 0 ? {} : _connector$editors;
  var _editors$cellEditor = editors.cellEditor, cellEditor = _editors$cellEditor === void 0 ? "internal" : _editors$cellEditor;
  var clickOutsideThePopup = function clickOutsideThePopup2() {
    stopEditor();
    utils2.setEditableCell(null);
  };
  var Editor = typeof cellEditor === "function" ? cellEditor : cellEditor === "TableCellEditor" ? TableCellEditor : InternalTableCellEditor;
  cell._.popupData = {};
  return /* @__PURE__ */ React__default.createElement(Popup, {
    initiator: cellRef.current,
    notResize: true,
    fitToParent: true,
    onOutsideClick: clickOutsideThePopup,
    style: {
      background: "transparent",
      overflow: "visible",
      boxShadow: "none"
    },
    extraClass: "unitable-row-cell-value-editor",
    answer: cell._.popupData
  }, /* @__PURE__ */ React__default.createElement(Editor, {
    cell
  }));
};
var InternalTableCellEditor = function InternalTableCellEditor2(props) {
  var cell = props.cell;
  var _React$useState = React__default.useState(cell.value), _React$useState2 = _slicedToArray(_React$useState, 2), value = _React$useState2[0], setValue = _React$useState2[1];
  var onChangeValue = function onChangeValue2(e) {
    var v = e.target.value;
    setValue(v);
    cell.value = v;
    cell._.refreshCell();
  };
  return /* @__PURE__ */ React__default.createElement("input", {
    className: "tf_form-control tf_form-control-xs unitable-row-cell-internal-editor",
    type: "text",
    value,
    onChange: onChangeValue,
    autoFocus: true
  });
};
var tablePaginator = "";
var TablePaginator = function TablePaginator2(props) {
  var utils2 = props.utils, connector = props.connector;
  var paginatorHeight = connector.sizes.paginatorHeight, tableHas = connector.tableHas, rowsRootNumber = connector.rowsRootNumber, params = connector.params, options = connector.options, onChangeComponentState = connector.onChangeComponentState;
  var _options$paginator$ro = options.paginator.rowsByPage, rowsByPage = _options$paginator$ro === void 0 ? [] : _options$paginator$ro;
  var pageLength = params.pageLength, totalLength = params.totalLength;
  var _onChangeComponentSta = onChangeComponentState.onClickToPaginator_ShowLength, onClickToPaginator_ShowLength = _onChangeComponentSta === void 0 ? function() {
  } : _onChangeComponentSta, _onChangeComponentSta2 = onChangeComponentState.onClickToPaginator_RowsByPage, onClickToPaginator_RowsByPage = _onChangeComponentSta2 === void 0 ? function() {
  } : _onChangeComponentSta2, _onChangeComponentSta3 = onChangeComponentState.onClickToPaginator_GoToPage, onClickToPaginator_GoToPage = _onChangeComponentSta3 === void 0 ? function() {
  } : _onChangeComponentSta3;
  var pageNum = params.pageNum;
  var _React$useState = React__default.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), _ = _React$useState2[0], setRefresh = _React$useState2[1];
  var refresh = function refresh2() {
    return setRefresh(UTILS$2.random16());
  };
  React__default.useEffect(function() {
    connector.refresh.paginator = refresh;
  }, []);
  if (!tableHas.paginator)
    return null;
  var getPagesNum = function getPagesNum2() {
    var remains = totalLength % pageLength;
    return Math.floor(totalLength / pageLength) + (remains ? 1 : 0);
  };
  var onClickToPaginatorPage = function onClickToPaginatorPage2(pageNum2) {
    var rowsFromStore = utils2.storeGetPage({
      pageNum: pageNum2
    });
    if (!rowsFromStore) {
      onClickToPaginator_GoToPage(pageNum2);
      return;
    }
    console.log("################### GET PAGE FROM STORE", pageNum2);
    utils2.refreshBodyWithNewRows({
      newRows: rowsFromStore,
      newPageNum: pageNum2
    });
  };
  var toFirstPage = function toFirstPage2() {
    return onClickToPaginatorPage(0);
  };
  var toPrevPage = function toPrevPage2() {
    return onClickToPaginatorPage(pageNum - 1);
  };
  var toNextPage = function toNextPage2() {
    return onClickToPaginatorPage(pageNum + 1);
  };
  var toLastPage = function toLastPage2() {
    return onClickToPaginatorPage(pagesNum - 1);
  };
  var clickToRowsByPage = function clickToRowsByPage2(length) {
    if (!utils2.storeRowsIsLoaded()) {
      onClickToPaginator_RowsByPage(length);
      return;
    }
    console.log("################### GET PAGE FROM STORE", 0);
    utils2.refreshBodyWithNewRows({
      newRows: utils2.storeGetPage({
        pageNum: 0,
        pageLength: length
      }),
      newPageLength: length,
      newPageNum: 0
    });
  };
  var pagesNum = totalLength ? getPagesNum() : void 0;
  var commonClass = "btn pager-control";
  var disabledFirstClass = pageNum ? "" : " disabled";
  var disabledPreClass = disabledFirstClass;
  var disabledNextClass = !pagesNum || pageNum < pagesNum - 1 ? "" : " disabled";
  var disabledLastClass = pagesNum && pageNum < pagesNum - 1 ? "" : " disabled";
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-paginator",
    style: utils2.getHeightStyle(paginatorHeight)
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "slick-pager"
  }, /* @__PURE__ */ React__default.createElement("span", {
    className: "btn-group slick-pager-nav"
  }, /* @__PURE__ */ React__default.createElement("a", {
    className: commonClass + disabledFirstClass,
    onClick: disabledFirstClass ? function() {
    } : toFirstPage,
    title: "\u041D\u0430 \u043F\u0435\u0440\u0432\u0443\u044E \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0443"
  }, /* @__PURE__ */ React__default.createElement("i", {
    className: "icon-step-backward"
  })), /* @__PURE__ */ React__default.createElement("a", {
    className: commonClass + disabledPreClass,
    onClick: disabledPreClass ? function() {
    } : toPrevPage,
    title: "\u041D\u0430 \u043F\u0440\u0435\u0434\u044B\u0434\u0443\u0449\u0443\u044E \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0443"
  }, /* @__PURE__ */ React__default.createElement("i", {
    className: "icon-backward"
  })), /* @__PURE__ */ React__default.createElement("a", {
    className: commonClass + disabledNextClass,
    onClick: disabledNextClass ? function() {
    } : toNextPage,
    title: "\u041D\u0430 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0443"
  }, /* @__PURE__ */ React__default.createElement("i", {
    className: "icon-forward"
  })), /* @__PURE__ */ React__default.createElement("a", {
    className: commonClass + disabledLastClass,
    onClick: disabledLastClass ? function() {
    } : toLastPage,
    title: "\u041D\u0430 \u043F\u043E\u0441\u043B\u0435\u0434\u043D\u044E\u044E \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0443"
  }, /* @__PURE__ */ React__default.createElement("i", {
    className: "icon-step-forward"
  }))), /* @__PURE__ */ React__default.createElement("div", {
    className: "slick-pager-status"
  }, "\u0421\u0442\u0440\u0430\u043D\u0438\u0446\u0430 ", pageNum + 1, " \u0438\u0437", /* @__PURE__ */ React__default.createElement(Undef, {
    num: pagesNum,
    onClickToShowInPaginator: onClickToPaginator_ShowLength
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "between"
  }), "(\u0441\u0442\u0440\u043E\u043A: ", rowsRootNumber, " \u0438\u0437", /* @__PURE__ */ React__default.createElement(Undef, {
    num: totalLength,
    onClickToShowInPaginator: onClickToPaginator_ShowLength
  }), ")"), rowsByPage.length && /* @__PURE__ */ React__default.createElement("span", {
    className: "slick-pager-settings"
  }, "\u0421\u0442\u0440\u043E\u043A \u043D\u0430 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0435:", /* @__PURE__ */ React__default.createElement("div", {
    className: "btn-group",
    "data-toggle": "buttons-radio"
  }, rowsByPage.map(function(num, index2) {
    return /* @__PURE__ */ React__default.createElement("div", {
      key: "pag-index-".concat(index2),
      className: "btn".concat(num === pageLength ? " active" : "", " ").concat(_),
      onClick: function onClick() {
        return clickToRowsByPage(num);
      }
    }, num);
  })))));
};
var Undef = function Undef2(props) {
  var num = props.num, onClickToShowInPaginator = props.onClickToShowInPaginator;
  if (!isNaN(num))
    return /* @__PURE__ */ React__default.createElement("div", {
      className: "num"
    }, num);
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "undefined-number text-primary",
    onClick: onClickToShowInPaginator
  }, "\u043F\u043E\u043A\u0430\u0437\u0430\u0442\u044C");
};
var tableSettings = "";
var TableSettings = function TableSettings2(props) {
  var connector = props.connector;
  var _React$useState = React__default.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), isShow = _React$useState2[0], setIsShow = _React$useState2[1];
  var settingsRef = React__default.useRef(null);
  React__default.useEffect(function() {
    connector.refs.settings = settingsRef.current;
  }, []);
  var toggleShow = function toggleShow2() {
    return setIsShow(!isShow);
  };
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-settings",
    ref: settingsRef
  }, /* @__PURE__ */ React__default.createElement("i", {
    className: "unitable-settings-icon fas fa-cog",
    title: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0442\u0430\u0431\u043B\u0438\u0446\u044B",
    onClick: toggleShow
  }), isShow && /* @__PURE__ */ React__default.createElement(Popup, {
    initiator: settingsRef.current,
    id: "unitable",
    maxHeight: "50%",
    onOutsideClick: toggleShow,
    notResize: true,
    autoSize: true
  }, /* @__PURE__ */ React__default.createElement(TableSettingsPanel, props)));
};
var tableSettingsPanel = "";
var TableSettingsPanel = function TableSettingsPanel2(props) {
  var utils2 = props.utils, connector = props.connector;
  var editableSettings = connector.options.editableSettings;
  utils2.distributeShowColumnsToHeader();
  var parametersPanelIsPresent = false;
  for (var i in editableSettings) {
    if (editableSettings[i]) {
      parametersPanelIsPresent = true;
      break;
    }
  }
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "unitable-settings-panel"
  }, /* @__PURE__ */ React__default.createElement(TableSettingsPanelList, props), parametersPanelIsPresent && /* @__PURE__ */ React__default.createElement(TableSettingsPanelParameters, props));
};
var tableSettingsPanelList = "";
var TableSettingsPanelList = function TableSettingsPanelList2(props) {
  var utils2 = props.utils, connector = props.connector;
  var header = connector.header, orderTree = connector.orderTree, numberFixedLeftColumns = connector.numberFixedLeftColumns;
  var _React$useState = React__default.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2);
  _React$useState2[0];
  var setRefresh = _React$useState2[1];
  var refresh = function refresh2() {
    return setRefresh(UTILS$2.random16);
  };
  var _utils$splitRowByLeft = utils2.splitRowByLeftAndRight(orderTree, numberFixedLeftColumns), _utils$splitRowByLeft2 = _slicedToArray(_utils$splitRowByLeft, 2), orderLeft = _utils$splitRowByLeft2[0], orderRight = _utils$splitRowByLeft2[1];
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "usp-list"
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "usp-list-left"
  }, orderLeft.map(function(item) {
    var i = item.i, ch = item.ch;
    var cell = header[i];
    var key = "panel-list-".concat(cell._.ordinalIndex);
    return /* @__PURE__ */ React__default.createElement(_Branch, _extends$h({
      key
    }, props, {
      cell,
      parent: null,
      parentCh: orderTree,
      parentChildren: header,
      ch,
      isLeft: true
    }));
  })), /* @__PURE__ */ React__default.createElement("div", {
    className: "usp-list-right"
  }, orderRight.map(function(item) {
    var i = item.i, ch = item.ch;
    var cell = header[i];
    var key = "panel-list-".concat(cell._.ordinalIndex);
    return /* @__PURE__ */ React__default.createElement(_Branch, _extends$h({
      key
    }, props, {
      cell,
      parent: null,
      parentCh: orderTree,
      ch,
      parentChildren: header,
      isRight: true,
      refresh
    }));
  })));
};
var _Branch = function Branch(props) {
  var utils2 = props.utils, cell = props.cell, ch = props.ch, parentCh = props.parentCh, parentChildren = props.parentChildren, _props$level = props.level, level = _props$level === void 0 ? 0 : _props$level, isLeft = props.isLeft, refresh = props.refresh;
  var value = cell.value, children = cell.children, isEnd = cell._.isEnd;
  var _React$useState3 = React__default.useState(true), _React$useState4 = _slicedToArray(_React$useState3, 2), collapsed = _React$useState4[0], setCollapsed = _React$useState4[1];
  var toggleCollapsed = function toggleCollapsed2() {
    return setCollapsed(!collapsed);
  };
  var toggleShow = function toggleShow2() {
    utils2.toggleCheckedCell(cell);
    utils2.distributeHeaderToShowColumns();
    utils2.refreshTableWidth();
    utils2.saveTableSettingsToLocaleStorage();
    refresh();
  };
  var labelData = _objectSpread2(_objectSpread2({}, props), {}, {
    value,
    collapsed,
    toggleCollapsed,
    isEnd,
    toggleShow,
    isLeft,
    parentCh,
    parentChildren
  });
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "branch"
  }, /* @__PURE__ */ React__default.createElement(BranchLabel, labelData), !isEnd && /* @__PURE__ */ React__default.createElement("div", {
    className: "branch-children".concat(collapsed ? " collapsed" : "")
  }, ch.map(function(item) {
    var i = item.i, _ch = item.ch;
    var _cell = children[i];
    var key = "panel-list-".concat(_cell._.ordinalIndex);
    return /* @__PURE__ */ React__default.createElement(_Branch, _extends$h({
      key
    }, props, {
      parentChildren: children,
      cell: _cell,
      parent: cell,
      parentCh: ch,
      ch: _ch,
      level: level + 1
    }));
  })));
};
var BranchLabel = function BranchLabel2(props) {
  var utils2 = props.utils, connector = props.connector, cell = props.cell, parent = props.parent, value = props.value, collapsed = props.collapsed, toggleCollapsed = props.toggleCollapsed, isEnd = props.isEnd, toggleShow = props.toggleShow, isLeft = props.isLeft, parentCh = props.parentCh, parentChildren = props.parentChildren, refresh = props.refresh;
  var show = cell._.checked;
  var branchRef = React__default.useRef(null);
  var _React$useState5 = React__default.useState(false), _React$useState6 = _slicedToArray(_React$useState5, 2), showOrderPanel = _React$useState6[0], setShowOrderPanel = _React$useState6[1];
  var openOrderMenu = function openOrderMenu2() {
    var list = [];
    var _iterator = _createForOfIteratorHelper(parentCh), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var item = _step.value;
        var index2 = item.i;
        list.push({
          index: index2,
          value: parentChildren[index2].value,
          isLeft: !!parentChildren[index2]._.isLeft
        });
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    setShowOrderPanel({
      list
    });
  };
  var onChangeOrder = function onChangeOrder2(list) {
    var tmp = {};
    var _iterator2 = _createForOfIteratorHelper(parentCh), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var item = _step2.value;
        tmp[item.i] = item;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    for (var i in list)
      parentCh[i] = tmp[list[i].index];
    utils2.orderTreeToOrderEnds();
    connector.refresh.headerAndBody();
    utils2.saveTableSettingsToLocaleStorage();
    refresh();
  };
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "branch-label-wrapper ".concat(isEnd ? "is-end" : "is-root").concat(show ? " is-show" : " is-hide"),
    ref: branchRef
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "branch-collapsed"
  }, !isEnd && /* @__PURE__ */ React__default.createElement("i", {
    className: "fas fa-chevron-".concat(collapsed ? "up" : "down"),
    onClick: toggleCollapsed
  })), /* @__PURE__ */ React__default.createElement("div", {
    className: "branch-show"
  }, /* @__PURE__ */ React__default.createElement("input", {
    type: "checkbox",
    checked: show,
    onChange: isLeft ? function() {
    } : toggleShow
  })), /* @__PURE__ */ React__default.createElement("div", {
    className: "branch-label"
  }, value), /* @__PURE__ */ React__default.createElement("div", {
    className: "branch-order"
  }, !isLeft && /* @__PURE__ */ React__default.createElement("i", {
    className: "fas fa-exchange-alt",
    onClick: openOrderMenu
  })), showOrderPanel && /* @__PURE__ */ React__default.createElement(Popup, {
    initiator: branchRef.current,
    id: "unitable-order-panel",
    minWidth: "0",
    minHeight: "0",
    onOutsideClick: function onOutsideClick() {
      return setShowOrderPanel(false);
    },
    notResize: true,
    autoSize: true
  }, /* @__PURE__ */ React__default.createElement(TableSettingsPanelOrder, _extends$h({}, props, {
    list: showOrderPanel.list,
    root: parent !== null && parent !== void 0 && parent.value ? parent.value : "ROOT",
    onChange: onChangeOrder
  }))));
};
var tableSettingsPanelParameters = "";
var TableSettingsPanelParameters = function TableSettingsPanelParameters2(props) {
  var utils2 = props.utils, connector = props.connector;
  var editableSettings = connector.options.editableSettings, _connector$refresh = connector.refresh, refreshHeader = _connector$refresh.header, refreshBody = _connector$refresh.body;
  var reSearch = function reSearch2() {
    var rowsFromStore = utils2.storeGetPage();
    if (!rowsFromStore)
      return;
    console.log("################### GET PAGE FROM STORE", 0);
    utils2.refreshBodyWithNewRows({
      newRows: rowsFromStore,
      newPageNum: 0,
      openAllLevels: true
    });
  };
  var data = [{
    blockName: "\u0426\u0412\u0415\u0422 \u0424\u041E\u041D\u0410"
  }, {
    alias: "bgrHeader",
    address: "background.header",
    type: "color",
    title: "\u0448\u0430\u043F\u043A\u0438 \u0442\u0430\u0431\u043B\u0438\u0446\u044B",
    refresh: refreshHeader
  }, {
    alias: "bgrEvenRows",
    address: "background.evenRows",
    type: "color",
    title: "\u0447\u0451\u0442\u043D\u044B\u0445 \u0441\u0442\u0440\u043E\u043A",
    refresh: refreshBody
  }, {
    alias: "bgrOddRows",
    address: "background.oddRows",
    type: "color",
    title: "\u043D\u0435\u0447\u0451\u0442\u043D\u044B\u0445 \u0441\u0442\u0440\u043E\u043A",
    refresh: refreshBody
  }, {
    alias: "bgrHover",
    address: "background.hovered",
    type: "color",
    title: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0438 \u0441\u0442\u043E\u043B\u0431\u0435\u0446 \u043F\u043E\u0434 \u043A\u0443\u0440\u0441\u043E\u0440\u043E\u043C",
    refresh: refreshBody
  }, {
    blockName: "\u0418\u0417\u041C\u0415\u041D\u042F\u0422\u042C \u0420\u0410\u0417\u041C\u0415\u0420\u042B"
  }, {
    alias: "resizeHeaderHeight",
    address: "resize.headerHeight",
    type: "bool",
    title: "\u0432\u044B\u0441\u043E\u0442\u0430 \u0448\u0430\u043F\u043A\u0438 \u0442\u0430\u0431\u043B\u0438\u0446\u044B",
    refresh: refreshHeader
  }, {
    alias: "resizeRowsHeight",
    address: "resize.rowsHeight",
    type: "bool",
    title: "\u0432\u044B\u0441\u043E\u0442\u0430 \u0441\u0442\u0440\u043E\u043A",
    refresh: refreshBody
  }, {
    alias: "resizeColumnsWidth",
    address: "resize.columnsWidth",
    type: "bool",
    title: "\u0448\u0438\u0440\u0438\u043D\u0430 \u0441\u0442\u043E\u043B\u0431\u0446\u043E\u0432",
    refresh: refreshHeader
  }, {
    blockName: "\u0421\u041E\u0421\u0422\u0410\u0412 \u041C\u0415\u041D\u042E \u042F\u0427\u0415\u0415\u041A \u0428\u0410\u041F\u041A\u0418"
  }, {
    alias: "colHasHideIcon",
    address: "columnsMenu.hasHideIcon",
    type: "bool",
    title: "\u0441\u043A\u0440\u044B\u0442\u0438\u0435 \u0441\u0442\u043E\u043B\u0431\u0446\u043E\u0432",
    refresh: refreshHeader
  }, {
    alias: "colHasOrderIcon",
    address: "columnsMenu.hasOrderIcon",
    type: "bool",
    title: "\u0441\u043C\u0435\u043D\u0430 \u043F\u043E\u0440\u044F\u0434\u043A\u0430 \u0441\u0442\u043E\u043B\u0431\u0446\u043E\u0432",
    refresh: refreshHeader
  }, {
    alias: "colHasFormatIcon",
    address: "columnsMenu.hasFormatIcon",
    type: "bool",
    title: "\u0444\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u0441\u0442\u043E\u043B\u0431\u0446\u043E\u0432",
    refresh: refreshHeader
  }, {
    alias: "colHasSearchIcon",
    address: "columnsMenu.hasSearchIcon",
    type: "bool",
    title: "\u043F\u043E\u0438\u0441\u043A \u043F\u043E \u0441\u0442\u043E\u043B\u0431\u0446\u0430\u043C",
    refresh: refreshHeader
  }, {
    alias: "colHasSortIcon",
    address: "columnsMenu.hasSortIcon",
    type: "bool",
    title: "\u0441\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u043A\u0430 \u043F\u043E \u0441\u0442\u043E\u043B\u0431\u0446\u0430\u043C",
    refresh: refreshHeader
  }, {
    blockName: "\u0420\u0410\u0417\u041D\u041E\u0415"
  }, {
    alias: "showHints",
    address: "other.showHints",
    type: "bool",
    title: "\u043F\u043E\u0434\u0441\u043A\u0430\u0437\u043A\u0430 \u0434\u043B\u044F \u043F\u0435\u0440\u0435\u043F\u043E\u043B\u043D\u0435\u043D\u044B\u0445 \u044F\u0447\u0435\u0435\u043A",
    refresh: refreshBody
  }, {
    alias: "searchLogicAND",
    address: "other.searchLogicAND",
    type: "bool",
    title: '\u043B\u043E\u0433\u0438\u0447\u0435\u0441\u043A\u043E\u0435 "\u0418" \u043F\u043E\u0438\u0441\u043A\u0430',
    refresh: reSearch
  }, {
    alias: "isHovered",
    address: "other.highlightHovered",
    type: "bool",
    title: "\u0432\u044B\u0434\u0435\u043B\u0430\u0442\u044C \u0441\u0442\u0440\u043E\u043A\u0443 \u0438 \u0441\u0442\u043E\u043B\u0431\u0435\u0446 \u043F\u043E\u0434 \u043A\u0443\u0440\u0441\u043E\u0440\u043E\u043C",
    refresh: refreshBody
  }];
  var getOptionValue = function getOptionValue2(address) {
    return utils2.getValueByAddress("options.".concat(address));
  };
  var setOptionValue = function setOptionValue2(address, value) {
    return utils2.setValueByAddress("options.".concat(address), value);
  };
  var lastBlock;
  var showLastBlock = false;
  for (var _i = 0, _data = data; _i < _data.length; _i++) {
    var item = _data[_i];
    if (item.blockName) {
      if (lastBlock) {
        lastBlock.show = showLastBlock;
        showLastBlock = false;
      }
      lastBlock = item;
    } else {
      if (editableSettings[item.alias])
        showLastBlock = true;
    }
  }
  lastBlock.show = showLastBlock;
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "usp-parameters"
  }, data.map(function(item2, index2) {
    var key = "par-".concat(index2);
    if (item2.blockName)
      return /* @__PURE__ */ React__default.createElement("div", {
        key,
        className: "usp-param-block-name".concat(item2.show ? "" : " is-hide")
      }, item2.blockName);
    return /* @__PURE__ */ React__default.createElement(Parameter, _extends$h({
      key
    }, props, {
      item: item2,
      getOptionValue,
      setOptionValue
    }));
  }));
};
var Parameter = function Parameter2(props) {
  var connector = props.connector, item = props.item;
  var editableSettings = connector.options.editableSettings;
  var alias = item.alias, type = item.type, title = item.title;
  item.isDisable = !editableSettings[alias];
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "usp-param-item".concat(item.isDisable ? " is-disable" : "")
  }, type === "bool" && /* @__PURE__ */ React__default.createElement(ParameterCheckbox, props), type === "color" && /* @__PURE__ */ React__default.createElement(ParameterColor, props), title);
};
var ParameterCheckbox = function ParameterCheckbox2(props) {
  var utils2 = props.utils, item = props.item, getOptionValue = props.getOptionValue, setOptionValue = props.setOptionValue, key = props.key;
  var address = item.address, isDisable = item.isDisable, refresh = item.refresh;
  var _React$useState = React__default.useState(getOptionValue(address)), _React$useState2 = _slicedToArray(_React$useState, 2), checked = _React$useState2[0], setChecked = _React$useState2[1];
  var clickToCheckbox = function clickToCheckbox2() {
    setChecked(!checked);
    setOptionValue(address, !checked);
    if (refresh)
      refresh();
    utils2.saveTableSettingsToLocaleStorage();
  };
  return /* @__PURE__ */ React__default.createElement("input", {
    key,
    type: "checkbox",
    checked,
    onChange: isDisable ? function() {
    } : clickToCheckbox
  });
};
var ParameterColor = function ParameterColor2(props) {
  var utils2 = props.utils, item = props.item, getOptionValue = props.getOptionValue, setOptionValue = props.setOptionValue;
  var address = item.address, isDisable = item.isDisable, refresh = item.refresh;
  var _React$useState3 = React__default.useState(getOptionValue(address) || "#fff"), _React$useState4 = _slicedToArray(_React$useState3, 2), color = _React$useState4[0], setColor = _React$useState4[1];
  var _React$useState5 = React__default.useState(false), _React$useState6 = _slicedToArray(_React$useState5, 2), showPicker = _React$useState6[0], setShowPicker = _React$useState6[1];
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "usp-param-item-color",
    style: {
      background: color
    },
    onClick: isDisable ? null : function() {
      return setShowPicker(true);
    }
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "color-picker-wrapper"
  }, showPicker && /* @__PURE__ */ React__default.createElement(ColorPicker, {
    pickerType: "sketch",
    color,
    onChange: function onChange(color2) {
      setColor(color2);
      setOptionValue(address, color2);
      if (refresh)
        refresh();
      utils2.saveTableSettingsToLocaleStorage();
    },
    onClickOutside: function onClickOutside() {
      return setShowPicker(false);
    }
  })));
};
const DndContext = createContext({
  dragDropManager: void 0
});
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or use the non-minified dev environment for full errors. ";
}
var $$observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var randomString = function randomString2() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  var proto2 = obj;
  while (Object.getPrototypeOf(proto2) !== null) {
    proto2 = Object.getPrototypeOf(proto2);
  }
  return Object.getPrototypeOf(obj) === proto2;
}
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(formatProdErrorMessage(0));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(formatProdErrorMessage(1));
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  if (typeof reducer !== "function") {
    throw new Error(formatProdErrorMessage(2));
  }
  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(3));
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(formatProdErrorMessage(4));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(5));
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage(6));
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index2 = nextListeners.indexOf(listener);
      nextListeners.splice(index2, 1);
      currentListeners = null;
    };
  }
  function dispatch(action2) {
    if (!isPlainObject(action2)) {
      throw new Error(formatProdErrorMessage(7));
    }
    if (typeof action2.type === "undefined") {
      throw new Error(formatProdErrorMessage(8));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(9));
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action2);
    } finally {
      isDispatching = false;
    }
    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }
    return action2;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(formatProdErrorMessage(10));
    }
    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  function observable2() {
    var _ref;
    var outerSubscribe = subscribe;
    return _ref = {
      subscribe: function subscribe2(observer2) {
        if (typeof observer2 !== "object" || observer2 === null) {
          throw new Error(formatProdErrorMessage(11));
        }
        function observeState() {
          if (observer2.next) {
            observer2.next(getState());
          }
        }
        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      }
    }, _ref[$$observable] = function() {
      return this;
    }, _ref;
  }
  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch,
    subscribe,
    getState,
    replaceReducer
  }, _ref2[$$observable] = observable2, _ref2;
}
function invariant(condition, format2, ...args) {
  if (isProduction()) {
    if (format2 === void 0) {
      throw new Error("invariant requires an error message argument");
    }
  }
  if (!condition) {
    let error;
    if (format2 === void 0) {
      error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    } else {
      let argIndex = 0;
      error = new Error(format2.replace(/%s/g, function() {
        return args[argIndex++];
      }));
      error.name = "Invariant Violation";
    }
    error.framesToPop = 1;
    throw error;
  }
}
function isProduction() {
  return typeof process !== "undefined" && process.env["NODE_ENV"] === "production";
}
function get4(obj, path, defaultValue) {
  return path.split(".").reduce(
    (a, c) => a && a[c] ? a[c] : defaultValue || null,
    obj
  );
}
function without$1(items, item) {
  return items.filter(
    (i) => i !== item
  );
}
function isObject(input) {
  return typeof input === "object";
}
function xor(itemsA, itemsB) {
  const map3 = /* @__PURE__ */ new Map();
  const insertItem = (item) => {
    map3.set(item, map3.has(item) ? map3.get(item) + 1 : 1);
  };
  itemsA.forEach(insertItem);
  itemsB.forEach(insertItem);
  const result = [];
  map3.forEach((count2, key) => {
    if (count2 === 1) {
      result.push(key);
    }
  });
  return result;
}
function intersection(itemsA, itemsB) {
  return itemsA.filter(
    (t) => itemsB.indexOf(t) > -1
  );
}
const INIT_COORDS = "dnd-core/INIT_COORDS";
const BEGIN_DRAG = "dnd-core/BEGIN_DRAG";
const PUBLISH_DRAG_SOURCE = "dnd-core/PUBLISH_DRAG_SOURCE";
const HOVER = "dnd-core/HOVER";
const DROP = "dnd-core/DROP";
const END_DRAG = "dnd-core/END_DRAG";
function setClientOffset(clientOffset, sourceClientOffset) {
  return {
    type: INIT_COORDS,
    payload: {
      sourceClientOffset: sourceClientOffset || null,
      clientOffset: clientOffset || null
    }
  };
}
const ResetCoordinatesAction = {
  type: INIT_COORDS,
  payload: {
    clientOffset: null,
    sourceClientOffset: null
  }
};
function createBeginDrag(manager) {
  return function beginDrag(sourceIds = [], options = {
    publishSource: true
  }) {
    const { publishSource = true, clientOffset, getSourceClientOffset: getSourceClientOffset2 } = options;
    const monitor = manager.getMonitor();
    const registry = manager.getRegistry();
    manager.dispatch(setClientOffset(clientOffset));
    verifyInvariants$1(sourceIds, monitor, registry);
    const sourceId = getDraggableSource(sourceIds, monitor);
    if (sourceId == null) {
      manager.dispatch(ResetCoordinatesAction);
      return;
    }
    let sourceClientOffset = null;
    if (clientOffset) {
      if (!getSourceClientOffset2) {
        throw new Error("getSourceClientOffset must be defined");
      }
      verifyGetSourceClientOffsetIsFunction(getSourceClientOffset2);
      sourceClientOffset = getSourceClientOffset2(sourceId);
    }
    manager.dispatch(setClientOffset(clientOffset, sourceClientOffset));
    const source = registry.getSource(sourceId);
    const item = source.beginDrag(monitor, sourceId);
    if (item == null) {
      return void 0;
    }
    verifyItemIsObject(item);
    registry.pinSource(sourceId);
    const itemType = registry.getSourceType(sourceId);
    return {
      type: BEGIN_DRAG,
      payload: {
        itemType,
        item,
        sourceId,
        clientOffset: clientOffset || null,
        sourceClientOffset: sourceClientOffset || null,
        isSourcePublic: !!publishSource
      }
    };
  };
}
function verifyInvariants$1(sourceIds, monitor, registry) {
  invariant(!monitor.isDragging(), "Cannot call beginDrag while dragging.");
  sourceIds.forEach(function(sourceId) {
    invariant(registry.getSource(sourceId), "Expected sourceIds to be registered.");
  });
}
function verifyGetSourceClientOffsetIsFunction(getSourceClientOffset2) {
  invariant(typeof getSourceClientOffset2 === "function", "When clientOffset is provided, getSourceClientOffset must be a function.");
}
function verifyItemIsObject(item) {
  invariant(isObject(item), "Item must be an object.");
}
function getDraggableSource(sourceIds, monitor) {
  let sourceId = null;
  for (let i = sourceIds.length - 1; i >= 0; i--) {
    if (monitor.canDragSource(sourceIds[i])) {
      sourceId = sourceIds[i];
      break;
    }
  }
  return sourceId;
}
function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys3 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys3.forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    });
  }
  return target;
}
function createDrop(manager) {
  return function drop(options = {}) {
    const monitor = manager.getMonitor();
    const registry = manager.getRegistry();
    verifyInvariants(monitor);
    const targetIds = getDroppableTargets(monitor);
    targetIds.forEach((targetId, index2) => {
      const dropResult = determineDropResult(targetId, index2, registry, monitor);
      const action2 = {
        type: DROP,
        payload: {
          dropResult: _objectSpread$4({}, options, dropResult)
        }
      };
      manager.dispatch(action2);
    });
  };
}
function verifyInvariants(monitor) {
  invariant(monitor.isDragging(), "Cannot call drop while not dragging.");
  invariant(!monitor.didDrop(), "Cannot call drop twice during one drag operation.");
}
function determineDropResult(targetId, index2, registry, monitor) {
  const target = registry.getTarget(targetId);
  let dropResult = target ? target.drop(monitor, targetId) : void 0;
  verifyDropResultType(dropResult);
  if (typeof dropResult === "undefined") {
    dropResult = index2 === 0 ? {} : monitor.getDropResult();
  }
  return dropResult;
}
function verifyDropResultType(dropResult) {
  invariant(typeof dropResult === "undefined" || isObject(dropResult), "Drop result must either be an object or undefined.");
}
function getDroppableTargets(monitor) {
  const targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);
  targetIds.reverse();
  return targetIds;
}
function createEndDrag(manager) {
  return function endDrag() {
    const monitor = manager.getMonitor();
    const registry = manager.getRegistry();
    verifyIsDragging(monitor);
    const sourceId = monitor.getSourceId();
    if (sourceId != null) {
      const source = registry.getSource(sourceId, true);
      source.endDrag(monitor, sourceId);
      registry.unpinSource();
    }
    return {
      type: END_DRAG
    };
  };
}
function verifyIsDragging(monitor) {
  invariant(monitor.isDragging(), "Cannot call endDrag while not dragging.");
}
function matchesType(targetType, draggedItemType) {
  if (draggedItemType === null) {
    return targetType === null;
  }
  return Array.isArray(targetType) ? targetType.some(
    (t) => t === draggedItemType
  ) : targetType === draggedItemType;
}
function createHover(manager) {
  return function hover3(targetIdsArg, { clientOffset } = {}) {
    verifyTargetIdsIsArray(targetIdsArg);
    const targetIds = targetIdsArg.slice(0);
    const monitor = manager.getMonitor();
    const registry = manager.getRegistry();
    const draggedItemType = monitor.getItemType();
    removeNonMatchingTargetIds(targetIds, registry, draggedItemType);
    checkInvariants(targetIds, monitor, registry);
    hoverAllTargets(targetIds, monitor, registry);
    return {
      type: HOVER,
      payload: {
        targetIds,
        clientOffset: clientOffset || null
      }
    };
  };
}
function verifyTargetIdsIsArray(targetIdsArg) {
  invariant(Array.isArray(targetIdsArg), "Expected targetIds to be an array.");
}
function checkInvariants(targetIds, monitor, registry) {
  invariant(monitor.isDragging(), "Cannot call hover while not dragging.");
  invariant(!monitor.didDrop(), "Cannot call hover after drop.");
  for (let i = 0; i < targetIds.length; i++) {
    const targetId = targetIds[i];
    invariant(targetIds.lastIndexOf(targetId) === i, "Expected targetIds to be unique in the passed array.");
    const target = registry.getTarget(targetId);
    invariant(target, "Expected targetIds to be registered.");
  }
}
function removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {
  for (let i = targetIds.length - 1; i >= 0; i--) {
    const targetId = targetIds[i];
    const targetType = registry.getTargetType(targetId);
    if (!matchesType(targetType, draggedItemType)) {
      targetIds.splice(i, 1);
    }
  }
}
function hoverAllTargets(targetIds, monitor, registry) {
  targetIds.forEach(function(targetId) {
    const target = registry.getTarget(targetId);
    target.hover(monitor, targetId);
  });
}
function createPublishDragSource(manager) {
  return function publishDragSource() {
    const monitor = manager.getMonitor();
    if (monitor.isDragging()) {
      return {
        type: PUBLISH_DRAG_SOURCE
      };
    }
    return;
  };
}
function createDragDropActions(manager) {
  return {
    beginDrag: createBeginDrag(manager),
    publishDragSource: createPublishDragSource(manager),
    hover: createHover(manager),
    drop: createDrop(manager),
    endDrag: createEndDrag(manager)
  };
}
class DragDropManagerImpl {
  receiveBackend(backend) {
    this.backend = backend;
  }
  getMonitor() {
    return this.monitor;
  }
  getBackend() {
    return this.backend;
  }
  getRegistry() {
    return this.monitor.registry;
  }
  getActions() {
    const manager = this;
    const { dispatch } = this.store;
    function bindActionCreator(actionCreator) {
      return (...args) => {
        const action2 = actionCreator.apply(manager, args);
        if (typeof action2 !== "undefined") {
          dispatch(action2);
        }
      };
    }
    const actions = createDragDropActions(this);
    return Object.keys(actions).reduce((boundActions, key) => {
      const action2 = actions[key];
      boundActions[key] = bindActionCreator(action2);
      return boundActions;
    }, {});
  }
  dispatch(action2) {
    this.store.dispatch(action2);
  }
  constructor(store, monitor) {
    this.isSetUp = false;
    this.handleRefCountChange = () => {
      const shouldSetUp = this.store.getState().refCount > 0;
      if (this.backend) {
        if (shouldSetUp && !this.isSetUp) {
          this.backend.setup();
          this.isSetUp = true;
        } else if (!shouldSetUp && this.isSetUp) {
          this.backend.teardown();
          this.isSetUp = false;
        }
      }
    };
    this.store = store;
    this.monitor = monitor;
    store.subscribe(this.handleRefCountChange);
  }
}
function add(a, b) {
  return {
    x: a.x + b.x,
    y: a.y + b.y
  };
}
function subtract(a, b) {
  return {
    x: a.x - b.x,
    y: a.y - b.y
  };
}
function getSourceClientOffset(state) {
  const { clientOffset, initialClientOffset, initialSourceClientOffset } = state;
  if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {
    return null;
  }
  return subtract(add(clientOffset, initialSourceClientOffset), initialClientOffset);
}
function getDifferenceFromInitialOffset(state) {
  const { clientOffset, initialClientOffset } = state;
  if (!clientOffset || !initialClientOffset) {
    return null;
  }
  return subtract(clientOffset, initialClientOffset);
}
const NONE = [];
const ALL = [];
NONE.__IS_NONE__ = true;
ALL.__IS_ALL__ = true;
function areDirty(dirtyIds, handlerIds) {
  if (dirtyIds === NONE) {
    return false;
  }
  if (dirtyIds === ALL || typeof handlerIds === "undefined") {
    return true;
  }
  const commonIds = intersection(handlerIds, dirtyIds);
  return commonIds.length > 0;
}
class DragDropMonitorImpl {
  subscribeToStateChange(listener, options = {}) {
    const { handlerIds } = options;
    invariant(typeof listener === "function", "listener must be a function.");
    invariant(typeof handlerIds === "undefined" || Array.isArray(handlerIds), "handlerIds, when specified, must be an array of strings.");
    let prevStateId = this.store.getState().stateId;
    const handleChange = () => {
      const state = this.store.getState();
      const currentStateId = state.stateId;
      try {
        const canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !areDirty(state.dirtyHandlerIds, handlerIds);
        if (!canSkipListener) {
          listener();
        }
      } finally {
        prevStateId = currentStateId;
      }
    };
    return this.store.subscribe(handleChange);
  }
  subscribeToOffsetChange(listener) {
    invariant(typeof listener === "function", "listener must be a function.");
    let previousState = this.store.getState().dragOffset;
    const handleChange = () => {
      const nextState = this.store.getState().dragOffset;
      if (nextState === previousState) {
        return;
      }
      previousState = nextState;
      listener();
    };
    return this.store.subscribe(handleChange);
  }
  canDragSource(sourceId) {
    if (!sourceId) {
      return false;
    }
    const source = this.registry.getSource(sourceId);
    invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);
    if (this.isDragging()) {
      return false;
    }
    return source.canDrag(this, sourceId);
  }
  canDropOnTarget(targetId) {
    if (!targetId) {
      return false;
    }
    const target = this.registry.getTarget(targetId);
    invariant(target, `Expected to find a valid target. targetId=${targetId}`);
    if (!this.isDragging() || this.didDrop()) {
      return false;
    }
    const targetType = this.registry.getTargetType(targetId);
    const draggedItemType = this.getItemType();
    return matchesType(targetType, draggedItemType) && target.canDrop(this, targetId);
  }
  isDragging() {
    return Boolean(this.getItemType());
  }
  isDraggingSource(sourceId) {
    if (!sourceId) {
      return false;
    }
    const source = this.registry.getSource(sourceId, true);
    invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);
    if (!this.isDragging() || !this.isSourcePublic()) {
      return false;
    }
    const sourceType = this.registry.getSourceType(sourceId);
    const draggedItemType = this.getItemType();
    if (sourceType !== draggedItemType) {
      return false;
    }
    return source.isDragging(this, sourceId);
  }
  isOverTarget(targetId, options = {
    shallow: false
  }) {
    if (!targetId) {
      return false;
    }
    const { shallow } = options;
    if (!this.isDragging()) {
      return false;
    }
    const targetType = this.registry.getTargetType(targetId);
    const draggedItemType = this.getItemType();
    if (draggedItemType && !matchesType(targetType, draggedItemType)) {
      return false;
    }
    const targetIds = this.getTargetIds();
    if (!targetIds.length) {
      return false;
    }
    const index2 = targetIds.indexOf(targetId);
    if (shallow) {
      return index2 === targetIds.length - 1;
    } else {
      return index2 > -1;
    }
  }
  getItemType() {
    return this.store.getState().dragOperation.itemType;
  }
  getItem() {
    return this.store.getState().dragOperation.item;
  }
  getSourceId() {
    return this.store.getState().dragOperation.sourceId;
  }
  getTargetIds() {
    return this.store.getState().dragOperation.targetIds;
  }
  getDropResult() {
    return this.store.getState().dragOperation.dropResult;
  }
  didDrop() {
    return this.store.getState().dragOperation.didDrop;
  }
  isSourcePublic() {
    return Boolean(this.store.getState().dragOperation.isSourcePublic);
  }
  getInitialClientOffset() {
    return this.store.getState().dragOffset.initialClientOffset;
  }
  getInitialSourceClientOffset() {
    return this.store.getState().dragOffset.initialSourceClientOffset;
  }
  getClientOffset() {
    return this.store.getState().dragOffset.clientOffset;
  }
  getSourceClientOffset() {
    return getSourceClientOffset(this.store.getState().dragOffset);
  }
  getDifferenceFromInitialOffset() {
    return getDifferenceFromInitialOffset(this.store.getState().dragOffset);
  }
  constructor(store, registry) {
    this.store = store;
    this.registry = registry;
  }
}
const scope = typeof global !== "undefined" ? global : self;
const BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
function makeRequestCallFromTimer(callback) {
  return function requestCall() {
    const timeoutHandle = setTimeout(handleTimer, 0);
    const intervalHandle = setInterval(handleTimer, 50);
    function handleTimer() {
      clearTimeout(timeoutHandle);
      clearInterval(intervalHandle);
      callback();
    }
  };
}
function makeRequestCallFromMutationObserver(callback) {
  let toggle = 1;
  const observer2 = new BrowserMutationObserver(callback);
  const node = document.createTextNode("");
  observer2.observe(node, {
    characterData: true
  });
  return function requestCall() {
    toggle = -toggle;
    node.data = toggle;
  };
}
const makeRequestCall = typeof BrowserMutationObserver === "function" ? makeRequestCallFromMutationObserver : makeRequestCallFromTimer;
class AsapQueue {
  enqueueTask(task) {
    const { queue: q2, requestFlush } = this;
    if (!q2.length) {
      requestFlush();
      this.flushing = true;
    }
    q2[q2.length] = task;
  }
  constructor() {
    this.queue = [];
    this.pendingErrors = [];
    this.flushing = false;
    this.index = 0;
    this.capacity = 1024;
    this.flush = () => {
      const { queue: q2 } = this;
      while (this.index < q2.length) {
        const currentIndex = this.index;
        this.index++;
        q2[currentIndex].call();
        if (this.index > this.capacity) {
          for (let scan = 0, newLength = q2.length - this.index; scan < newLength; scan++) {
            q2[scan] = q2[scan + this.index];
          }
          q2.length -= this.index;
          this.index = 0;
        }
      }
      q2.length = 0;
      this.index = 0;
      this.flushing = false;
    };
    this.registerPendingError = (err) => {
      this.pendingErrors.push(err);
      this.requestErrorThrow();
    };
    this.requestFlush = makeRequestCall(this.flush);
    this.requestErrorThrow = makeRequestCallFromTimer(() => {
      if (this.pendingErrors.length) {
        throw this.pendingErrors.shift();
      }
    });
  }
}
class RawTask {
  call() {
    try {
      this.task && this.task();
    } catch (error) {
      this.onError(error);
    } finally {
      this.task = null;
      this.release(this);
    }
  }
  constructor(onError, release) {
    this.onError = onError;
    this.release = release;
    this.task = null;
  }
}
class TaskFactory {
  create(task) {
    const tasks = this.freeTasks;
    const t1 = tasks.length ? tasks.pop() : new RawTask(
      this.onError,
      (t) => tasks[tasks.length] = t
    );
    t1.task = task;
    return t1;
  }
  constructor(onError) {
    this.onError = onError;
    this.freeTasks = [];
  }
}
const asapQueue = new AsapQueue();
const taskFactory = new TaskFactory(asapQueue.registerPendingError);
function asap(task) {
  asapQueue.enqueueTask(taskFactory.create(task));
}
const ADD_SOURCE = "dnd-core/ADD_SOURCE";
const ADD_TARGET = "dnd-core/ADD_TARGET";
const REMOVE_SOURCE = "dnd-core/REMOVE_SOURCE";
const REMOVE_TARGET = "dnd-core/REMOVE_TARGET";
function addSource(sourceId) {
  return {
    type: ADD_SOURCE,
    payload: {
      sourceId
    }
  };
}
function addTarget(targetId) {
  return {
    type: ADD_TARGET,
    payload: {
      targetId
    }
  };
}
function removeSource(sourceId) {
  return {
    type: REMOVE_SOURCE,
    payload: {
      sourceId
    }
  };
}
function removeTarget(targetId) {
  return {
    type: REMOVE_TARGET,
    payload: {
      targetId
    }
  };
}
function validateSourceContract(source) {
  invariant(typeof source.canDrag === "function", "Expected canDrag to be a function.");
  invariant(typeof source.beginDrag === "function", "Expected beginDrag to be a function.");
  invariant(typeof source.endDrag === "function", "Expected endDrag to be a function.");
}
function validateTargetContract(target) {
  invariant(typeof target.canDrop === "function", "Expected canDrop to be a function.");
  invariant(typeof target.hover === "function", "Expected hover to be a function.");
  invariant(typeof target.drop === "function", "Expected beginDrag to be a function.");
}
function validateType(type, allowArray) {
  if (allowArray && Array.isArray(type)) {
    type.forEach(
      (t) => validateType(t, false)
    );
    return;
  }
  invariant(typeof type === "string" || typeof type === "symbol", allowArray ? "Type can only be a string, a symbol, or an array of either." : "Type can only be a string or a symbol.");
}
var HandlerRole;
(function(HandlerRole2) {
  HandlerRole2["SOURCE"] = "SOURCE";
  HandlerRole2["TARGET"] = "TARGET";
})(HandlerRole || (HandlerRole = {}));
let nextUniqueId = 0;
function getNextUniqueId() {
  return nextUniqueId++;
}
function getNextHandlerId(role) {
  const id = getNextUniqueId().toString();
  switch (role) {
    case HandlerRole.SOURCE:
      return `S${id}`;
    case HandlerRole.TARGET:
      return `T${id}`;
    default:
      throw new Error(`Unknown Handler Role: ${role}`);
  }
}
function parseRoleFromHandlerId(handlerId) {
  switch (handlerId[0]) {
    case "S":
      return HandlerRole.SOURCE;
    case "T":
      return HandlerRole.TARGET;
    default:
      throw new Error(`Cannot parse handler ID: ${handlerId}`);
  }
}
function mapContainsValue(map3, searchValue) {
  const entries = map3.entries();
  let isDone = false;
  do {
    const { done, value: [, value] } = entries.next();
    if (value === searchValue) {
      return true;
    }
    isDone = !!done;
  } while (!isDone);
  return false;
}
class HandlerRegistryImpl {
  addSource(type, source) {
    validateType(type);
    validateSourceContract(source);
    const sourceId = this.addHandler(HandlerRole.SOURCE, type, source);
    this.store.dispatch(addSource(sourceId));
    return sourceId;
  }
  addTarget(type, target) {
    validateType(type, true);
    validateTargetContract(target);
    const targetId = this.addHandler(HandlerRole.TARGET, type, target);
    this.store.dispatch(addTarget(targetId));
    return targetId;
  }
  containsHandler(handler) {
    return mapContainsValue(this.dragSources, handler) || mapContainsValue(this.dropTargets, handler);
  }
  getSource(sourceId, includePinned = false) {
    invariant(this.isSourceId(sourceId), "Expected a valid source ID.");
    const isPinned = includePinned && sourceId === this.pinnedSourceId;
    const source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId);
    return source;
  }
  getTarget(targetId) {
    invariant(this.isTargetId(targetId), "Expected a valid target ID.");
    return this.dropTargets.get(targetId);
  }
  getSourceType(sourceId) {
    invariant(this.isSourceId(sourceId), "Expected a valid source ID.");
    return this.types.get(sourceId);
  }
  getTargetType(targetId) {
    invariant(this.isTargetId(targetId), "Expected a valid target ID.");
    return this.types.get(targetId);
  }
  isSourceId(handlerId) {
    const role = parseRoleFromHandlerId(handlerId);
    return role === HandlerRole.SOURCE;
  }
  isTargetId(handlerId) {
    const role = parseRoleFromHandlerId(handlerId);
    return role === HandlerRole.TARGET;
  }
  removeSource(sourceId) {
    invariant(this.getSource(sourceId), "Expected an existing source.");
    this.store.dispatch(removeSource(sourceId));
    asap(() => {
      this.dragSources.delete(sourceId);
      this.types.delete(sourceId);
    });
  }
  removeTarget(targetId) {
    invariant(this.getTarget(targetId), "Expected an existing target.");
    this.store.dispatch(removeTarget(targetId));
    this.dropTargets.delete(targetId);
    this.types.delete(targetId);
  }
  pinSource(sourceId) {
    const source = this.getSource(sourceId);
    invariant(source, "Expected an existing source.");
    this.pinnedSourceId = sourceId;
    this.pinnedSource = source;
  }
  unpinSource() {
    invariant(this.pinnedSource, "No source is pinned at the time.");
    this.pinnedSourceId = null;
    this.pinnedSource = null;
  }
  addHandler(role, type, handler) {
    const id = getNextHandlerId(role);
    this.types.set(id, type);
    if (role === HandlerRole.SOURCE) {
      this.dragSources.set(id, handler);
    } else if (role === HandlerRole.TARGET) {
      this.dropTargets.set(id, handler);
    }
    return id;
  }
  constructor(store) {
    this.types = /* @__PURE__ */ new Map();
    this.dragSources = /* @__PURE__ */ new Map();
    this.dropTargets = /* @__PURE__ */ new Map();
    this.pinnedSourceId = null;
    this.pinnedSource = null;
    this.store = store;
  }
}
const strictEquality = (a, b) => a === b;
function areCoordsEqual(offsetA, offsetB) {
  if (!offsetA && !offsetB) {
    return true;
  } else if (!offsetA || !offsetB) {
    return false;
  } else {
    return offsetA.x === offsetB.x && offsetA.y === offsetB.y;
  }
}
function areArraysEqual(a, b, isEqual2 = strictEquality) {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; ++i) {
    if (!isEqual2(a[i], b[i])) {
      return false;
    }
  }
  return true;
}
function reduce$5(_state = NONE, action2) {
  switch (action2.type) {
    case HOVER:
      break;
    case ADD_SOURCE:
    case ADD_TARGET:
    case REMOVE_TARGET:
    case REMOVE_SOURCE:
      return NONE;
    case BEGIN_DRAG:
    case PUBLISH_DRAG_SOURCE:
    case END_DRAG:
    case DROP:
    default:
      return ALL;
  }
  const { targetIds = [], prevTargetIds = [] } = action2.payload;
  const result = xor(targetIds, prevTargetIds);
  const didChange = result.length > 0 || !areArraysEqual(targetIds, prevTargetIds);
  if (!didChange) {
    return NONE;
  }
  const prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];
  const innermostTargetId = targetIds[targetIds.length - 1];
  if (prevInnermostTargetId !== innermostTargetId) {
    if (prevInnermostTargetId) {
      result.push(prevInnermostTargetId);
    }
    if (innermostTargetId) {
      result.push(innermostTargetId);
    }
  }
  return result;
}
function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys3 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys3.forEach(function(key) {
      _defineProperty$3(target, key, source[key]);
    });
  }
  return target;
}
const initialState$1 = {
  initialSourceClientOffset: null,
  initialClientOffset: null,
  clientOffset: null
};
function reduce$4(state = initialState$1, action2) {
  const { payload } = action2;
  switch (action2.type) {
    case INIT_COORDS:
    case BEGIN_DRAG:
      return {
        initialSourceClientOffset: payload.sourceClientOffset,
        initialClientOffset: payload.clientOffset,
        clientOffset: payload.clientOffset
      };
    case HOVER:
      if (areCoordsEqual(state.clientOffset, payload.clientOffset)) {
        return state;
      }
      return _objectSpread$3({}, state, {
        clientOffset: payload.clientOffset
      });
    case END_DRAG:
    case DROP:
      return initialState$1;
    default:
      return state;
  }
}
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys3 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys3.forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    });
  }
  return target;
}
const initialState = {
  itemType: null,
  item: null,
  sourceId: null,
  targetIds: [],
  dropResult: null,
  didDrop: false,
  isSourcePublic: null
};
function reduce$3(state = initialState, action2) {
  const { payload } = action2;
  switch (action2.type) {
    case BEGIN_DRAG:
      return _objectSpread$2({}, state, {
        itemType: payload.itemType,
        item: payload.item,
        sourceId: payload.sourceId,
        isSourcePublic: payload.isSourcePublic,
        dropResult: null,
        didDrop: false
      });
    case PUBLISH_DRAG_SOURCE:
      return _objectSpread$2({}, state, {
        isSourcePublic: true
      });
    case HOVER:
      return _objectSpread$2({}, state, {
        targetIds: payload.targetIds
      });
    case REMOVE_TARGET:
      if (state.targetIds.indexOf(payload.targetId) === -1) {
        return state;
      }
      return _objectSpread$2({}, state, {
        targetIds: without$1(state.targetIds, payload.targetId)
      });
    case DROP:
      return _objectSpread$2({}, state, {
        dropResult: payload.dropResult,
        didDrop: true,
        targetIds: []
      });
    case END_DRAG:
      return _objectSpread$2({}, state, {
        itemType: null,
        item: null,
        sourceId: null,
        dropResult: null,
        didDrop: false,
        isSourcePublic: null,
        targetIds: []
      });
    default:
      return state;
  }
}
function reduce$2(state = 0, action2) {
  switch (action2.type) {
    case ADD_SOURCE:
    case ADD_TARGET:
      return state + 1;
    case REMOVE_SOURCE:
    case REMOVE_TARGET:
      return state - 1;
    default:
      return state;
  }
}
function reduce$1(state = 0) {
  return state + 1;
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys3 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys3.forEach(function(key) {
      _defineProperty$1(target, key, source[key]);
    });
  }
  return target;
}
function reduce(state = {}, action2) {
  return {
    dirtyHandlerIds: reduce$5(state.dirtyHandlerIds, {
      type: action2.type,
      payload: _objectSpread$1({}, action2.payload, {
        prevTargetIds: get4(state, "dragOperation.targetIds", [])
      })
    }),
    dragOffset: reduce$4(state.dragOffset, action2),
    refCount: reduce$2(state.refCount, action2),
    dragOperation: reduce$3(state.dragOperation, action2),
    stateId: reduce$1(state.stateId)
  };
}
function createDragDropManager(backendFactory, globalContext = void 0, backendOptions = {}, debugMode = false) {
  const store = makeStoreInstance(debugMode);
  const monitor = new DragDropMonitorImpl(store, new HandlerRegistryImpl(store));
  const manager = new DragDropManagerImpl(store, monitor);
  const backend = backendFactory(manager, globalContext, backendOptions);
  manager.receiveBackend(backend);
  return manager;
}
function makeStoreInstance(debugMode) {
  const reduxDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__;
  return createStore(reduce, debugMode && reduxDevTools && reduxDevTools({
    name: "dnd-core",
    instanceId: "dnd-core"
  }));
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
let refCount = 0;
const INSTANCE_SYM = Symbol.for("__REACT_DND_CONTEXT_INSTANCE__");
var DndProvider = /* @__PURE__ */ memo(function DndProvider2(_param) {
  var { children } = _param, props = _objectWithoutProperties(_param, [
    "children"
  ]);
  const [manager, isGlobalInstance] = getDndContextValue(props);
  useEffect(() => {
    if (isGlobalInstance) {
      const context = getGlobalContext();
      ++refCount;
      return () => {
        if (--refCount === 0) {
          context[INSTANCE_SYM] = null;
        }
      };
    }
    return;
  }, []);
  return /* @__PURE__ */ jsx(DndContext.Provider, {
    value: manager,
    children
  });
});
function getDndContextValue(props) {
  if ("manager" in props) {
    const manager2 = {
      dragDropManager: props.manager
    };
    return [
      manager2,
      false
    ];
  }
  const manager = createSingletonDndContext(props.backend, props.context, props.options, props.debugMode);
  const isGlobalInstance = !props.context;
  return [
    manager,
    isGlobalInstance
  ];
}
function createSingletonDndContext(backend, context = getGlobalContext(), options, debugMode) {
  const ctx = context;
  if (!ctx[INSTANCE_SYM]) {
    ctx[INSTANCE_SYM] = {
      dragDropManager: createDragDropManager(backend, context, options, debugMode)
    };
  }
  return ctx[INSTANCE_SYM];
}
function getGlobalContext() {
  return typeof global !== "undefined" ? global : window;
}
var fastDeepEqual = function equal(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length, i, keys2;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!equal(a[i], b[i]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys2 = Object.keys(a);
    length = keys2.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys2[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      var key = keys2[i];
      if (!equal(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
const useIsomorphicLayoutEffect = typeof window !== "undefined" ? useLayoutEffect : useEffect;
function useCollector(monitor, collect, onUpdate) {
  const [collected, setCollected] = useState(
    () => collect(monitor)
  );
  const updateCollected = useCallback(() => {
    const nextValue = collect(monitor);
    if (!fastDeepEqual(collected, nextValue)) {
      setCollected(nextValue);
      if (onUpdate) {
        onUpdate();
      }
    }
  }, [
    collected,
    monitor,
    onUpdate
  ]);
  useIsomorphicLayoutEffect(updateCollected);
  return [
    collected,
    updateCollected
  ];
}
function useMonitorOutput(monitor, collect, onCollect) {
  const [collected, updateCollected] = useCollector(monitor, collect, onCollect);
  useIsomorphicLayoutEffect(function subscribeToMonitorStateChange() {
    const handlerId = monitor.getHandlerId();
    if (handlerId == null) {
      return;
    }
    return monitor.subscribeToStateChange(updateCollected, {
      handlerIds: [
        handlerId
      ]
    });
  }, [
    monitor,
    updateCollected
  ]);
  return collected;
}
function useCollectedProps(collector, monitor, connector) {
  return useMonitorOutput(
    monitor,
    collector || (() => ({})),
    () => connector.reconnect()
  );
}
function useOptionalFactory(arg, deps) {
  const memoDeps = [
    ...deps || []
  ];
  if (deps == null && typeof arg !== "function") {
    memoDeps.push(arg);
  }
  return useMemo(() => {
    return typeof arg === "function" ? arg() : arg;
  }, memoDeps);
}
function useConnectDragSource(connector) {
  return useMemo(
    () => connector.hooks.dragSource(),
    [
      connector
    ]
  );
}
function useConnectDragPreview(connector) {
  return useMemo(
    () => connector.hooks.dragPreview(),
    [
      connector
    ]
  );
}
let isCallingCanDrag = false;
let isCallingIsDragging = false;
class DragSourceMonitorImpl {
  receiveHandlerId(sourceId) {
    this.sourceId = sourceId;
  }
  getHandlerId() {
    return this.sourceId;
  }
  canDrag() {
    invariant(!isCallingCanDrag, "You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
    try {
      isCallingCanDrag = true;
      return this.internalMonitor.canDragSource(this.sourceId);
    } finally {
      isCallingCanDrag = false;
    }
  }
  isDragging() {
    if (!this.sourceId) {
      return false;
    }
    invariant(!isCallingIsDragging, "You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
    try {
      isCallingIsDragging = true;
      return this.internalMonitor.isDraggingSource(this.sourceId);
    } finally {
      isCallingIsDragging = false;
    }
  }
  subscribeToStateChange(listener, options) {
    return this.internalMonitor.subscribeToStateChange(listener, options);
  }
  isDraggingSource(sourceId) {
    return this.internalMonitor.isDraggingSource(sourceId);
  }
  isOverTarget(targetId, options) {
    return this.internalMonitor.isOverTarget(targetId, options);
  }
  getTargetIds() {
    return this.internalMonitor.getTargetIds();
  }
  isSourcePublic() {
    return this.internalMonitor.isSourcePublic();
  }
  getSourceId() {
    return this.internalMonitor.getSourceId();
  }
  subscribeToOffsetChange(listener) {
    return this.internalMonitor.subscribeToOffsetChange(listener);
  }
  canDragSource(sourceId) {
    return this.internalMonitor.canDragSource(sourceId);
  }
  canDropOnTarget(targetId) {
    return this.internalMonitor.canDropOnTarget(targetId);
  }
  getItemType() {
    return this.internalMonitor.getItemType();
  }
  getItem() {
    return this.internalMonitor.getItem();
  }
  getDropResult() {
    return this.internalMonitor.getDropResult();
  }
  didDrop() {
    return this.internalMonitor.didDrop();
  }
  getInitialClientOffset() {
    return this.internalMonitor.getInitialClientOffset();
  }
  getInitialSourceClientOffset() {
    return this.internalMonitor.getInitialSourceClientOffset();
  }
  getSourceClientOffset() {
    return this.internalMonitor.getSourceClientOffset();
  }
  getClientOffset() {
    return this.internalMonitor.getClientOffset();
  }
  getDifferenceFromInitialOffset() {
    return this.internalMonitor.getDifferenceFromInitialOffset();
  }
  constructor(manager) {
    this.sourceId = null;
    this.internalMonitor = manager.getMonitor();
  }
}
let isCallingCanDrop = false;
class DropTargetMonitorImpl {
  receiveHandlerId(targetId) {
    this.targetId = targetId;
  }
  getHandlerId() {
    return this.targetId;
  }
  subscribeToStateChange(listener, options) {
    return this.internalMonitor.subscribeToStateChange(listener, options);
  }
  canDrop() {
    if (!this.targetId) {
      return false;
    }
    invariant(!isCallingCanDrop, "You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");
    try {
      isCallingCanDrop = true;
      return this.internalMonitor.canDropOnTarget(this.targetId);
    } finally {
      isCallingCanDrop = false;
    }
  }
  isOver(options) {
    if (!this.targetId) {
      return false;
    }
    return this.internalMonitor.isOverTarget(this.targetId, options);
  }
  getItemType() {
    return this.internalMonitor.getItemType();
  }
  getItem() {
    return this.internalMonitor.getItem();
  }
  getDropResult() {
    return this.internalMonitor.getDropResult();
  }
  didDrop() {
    return this.internalMonitor.didDrop();
  }
  getInitialClientOffset() {
    return this.internalMonitor.getInitialClientOffset();
  }
  getInitialSourceClientOffset() {
    return this.internalMonitor.getInitialSourceClientOffset();
  }
  getSourceClientOffset() {
    return this.internalMonitor.getSourceClientOffset();
  }
  getClientOffset() {
    return this.internalMonitor.getClientOffset();
  }
  getDifferenceFromInitialOffset() {
    return this.internalMonitor.getDifferenceFromInitialOffset();
  }
  constructor(manager) {
    this.targetId = null;
    this.internalMonitor = manager.getMonitor();
  }
}
function registerTarget(type, target, manager) {
  const registry = manager.getRegistry();
  const targetId = registry.addTarget(type, target);
  return [
    targetId,
    () => registry.removeTarget(targetId)
  ];
}
function registerSource(type, source, manager) {
  const registry = manager.getRegistry();
  const sourceId = registry.addSource(type, source);
  return [
    sourceId,
    () => registry.removeSource(sourceId)
  ];
}
function shallowEqual(objA, objB, compare, compareContext) {
  let compareResult = compare ? compare.call(compareContext, objA, objB) : void 0;
  if (compareResult !== void 0) {
    return !!compareResult;
  }
  if (objA === objB) {
    return true;
  }
  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
  for (let idx = 0; idx < keysA.length; idx++) {
    const key = keysA[idx];
    if (!bHasOwnProperty(key)) {
      return false;
    }
    const valueA = objA[key];
    const valueB = objB[key];
    compareResult = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
    if (compareResult === false || compareResult === void 0 && valueA !== valueB) {
      return false;
    }
  }
  return true;
}
function isRef(obj) {
  return obj !== null && typeof obj === "object" && Object.prototype.hasOwnProperty.call(obj, "current");
}
function throwIfCompositeComponentElement(element) {
  if (typeof element.type === "string") {
    return;
  }
  const displayName = element.type.displayName || element.type.name || "the component";
  throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${displayName} into a <div>, or turn it into a drag source or a drop target itself.`);
}
function wrapHookToRecognizeElement(hook) {
  return (elementOrNode = null, options = null) => {
    if (!isValidElement(elementOrNode)) {
      const node = elementOrNode;
      hook(node, options);
      return node;
    }
    const element = elementOrNode;
    throwIfCompositeComponentElement(element);
    const ref = options ? (node) => hook(node, options) : hook;
    return cloneWithRef(element, ref);
  };
}
function wrapConnectorHooks(hooks2) {
  const wrappedHooks = {};
  Object.keys(hooks2).forEach((key) => {
    const hook = hooks2[key];
    if (key.endsWith("Ref")) {
      wrappedHooks[key] = hooks2[key];
    } else {
      const wrappedHook = wrapHookToRecognizeElement(hook);
      wrappedHooks[key] = () => wrappedHook;
    }
  });
  return wrappedHooks;
}
function setRef(ref, node) {
  if (typeof ref === "function") {
    ref(node);
  } else {
    ref.current = node;
  }
}
function cloneWithRef(element, newRef) {
  const previousRef = element.ref;
  invariant(typeof previousRef !== "string", "Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs");
  if (!previousRef) {
    return cloneElement(element, {
      ref: newRef
    });
  } else {
    return cloneElement(element, {
      ref: (node) => {
        setRef(previousRef, node);
        setRef(newRef, node);
      }
    });
  }
}
class SourceConnector {
  receiveHandlerId(newHandlerId) {
    if (this.handlerId === newHandlerId) {
      return;
    }
    this.handlerId = newHandlerId;
    this.reconnect();
  }
  get connectTarget() {
    return this.dragSource;
  }
  get dragSourceOptions() {
    return this.dragSourceOptionsInternal;
  }
  set dragSourceOptions(options) {
    this.dragSourceOptionsInternal = options;
  }
  get dragPreviewOptions() {
    return this.dragPreviewOptionsInternal;
  }
  set dragPreviewOptions(options) {
    this.dragPreviewOptionsInternal = options;
  }
  reconnect() {
    const didChange = this.reconnectDragSource();
    this.reconnectDragPreview(didChange);
  }
  reconnectDragSource() {
    const dragSource = this.dragSource;
    const didChange = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();
    if (didChange) {
      this.disconnectDragSource();
    }
    if (!this.handlerId) {
      return didChange;
    }
    if (!dragSource) {
      this.lastConnectedDragSource = dragSource;
      return didChange;
    }
    if (didChange) {
      this.lastConnectedHandlerId = this.handlerId;
      this.lastConnectedDragSource = dragSource;
      this.lastConnectedDragSourceOptions = this.dragSourceOptions;
      this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, dragSource, this.dragSourceOptions);
    }
    return didChange;
  }
  reconnectDragPreview(forceDidChange = false) {
    const dragPreview = this.dragPreview;
    const didChange = forceDidChange || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();
    if (didChange) {
      this.disconnectDragPreview();
    }
    if (!this.handlerId) {
      return;
    }
    if (!dragPreview) {
      this.lastConnectedDragPreview = dragPreview;
      return;
    }
    if (didChange) {
      this.lastConnectedHandlerId = this.handlerId;
      this.lastConnectedDragPreview = dragPreview;
      this.lastConnectedDragPreviewOptions = this.dragPreviewOptions;
      this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, dragPreview, this.dragPreviewOptions);
    }
  }
  didHandlerIdChange() {
    return this.lastConnectedHandlerId !== this.handlerId;
  }
  didConnectedDragSourceChange() {
    return this.lastConnectedDragSource !== this.dragSource;
  }
  didConnectedDragPreviewChange() {
    return this.lastConnectedDragPreview !== this.dragPreview;
  }
  didDragSourceOptionsChange() {
    return !shallowEqual(this.lastConnectedDragSourceOptions, this.dragSourceOptions);
  }
  didDragPreviewOptionsChange() {
    return !shallowEqual(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);
  }
  disconnectDragSource() {
    if (this.dragSourceUnsubscribe) {
      this.dragSourceUnsubscribe();
      this.dragSourceUnsubscribe = void 0;
    }
  }
  disconnectDragPreview() {
    if (this.dragPreviewUnsubscribe) {
      this.dragPreviewUnsubscribe();
      this.dragPreviewUnsubscribe = void 0;
      this.dragPreviewNode = null;
      this.dragPreviewRef = null;
    }
  }
  get dragSource() {
    return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;
  }
  get dragPreview() {
    return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;
  }
  clearDragSource() {
    this.dragSourceNode = null;
    this.dragSourceRef = null;
  }
  clearDragPreview() {
    this.dragPreviewNode = null;
    this.dragPreviewRef = null;
  }
  constructor(backend) {
    this.hooks = wrapConnectorHooks({
      dragSource: (node, options) => {
        this.clearDragSource();
        this.dragSourceOptions = options || null;
        if (isRef(node)) {
          this.dragSourceRef = node;
        } else {
          this.dragSourceNode = node;
        }
        this.reconnectDragSource();
      },
      dragPreview: (node, options) => {
        this.clearDragPreview();
        this.dragPreviewOptions = options || null;
        if (isRef(node)) {
          this.dragPreviewRef = node;
        } else {
          this.dragPreviewNode = node;
        }
        this.reconnectDragPreview();
      }
    });
    this.handlerId = null;
    this.dragSourceRef = null;
    this.dragSourceOptionsInternal = null;
    this.dragPreviewRef = null;
    this.dragPreviewOptionsInternal = null;
    this.lastConnectedHandlerId = null;
    this.lastConnectedDragSource = null;
    this.lastConnectedDragSourceOptions = null;
    this.lastConnectedDragPreview = null;
    this.lastConnectedDragPreviewOptions = null;
    this.backend = backend;
  }
}
class TargetConnector {
  get connectTarget() {
    return this.dropTarget;
  }
  reconnect() {
    const didChange = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();
    if (didChange) {
      this.disconnectDropTarget();
    }
    const dropTarget = this.dropTarget;
    if (!this.handlerId) {
      return;
    }
    if (!dropTarget) {
      this.lastConnectedDropTarget = dropTarget;
      return;
    }
    if (didChange) {
      this.lastConnectedHandlerId = this.handlerId;
      this.lastConnectedDropTarget = dropTarget;
      this.lastConnectedDropTargetOptions = this.dropTargetOptions;
      this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, dropTarget, this.dropTargetOptions);
    }
  }
  receiveHandlerId(newHandlerId) {
    if (newHandlerId === this.handlerId) {
      return;
    }
    this.handlerId = newHandlerId;
    this.reconnect();
  }
  get dropTargetOptions() {
    return this.dropTargetOptionsInternal;
  }
  set dropTargetOptions(options) {
    this.dropTargetOptionsInternal = options;
  }
  didHandlerIdChange() {
    return this.lastConnectedHandlerId !== this.handlerId;
  }
  didDropTargetChange() {
    return this.lastConnectedDropTarget !== this.dropTarget;
  }
  didOptionsChange() {
    return !shallowEqual(this.lastConnectedDropTargetOptions, this.dropTargetOptions);
  }
  disconnectDropTarget() {
    if (this.unsubscribeDropTarget) {
      this.unsubscribeDropTarget();
      this.unsubscribeDropTarget = void 0;
    }
  }
  get dropTarget() {
    return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;
  }
  clearDropTarget() {
    this.dropTargetRef = null;
    this.dropTargetNode = null;
  }
  constructor(backend) {
    this.hooks = wrapConnectorHooks({
      dropTarget: (node, options) => {
        this.clearDropTarget();
        this.dropTargetOptions = options;
        if (isRef(node)) {
          this.dropTargetRef = node;
        } else {
          this.dropTargetNode = node;
        }
        this.reconnect();
      }
    });
    this.handlerId = null;
    this.dropTargetRef = null;
    this.dropTargetOptionsInternal = null;
    this.lastConnectedHandlerId = null;
    this.lastConnectedDropTarget = null;
    this.lastConnectedDropTargetOptions = null;
    this.backend = backend;
  }
}
function useDragDropManager() {
  const { dragDropManager } = useContext(DndContext);
  invariant(dragDropManager != null, "Expected drag drop context");
  return dragDropManager;
}
function useDragSourceConnector(dragSourceOptions, dragPreviewOptions) {
  const manager = useDragDropManager();
  const connector = useMemo(
    () => new SourceConnector(manager.getBackend()),
    [
      manager
    ]
  );
  useIsomorphicLayoutEffect(() => {
    connector.dragSourceOptions = dragSourceOptions || null;
    connector.reconnect();
    return () => connector.disconnectDragSource();
  }, [
    connector,
    dragSourceOptions
  ]);
  useIsomorphicLayoutEffect(() => {
    connector.dragPreviewOptions = dragPreviewOptions || null;
    connector.reconnect();
    return () => connector.disconnectDragPreview();
  }, [
    connector,
    dragPreviewOptions
  ]);
  return connector;
}
function useDragSourceMonitor() {
  const manager = useDragDropManager();
  return useMemo(
    () => new DragSourceMonitorImpl(manager),
    [
      manager
    ]
  );
}
class DragSourceImpl {
  beginDrag() {
    const spec = this.spec;
    const monitor = this.monitor;
    let result = null;
    if (typeof spec.item === "object") {
      result = spec.item;
    } else if (typeof spec.item === "function") {
      result = spec.item(monitor);
    } else {
      result = {};
    }
    return result !== null && result !== void 0 ? result : null;
  }
  canDrag() {
    const spec = this.spec;
    const monitor = this.monitor;
    if (typeof spec.canDrag === "boolean") {
      return spec.canDrag;
    } else if (typeof spec.canDrag === "function") {
      return spec.canDrag(monitor);
    } else {
      return true;
    }
  }
  isDragging(globalMonitor, target) {
    const spec = this.spec;
    const monitor = this.monitor;
    const { isDragging } = spec;
    return isDragging ? isDragging(monitor) : target === globalMonitor.getSourceId();
  }
  endDrag() {
    const spec = this.spec;
    const monitor = this.monitor;
    const connector = this.connector;
    const { end } = spec;
    if (end) {
      end(monitor.getItem(), monitor);
    }
    connector.reconnect();
  }
  constructor(spec, monitor, connector) {
    this.spec = spec;
    this.monitor = monitor;
    this.connector = connector;
  }
}
function useDragSource(spec, monitor, connector) {
  const handler = useMemo(
    () => new DragSourceImpl(spec, monitor, connector),
    [
      monitor,
      connector
    ]
  );
  useEffect(() => {
    handler.spec = spec;
  }, [
    spec
  ]);
  return handler;
}
function useDragType(spec) {
  return useMemo(() => {
    const result = spec.type;
    invariant(result != null, "spec.type must be defined");
    return result;
  }, [
    spec
  ]);
}
function useRegisteredDragSource(spec, monitor, connector) {
  const manager = useDragDropManager();
  const handler = useDragSource(spec, monitor, connector);
  const itemType = useDragType(spec);
  useIsomorphicLayoutEffect(function registerDragSource() {
    if (itemType != null) {
      const [handlerId, unregister] = registerSource(itemType, handler, manager);
      monitor.receiveHandlerId(handlerId);
      connector.receiveHandlerId(handlerId);
      return unregister;
    }
    return;
  }, [
    manager,
    monitor,
    connector,
    handler,
    itemType
  ]);
}
function useDrag(specArg, deps) {
  const spec = useOptionalFactory(specArg, deps);
  invariant(!spec.begin, `useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)`);
  const monitor = useDragSourceMonitor();
  const connector = useDragSourceConnector(spec.options, spec.previewOptions);
  useRegisteredDragSource(spec, monitor, connector);
  return [
    useCollectedProps(spec.collect, monitor, connector),
    useConnectDragSource(connector),
    useConnectDragPreview(connector)
  ];
}
function useConnectDropTarget(connector) {
  return useMemo(
    () => connector.hooks.dropTarget(),
    [
      connector
    ]
  );
}
function useDropTargetConnector(options) {
  const manager = useDragDropManager();
  const connector = useMemo(
    () => new TargetConnector(manager.getBackend()),
    [
      manager
    ]
  );
  useIsomorphicLayoutEffect(() => {
    connector.dropTargetOptions = options || null;
    connector.reconnect();
    return () => connector.disconnectDropTarget();
  }, [
    options
  ]);
  return connector;
}
function useDropTargetMonitor() {
  const manager = useDragDropManager();
  return useMemo(
    () => new DropTargetMonitorImpl(manager),
    [
      manager
    ]
  );
}
function useAccept(spec) {
  const { accept } = spec;
  return useMemo(() => {
    invariant(spec.accept != null, "accept must be defined");
    return Array.isArray(accept) ? accept : [
      accept
    ];
  }, [
    accept
  ]);
}
class DropTargetImpl {
  canDrop() {
    const spec = this.spec;
    const monitor = this.monitor;
    return spec.canDrop ? spec.canDrop(monitor.getItem(), monitor) : true;
  }
  hover() {
    const spec = this.spec;
    const monitor = this.monitor;
    if (spec.hover) {
      spec.hover(monitor.getItem(), monitor);
    }
  }
  drop() {
    const spec = this.spec;
    const monitor = this.monitor;
    if (spec.drop) {
      return spec.drop(monitor.getItem(), monitor);
    }
    return;
  }
  constructor(spec, monitor) {
    this.spec = spec;
    this.monitor = monitor;
  }
}
function useDropTarget(spec, monitor) {
  const dropTarget = useMemo(
    () => new DropTargetImpl(spec, monitor),
    [
      monitor
    ]
  );
  useEffect(() => {
    dropTarget.spec = spec;
  }, [
    spec
  ]);
  return dropTarget;
}
function useRegisteredDropTarget(spec, monitor, connector) {
  const manager = useDragDropManager();
  const dropTarget = useDropTarget(spec, monitor);
  const accept = useAccept(spec);
  useIsomorphicLayoutEffect(function registerDropTarget() {
    const [handlerId, unregister] = registerTarget(accept, dropTarget, manager);
    monitor.receiveHandlerId(handlerId);
    connector.receiveHandlerId(handlerId);
    return unregister;
  }, [
    manager,
    monitor,
    dropTarget,
    connector,
    accept.map(
      (a) => a.toString()
    ).join("|")
  ]);
}
function useDrop(specArg, deps) {
  const spec = useOptionalFactory(specArg, deps);
  const monitor = useDropTargetMonitor();
  const connector = useDropTargetConnector(spec.options);
  useRegisteredDropTarget(spec, monitor, connector);
  return [
    useCollectedProps(spec.collect, monitor, connector),
    useConnectDropTarget(connector)
  ];
}
function memoize(fn) {
  let result = null;
  const memoized = () => {
    if (result == null) {
      result = fn();
    }
    return result;
  };
  return memoized;
}
function without(items, item) {
  return items.filter(
    (i) => i !== item
  );
}
function union(itemsA, itemsB) {
  const set5 = /* @__PURE__ */ new Set();
  const insertItem = (item) => set5.add(item);
  itemsA.forEach(insertItem);
  itemsB.forEach(insertItem);
  const result = [];
  set5.forEach(
    (key) => result.push(key)
  );
  return result;
}
class EnterLeaveCounter {
  enter(enteringNode) {
    const previousLength = this.entered.length;
    const isNodeEntered = (node) => this.isNodeInDocument(node) && (!node.contains || node.contains(enteringNode));
    this.entered = union(this.entered.filter(isNodeEntered), [
      enteringNode
    ]);
    return previousLength === 0 && this.entered.length > 0;
  }
  leave(leavingNode) {
    const previousLength = this.entered.length;
    this.entered = without(this.entered.filter(this.isNodeInDocument), leavingNode);
    return previousLength > 0 && this.entered.length === 0;
  }
  reset() {
    this.entered = [];
  }
  constructor(isNodeInDocument) {
    this.entered = [];
    this.isNodeInDocument = isNodeInDocument;
  }
}
class NativeDragSource {
  initializeExposedProperties() {
    Object.keys(this.config.exposeProperties).forEach((property2) => {
      Object.defineProperty(this.item, property2, {
        configurable: true,
        enumerable: true,
        get() {
          console.warn(`Browser doesn't allow reading "${property2}" until the drop event.`);
          return null;
        }
      });
    });
  }
  loadDataTransfer(dataTransfer) {
    if (dataTransfer) {
      const newProperties = {};
      Object.keys(this.config.exposeProperties).forEach((property2) => {
        const propertyFn = this.config.exposeProperties[property2];
        if (propertyFn != null) {
          newProperties[property2] = {
            value: propertyFn(dataTransfer, this.config.matchesTypes),
            configurable: true,
            enumerable: true
          };
        }
      });
      Object.defineProperties(this.item, newProperties);
    }
  }
  canDrag() {
    return true;
  }
  beginDrag() {
    return this.item;
  }
  isDragging(monitor, handle) {
    return handle === monitor.getSourceId();
  }
  endDrag() {
  }
  constructor(config) {
    this.config = config;
    this.item = {};
    this.initializeExposedProperties();
  }
}
const FILE = "__NATIVE_FILE__";
const URL = "__NATIVE_URL__";
const TEXT = "__NATIVE_TEXT__";
const HTML = "__NATIVE_HTML__";
var NativeTypes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FILE,
  URL,
  TEXT,
  HTML
}, Symbol.toStringTag, { value: "Module" }));
function getDataFromDataTransfer(dataTransfer, typesToTry, defaultValue) {
  const result = typesToTry.reduce(
    (resultSoFar, typeToTry) => resultSoFar || dataTransfer.getData(typeToTry),
    ""
  );
  return result != null ? result : defaultValue;
}
const nativeTypesConfig = {
  [FILE]: {
    exposeProperties: {
      files: (dataTransfer) => Array.prototype.slice.call(dataTransfer.files),
      items: (dataTransfer) => dataTransfer.items,
      dataTransfer: (dataTransfer) => dataTransfer
    },
    matchesTypes: [
      "Files"
    ]
  },
  [HTML]: {
    exposeProperties: {
      html: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, ""),
      dataTransfer: (dataTransfer) => dataTransfer
    },
    matchesTypes: [
      "Html",
      "text/html"
    ]
  },
  [URL]: {
    exposeProperties: {
      urls: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, "").split("\n"),
      dataTransfer: (dataTransfer) => dataTransfer
    },
    matchesTypes: [
      "Url",
      "text/uri-list"
    ]
  },
  [TEXT]: {
    exposeProperties: {
      text: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, ""),
      dataTransfer: (dataTransfer) => dataTransfer
    },
    matchesTypes: [
      "Text",
      "text/plain"
    ]
  }
};
function createNativeDragSource(type, dataTransfer) {
  const config = nativeTypesConfig[type];
  if (!config) {
    throw new Error(`native type ${type} has no configuration`);
  }
  const result = new NativeDragSource(config);
  result.loadDataTransfer(dataTransfer);
  return result;
}
function matchNativeItemType(dataTransfer) {
  if (!dataTransfer) {
    return null;
  }
  const dataTransferTypes = Array.prototype.slice.call(dataTransfer.types || []);
  return Object.keys(nativeTypesConfig).filter((nativeItemType) => {
    const typeConfig = nativeTypesConfig[nativeItemType];
    if (!(typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.matchesTypes)) {
      return false;
    }
    return typeConfig.matchesTypes.some(
      (t) => dataTransferTypes.indexOf(t) > -1
    );
  })[0] || null;
}
const isFirefox = memoize(
  () => /firefox/i.test(navigator.userAgent)
);
const isSafari = memoize(
  () => Boolean(window.safari)
);
class MonotonicInterpolant {
  interpolate(x) {
    const { xs, ys, c1s, c2s, c3s } = this;
    let i = xs.length - 1;
    if (x === xs[i]) {
      return ys[i];
    }
    let low = 0;
    let high = c3s.length - 1;
    let mid;
    while (low <= high) {
      mid = Math.floor(0.5 * (low + high));
      const xHere = xs[mid];
      if (xHere < x) {
        low = mid + 1;
      } else if (xHere > x) {
        high = mid - 1;
      } else {
        return ys[mid];
      }
    }
    i = Math.max(0, high);
    const diff2 = x - xs[i];
    const diffSq = diff2 * diff2;
    return ys[i] + c1s[i] * diff2 + c2s[i] * diffSq + c3s[i] * diff2 * diffSq;
  }
  constructor(xs, ys) {
    const { length } = xs;
    const indexes = [];
    for (let i = 0; i < length; i++) {
      indexes.push(i);
    }
    indexes.sort(
      (a, b) => xs[a] < xs[b] ? -1 : 1
    );
    const dxs = [];
    const ms = [];
    let dx;
    let dy;
    for (let i1 = 0; i1 < length - 1; i1++) {
      dx = xs[i1 + 1] - xs[i1];
      dy = ys[i1 + 1] - ys[i1];
      dxs.push(dx);
      ms.push(dy / dx);
    }
    const c1s = [
      ms[0]
    ];
    for (let i2 = 0; i2 < dxs.length - 1; i2++) {
      const m22 = ms[i2];
      const mNext = ms[i2 + 1];
      if (m22 * mNext <= 0) {
        c1s.push(0);
      } else {
        dx = dxs[i2];
        const dxNext = dxs[i2 + 1];
        const common = dx + dxNext;
        c1s.push(3 * common / ((common + dxNext) / m22 + (common + dx) / mNext));
      }
    }
    c1s.push(ms[ms.length - 1]);
    const c2s = [];
    const c3s = [];
    let m2;
    for (let i3 = 0; i3 < c1s.length - 1; i3++) {
      m2 = ms[i3];
      const c1 = c1s[i3];
      const invDx = 1 / dxs[i3];
      const common = c1 + c1s[i3 + 1] - m2 - m2;
      c2s.push((m2 - c1 - common) * invDx);
      c3s.push(common * invDx * invDx);
    }
    this.xs = xs;
    this.ys = ys;
    this.c1s = c1s;
    this.c2s = c2s;
    this.c3s = c3s;
  }
}
const ELEMENT_NODE = 1;
function getNodeClientOffset(node) {
  const el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;
  if (!el) {
    return null;
  }
  const { top, left } = el.getBoundingClientRect();
  return {
    x: left,
    y: top
  };
}
function getEventClientOffset(e) {
  return {
    x: e.clientX,
    y: e.clientY
  };
}
function isImageNode(node) {
  var ref;
  return node.nodeName === "IMG" && (isFirefox() || !((ref = document.documentElement) === null || ref === void 0 ? void 0 : ref.contains(node)));
}
function getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {
  let dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;
  let dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;
  if (isSafari() && isImage) {
    dragPreviewHeight /= window.devicePixelRatio;
    dragPreviewWidth /= window.devicePixelRatio;
  }
  return {
    dragPreviewWidth,
    dragPreviewHeight
  };
}
function getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {
  const isImage = isImageNode(dragPreview);
  const dragPreviewNode = isImage ? sourceNode : dragPreview;
  const dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);
  const offsetFromDragPreview = {
    x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,
    y: clientOffset.y - dragPreviewNodeOffsetFromClient.y
  };
  const { offsetWidth: sourceWidth, offsetHeight: sourceHeight } = sourceNode;
  const { anchorX, anchorY } = anchorPoint;
  const { dragPreviewWidth, dragPreviewHeight } = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight);
  const calculateYOffset = () => {
    const interpolantY = new MonotonicInterpolant([
      0,
      0.5,
      1
    ], [
      offsetFromDragPreview.y,
      offsetFromDragPreview.y / sourceHeight * dragPreviewHeight,
      offsetFromDragPreview.y + dragPreviewHeight - sourceHeight
    ]);
    let y = interpolantY.interpolate(anchorY);
    if (isSafari() && isImage) {
      y += (window.devicePixelRatio - 1) * dragPreviewHeight;
    }
    return y;
  };
  const calculateXOffset = () => {
    const interpolantX = new MonotonicInterpolant([
      0,
      0.5,
      1
    ], [
      offsetFromDragPreview.x,
      offsetFromDragPreview.x / sourceWidth * dragPreviewWidth,
      offsetFromDragPreview.x + dragPreviewWidth - sourceWidth
    ]);
    return interpolantX.interpolate(anchorX);
  };
  const { offsetX, offsetY } = offsetPoint;
  const isManualOffsetX = offsetX === 0 || offsetX;
  const isManualOffsetY = offsetY === 0 || offsetY;
  return {
    x: isManualOffsetX ? offsetX : calculateXOffset(),
    y: isManualOffsetY ? offsetY : calculateYOffset()
  };
}
class OptionsReader {
  get window() {
    if (this.globalContext) {
      return this.globalContext;
    } else if (typeof window !== "undefined") {
      return window;
    }
    return void 0;
  }
  get document() {
    var ref;
    if ((ref = this.globalContext) === null || ref === void 0 ? void 0 : ref.document) {
      return this.globalContext.document;
    } else if (this.window) {
      return this.window.document;
    } else {
      return void 0;
    }
  }
  get rootElement() {
    var ref;
    return ((ref = this.optionsArgs) === null || ref === void 0 ? void 0 : ref.rootElement) || this.window;
  }
  constructor(globalContext, options) {
    this.ownerDocument = null;
    this.globalContext = globalContext;
    this.optionsArgs = options;
  }
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys3 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys3.forEach(function(key) {
      _defineProperty(target, key, source[key]);
    });
  }
  return target;
}
class HTML5BackendImpl {
  profile() {
    var ref, ref1;
    return {
      sourcePreviewNodes: this.sourcePreviewNodes.size,
      sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,
      sourceNodeOptions: this.sourceNodeOptions.size,
      sourceNodes: this.sourceNodes.size,
      dragStartSourceIds: ((ref = this.dragStartSourceIds) === null || ref === void 0 ? void 0 : ref.length) || 0,
      dropTargetIds: this.dropTargetIds.length,
      dragEnterTargetIds: this.dragEnterTargetIds.length,
      dragOverTargetIds: ((ref1 = this.dragOverTargetIds) === null || ref1 === void 0 ? void 0 : ref1.length) || 0
    };
  }
  get window() {
    return this.options.window;
  }
  get document() {
    return this.options.document;
  }
  get rootElement() {
    return this.options.rootElement;
  }
  setup() {
    const root2 = this.rootElement;
    if (root2 === void 0) {
      return;
    }
    if (root2.__isReactDndBackendSetUp) {
      throw new Error("Cannot have two HTML5 backends at the same time.");
    }
    root2.__isReactDndBackendSetUp = true;
    this.addEventListeners(root2);
  }
  teardown() {
    const root2 = this.rootElement;
    if (root2 === void 0) {
      return;
    }
    root2.__isReactDndBackendSetUp = false;
    this.removeEventListeners(this.rootElement);
    this.clearCurrentDragSourceNode();
    if (this.asyncEndDragFrameId) {
      var ref;
      (ref = this.window) === null || ref === void 0 ? void 0 : ref.cancelAnimationFrame(this.asyncEndDragFrameId);
    }
  }
  connectDragPreview(sourceId, node, options) {
    this.sourcePreviewNodeOptions.set(sourceId, options);
    this.sourcePreviewNodes.set(sourceId, node);
    return () => {
      this.sourcePreviewNodes.delete(sourceId);
      this.sourcePreviewNodeOptions.delete(sourceId);
    };
  }
  connectDragSource(sourceId, node, options) {
    this.sourceNodes.set(sourceId, node);
    this.sourceNodeOptions.set(sourceId, options);
    const handleDragStart = (e) => this.handleDragStart(e, sourceId);
    const handleSelectStart = (e) => this.handleSelectStart(e);
    node.setAttribute("draggable", "true");
    node.addEventListener("dragstart", handleDragStart);
    node.addEventListener("selectstart", handleSelectStart);
    return () => {
      this.sourceNodes.delete(sourceId);
      this.sourceNodeOptions.delete(sourceId);
      node.removeEventListener("dragstart", handleDragStart);
      node.removeEventListener("selectstart", handleSelectStart);
      node.setAttribute("draggable", "false");
    };
  }
  connectDropTarget(targetId, node) {
    const handleDragEnter = (e) => this.handleDragEnter(e, targetId);
    const handleDragOver = (e) => this.handleDragOver(e, targetId);
    const handleDrop = (e) => this.handleDrop(e, targetId);
    node.addEventListener("dragenter", handleDragEnter);
    node.addEventListener("dragover", handleDragOver);
    node.addEventListener("drop", handleDrop);
    return () => {
      node.removeEventListener("dragenter", handleDragEnter);
      node.removeEventListener("dragover", handleDragOver);
      node.removeEventListener("drop", handleDrop);
    };
  }
  addEventListeners(target) {
    if (!target.addEventListener) {
      return;
    }
    target.addEventListener("dragstart", this.handleTopDragStart);
    target.addEventListener("dragstart", this.handleTopDragStartCapture, true);
    target.addEventListener("dragend", this.handleTopDragEndCapture, true);
    target.addEventListener("dragenter", this.handleTopDragEnter);
    target.addEventListener("dragenter", this.handleTopDragEnterCapture, true);
    target.addEventListener("dragleave", this.handleTopDragLeaveCapture, true);
    target.addEventListener("dragover", this.handleTopDragOver);
    target.addEventListener("dragover", this.handleTopDragOverCapture, true);
    target.addEventListener("drop", this.handleTopDrop);
    target.addEventListener("drop", this.handleTopDropCapture, true);
  }
  removeEventListeners(target) {
    if (!target.removeEventListener) {
      return;
    }
    target.removeEventListener("dragstart", this.handleTopDragStart);
    target.removeEventListener("dragstart", this.handleTopDragStartCapture, true);
    target.removeEventListener("dragend", this.handleTopDragEndCapture, true);
    target.removeEventListener("dragenter", this.handleTopDragEnter);
    target.removeEventListener("dragenter", this.handleTopDragEnterCapture, true);
    target.removeEventListener("dragleave", this.handleTopDragLeaveCapture, true);
    target.removeEventListener("dragover", this.handleTopDragOver);
    target.removeEventListener("dragover", this.handleTopDragOverCapture, true);
    target.removeEventListener("drop", this.handleTopDrop);
    target.removeEventListener("drop", this.handleTopDropCapture, true);
  }
  getCurrentSourceNodeOptions() {
    const sourceId = this.monitor.getSourceId();
    const sourceNodeOptions = this.sourceNodeOptions.get(sourceId);
    return _objectSpread({
      dropEffect: this.altKeyPressed ? "copy" : "move"
    }, sourceNodeOptions || {});
  }
  getCurrentDropEffect() {
    if (this.isDraggingNativeItem()) {
      return "copy";
    }
    return this.getCurrentSourceNodeOptions().dropEffect;
  }
  getCurrentSourcePreviewNodeOptions() {
    const sourceId = this.monitor.getSourceId();
    const sourcePreviewNodeOptions = this.sourcePreviewNodeOptions.get(sourceId);
    return _objectSpread({
      anchorX: 0.5,
      anchorY: 0.5,
      captureDraggingState: false
    }, sourcePreviewNodeOptions || {});
  }
  isDraggingNativeItem() {
    const itemType = this.monitor.getItemType();
    return Object.keys(NativeTypes).some(
      (key) => NativeTypes[key] === itemType
    );
  }
  beginDragNativeItem(type, dataTransfer) {
    this.clearCurrentDragSourceNode();
    this.currentNativeSource = createNativeDragSource(type, dataTransfer);
    this.currentNativeHandle = this.registry.addSource(type, this.currentNativeSource);
    this.actions.beginDrag([
      this.currentNativeHandle
    ]);
  }
  setCurrentDragSourceNode(node) {
    this.clearCurrentDragSourceNode();
    this.currentDragSourceNode = node;
    const MOUSE_MOVE_TIMEOUT = 1e3;
    this.mouseMoveTimeoutTimer = setTimeout(() => {
      var ref;
      return (ref = this.rootElement) === null || ref === void 0 ? void 0 : ref.addEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, true);
    }, MOUSE_MOVE_TIMEOUT);
  }
  clearCurrentDragSourceNode() {
    if (this.currentDragSourceNode) {
      this.currentDragSourceNode = null;
      if (this.rootElement) {
        var ref;
        (ref = this.window) === null || ref === void 0 ? void 0 : ref.clearTimeout(this.mouseMoveTimeoutTimer || void 0);
        this.rootElement.removeEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, true);
      }
      this.mouseMoveTimeoutTimer = null;
      return true;
    }
    return false;
  }
  handleDragStart(e, sourceId) {
    if (e.defaultPrevented) {
      return;
    }
    if (!this.dragStartSourceIds) {
      this.dragStartSourceIds = [];
    }
    this.dragStartSourceIds.unshift(sourceId);
  }
  handleDragEnter(_e, targetId) {
    this.dragEnterTargetIds.unshift(targetId);
  }
  handleDragOver(_e, targetId) {
    if (this.dragOverTargetIds === null) {
      this.dragOverTargetIds = [];
    }
    this.dragOverTargetIds.unshift(targetId);
  }
  handleDrop(_e, targetId) {
    this.dropTargetIds.unshift(targetId);
  }
  constructor(manager, globalContext, options) {
    this.sourcePreviewNodes = /* @__PURE__ */ new Map();
    this.sourcePreviewNodeOptions = /* @__PURE__ */ new Map();
    this.sourceNodes = /* @__PURE__ */ new Map();
    this.sourceNodeOptions = /* @__PURE__ */ new Map();
    this.dragStartSourceIds = null;
    this.dropTargetIds = [];
    this.dragEnterTargetIds = [];
    this.currentNativeSource = null;
    this.currentNativeHandle = null;
    this.currentDragSourceNode = null;
    this.altKeyPressed = false;
    this.mouseMoveTimeoutTimer = null;
    this.asyncEndDragFrameId = null;
    this.dragOverTargetIds = null;
    this.lastClientOffset = null;
    this.hoverRafId = null;
    this.getSourceClientOffset = (sourceId) => {
      const source = this.sourceNodes.get(sourceId);
      return source && getNodeClientOffset(source) || null;
    };
    this.endDragNativeItem = () => {
      if (!this.isDraggingNativeItem()) {
        return;
      }
      this.actions.endDrag();
      if (this.currentNativeHandle) {
        this.registry.removeSource(this.currentNativeHandle);
      }
      this.currentNativeHandle = null;
      this.currentNativeSource = null;
    };
    this.isNodeInDocument = (node) => {
      return Boolean(node && this.document && this.document.body && this.document.body.contains(node));
    };
    this.endDragIfSourceWasRemovedFromDOM = () => {
      const node = this.currentDragSourceNode;
      if (node == null || this.isNodeInDocument(node)) {
        return;
      }
      if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {
        this.actions.endDrag();
      }
      this.cancelHover();
    };
    this.scheduleHover = (dragOverTargetIds) => {
      if (this.hoverRafId === null && typeof requestAnimationFrame !== "undefined") {
        this.hoverRafId = requestAnimationFrame(() => {
          if (this.monitor.isDragging()) {
            this.actions.hover(dragOverTargetIds || [], {
              clientOffset: this.lastClientOffset
            });
          }
          this.hoverRafId = null;
        });
      }
    };
    this.cancelHover = () => {
      if (this.hoverRafId !== null && typeof cancelAnimationFrame !== "undefined") {
        cancelAnimationFrame(this.hoverRafId);
        this.hoverRafId = null;
      }
    };
    this.handleTopDragStartCapture = () => {
      this.clearCurrentDragSourceNode();
      this.dragStartSourceIds = [];
    };
    this.handleTopDragStart = (e) => {
      if (e.defaultPrevented) {
        return;
      }
      const { dragStartSourceIds } = this;
      this.dragStartSourceIds = null;
      const clientOffset = getEventClientOffset(e);
      if (this.monitor.isDragging()) {
        this.actions.endDrag();
        this.cancelHover();
      }
      this.actions.beginDrag(dragStartSourceIds || [], {
        publishSource: false,
        getSourceClientOffset: this.getSourceClientOffset,
        clientOffset
      });
      const { dataTransfer } = e;
      const nativeType = matchNativeItemType(dataTransfer);
      if (this.monitor.isDragging()) {
        if (dataTransfer && typeof dataTransfer.setDragImage === "function") {
          const sourceId = this.monitor.getSourceId();
          const sourceNode = this.sourceNodes.get(sourceId);
          const dragPreview = this.sourcePreviewNodes.get(sourceId) || sourceNode;
          if (dragPreview) {
            const { anchorX, anchorY, offsetX, offsetY } = this.getCurrentSourcePreviewNodeOptions();
            const anchorPoint = {
              anchorX,
              anchorY
            };
            const offsetPoint = {
              offsetX,
              offsetY
            };
            const dragPreviewOffset = getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint);
            dataTransfer.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);
          }
        }
        try {
          dataTransfer === null || dataTransfer === void 0 ? void 0 : dataTransfer.setData("application/json", {});
        } catch (err) {
        }
        this.setCurrentDragSourceNode(e.target);
        const { captureDraggingState } = this.getCurrentSourcePreviewNodeOptions();
        if (!captureDraggingState) {
          setTimeout(
            () => this.actions.publishDragSource(),
            0
          );
        } else {
          this.actions.publishDragSource();
        }
      } else if (nativeType) {
        this.beginDragNativeItem(nativeType);
      } else if (dataTransfer && !dataTransfer.types && (e.target && !e.target.hasAttribute || !e.target.hasAttribute("draggable"))) {
        return;
      } else {
        e.preventDefault();
      }
    };
    this.handleTopDragEndCapture = () => {
      if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {
        this.actions.endDrag();
      }
      this.cancelHover();
    };
    this.handleTopDragEnterCapture = (e) => {
      this.dragEnterTargetIds = [];
      if (this.isDraggingNativeItem()) {
        var ref;
        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);
      }
      const isFirstEnter = this.enterLeaveCounter.enter(e.target);
      if (!isFirstEnter || this.monitor.isDragging()) {
        return;
      }
      const { dataTransfer } = e;
      const nativeType = matchNativeItemType(dataTransfer);
      if (nativeType) {
        this.beginDragNativeItem(nativeType, dataTransfer);
      }
    };
    this.handleTopDragEnter = (e) => {
      const { dragEnterTargetIds } = this;
      this.dragEnterTargetIds = [];
      if (!this.monitor.isDragging()) {
        return;
      }
      this.altKeyPressed = e.altKey;
      if (dragEnterTargetIds.length > 0) {
        this.actions.hover(dragEnterTargetIds, {
          clientOffset: getEventClientOffset(e)
        });
      }
      const canDrop = dragEnterTargetIds.some(
        (targetId) => this.monitor.canDropOnTarget(targetId)
      );
      if (canDrop) {
        e.preventDefault();
        if (e.dataTransfer) {
          e.dataTransfer.dropEffect = this.getCurrentDropEffect();
        }
      }
    };
    this.handleTopDragOverCapture = (e) => {
      this.dragOverTargetIds = [];
      if (this.isDraggingNativeItem()) {
        var ref;
        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);
      }
    };
    this.handleTopDragOver = (e) => {
      const { dragOverTargetIds } = this;
      this.dragOverTargetIds = [];
      if (!this.monitor.isDragging()) {
        e.preventDefault();
        if (e.dataTransfer) {
          e.dataTransfer.dropEffect = "none";
        }
        return;
      }
      this.altKeyPressed = e.altKey;
      this.lastClientOffset = getEventClientOffset(e);
      this.scheduleHover(dragOverTargetIds);
      const canDrop = (dragOverTargetIds || []).some(
        (targetId) => this.monitor.canDropOnTarget(targetId)
      );
      if (canDrop) {
        e.preventDefault();
        if (e.dataTransfer) {
          e.dataTransfer.dropEffect = this.getCurrentDropEffect();
        }
      } else if (this.isDraggingNativeItem()) {
        e.preventDefault();
      } else {
        e.preventDefault();
        if (e.dataTransfer) {
          e.dataTransfer.dropEffect = "none";
        }
      }
    };
    this.handleTopDragLeaveCapture = (e) => {
      if (this.isDraggingNativeItem()) {
        e.preventDefault();
      }
      const isLastLeave = this.enterLeaveCounter.leave(e.target);
      if (!isLastLeave) {
        return;
      }
      if (this.isDraggingNativeItem()) {
        setTimeout(
          () => this.endDragNativeItem(),
          0
        );
      }
      this.cancelHover();
    };
    this.handleTopDropCapture = (e) => {
      this.dropTargetIds = [];
      if (this.isDraggingNativeItem()) {
        var ref;
        e.preventDefault();
        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);
      } else if (matchNativeItemType(e.dataTransfer)) {
        e.preventDefault();
      }
      this.enterLeaveCounter.reset();
    };
    this.handleTopDrop = (e) => {
      const { dropTargetIds } = this;
      this.dropTargetIds = [];
      this.actions.hover(dropTargetIds, {
        clientOffset: getEventClientOffset(e)
      });
      this.actions.drop({
        dropEffect: this.getCurrentDropEffect()
      });
      if (this.isDraggingNativeItem()) {
        this.endDragNativeItem();
      } else if (this.monitor.isDragging()) {
        this.actions.endDrag();
      }
      this.cancelHover();
    };
    this.handleSelectStart = (e) => {
      const target = e.target;
      if (typeof target.dragDrop !== "function") {
        return;
      }
      if (target.tagName === "INPUT" || target.tagName === "SELECT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
        return;
      }
      e.preventDefault();
      target.dragDrop();
    };
    this.options = new OptionsReader(globalContext, options);
    this.actions = manager.getActions();
    this.monitor = manager.getMonitor();
    this.registry = manager.getRegistry();
    this.enterLeaveCounter = new EnterLeaveCounter(this.isNodeInDocument);
  }
}
const HTML5Backend = function createBackend(manager, context, options) {
  return new HTML5BackendImpl(manager, context, options);
};
var tableSettingsPanelOrder = "";
var TableSettingsPanelOrder = function TableSettingsPanelOrder2(props) {
  var externalList = props.list, root2 = props.root, onChange = props.onChange;
  var _React$useState = React__default.useState(externalList), _React$useState2 = _slicedToArray(_React$useState, 2), list = _React$useState2[0], selList = _React$useState2[1];
  var moveListItem = React__default.useCallback(function(dragIndex, hoverIndex) {
    var dragItem = list[dragIndex];
    var hoverItem = list[hoverIndex];
    selList(function(list2) {
      var newList = _toConsumableArray(list2);
      newList[dragIndex] = hoverItem;
      newList[hoverIndex] = dragItem;
      return newList;
    });
  }, [list]);
  var onDrop = function onDrop2() {
    onChange(list);
  };
  return /* @__PURE__ */ React__default.createElement(DndProvider, {
    backend: HTML5Backend
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "order-list"
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "order-root"
  }, root2), /* @__PURE__ */ React__default.createElement("div", {
    className: "order-items"
  }, list.map(function(item, index2) {
    if (item.isLeft)
      return null;
    return /* @__PURE__ */ React__default.createElement(ListItem, _extends$h({}, props, item, {
      index: index2,
      moveListItem,
      onDrop
    }));
  }))));
};
var ListItem = function ListItem2(props) {
  var value = props.value, index2 = props.index, moveListItem = props.moveListItem, onDrop = props.onDrop;
  var _useDrag = useDrag({
    type: "item",
    item: {
      index: index2
    },
    collect: function collect(monitor) {
      return {
        isDragging: monitor.isDragging()
      };
    }
  }), _useDrag2 = _slicedToArray(_useDrag, 2);
  _useDrag2[0].isDragging;
  var dragRef = _useDrag2[1];
  var _useDrop = useDrop({
    accept: "item",
    hover: function hover3(item, monitor) {
      var _ref$current;
      var dragIndex = item.index;
      var hoverIndex = index2;
      var hoverBoundingRect = (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.getBoundingClientRect();
      var hoverMiddleX = (hoverBoundingRect.right - hoverBoundingRect.left) / 2;
      var hoverActualX = monitor.getClientOffset().x - hoverBoundingRect.left;
      if (dragIndex < hoverIndex && hoverActualX < hoverMiddleX || dragIndex > hoverIndex && hoverActualX > hoverMiddleX)
        return;
      moveListItem(dragIndex, hoverIndex);
      item.index = hoverIndex;
    },
    drop: function drop() {
      return onDrop();
    }
  }), _useDrop2 = _slicedToArray(_useDrop, 2);
  _useDrop2[0];
  var dropRef = _useDrop2[1];
  var ref = React__default.useRef(null);
  var dragDropRef = dragRef(dropRef(ref));
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "order-list-item",
    ref: dragDropRef
  }, value);
};
var callTable = function callTable2(tablePortalEl, tableProps) {
  var tableRoot = document.createElement("div");
  tableRoot.className = "call-unitable-wrapper";
  tablePortalEl.appendChild(tableRoot);
  var root2 = createRoot(tableRoot);
  var removeComponent = function removeComponent2() {
    root2.unmount();
    tableRoot.remove();
  };
  root2.render(/* @__PURE__ */ React__default.createElement(Table, _extends$h({}, tableProps, {
    removeComponent
  })));
  return {
    removeComponent
  };
};
var Utils = /* @__PURE__ */ function() {
  function Utils2(props) {
    var _this = this;
    _classCallCheck$a(this, Utils2);
    _defineProperty$7(this, "getHeightStyle", function(height) {
      var _height = isNaN(height) ? height : "".concat(height, "px");
      return {
        height: _height,
        minHeight: _height,
        maxHeight: _height
      };
    });
    _defineProperty$7(this, "getWidthStyle", function(width) {
      var _width = isNaN(width) ? width : "".concat(width, "px");
      return {
        width: _width,
        minWidth: _width,
        maxWidth: _width
      };
    });
    _defineProperty$7(this, "getValueByAddress", function(address) {
      var value = _this.connector;
      var offsets = address.split(".");
      var _iterator = _createForOfIteratorHelper(offsets), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var offset2 = _step.value;
          value = value[offset2];
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return value;
    });
    _defineProperty$7(this, "setValueByAddress", function(address, value) {
      var addr = _this.connector;
      var offsets = address.split(".");
      for (var i in offsets) {
        if (Number(i) === offsets.length - 1) {
          addr[offsets[i]] = value;
        } else {
          addr = addr[offsets[i]];
        }
      }
    });
    _defineProperty$7(this, "setHoveredCell", function(column, row) {
      var _this$connector = _this.connector, hovered = _this$connector.hovered, _this$connector$refre = _this$connector.refresh, refreshRow = _this$connector$refre.row, refreshCol = _this$connector$refre.column;
      var oldHoveredColumn = hovered.column, oldHoveredRow = hovered.row;
      var _refreshColumn = function _refreshColumn2(index2) {
        if (index2 !== null && Array.isArray(refreshCol))
          _this.refreshColumn(index2);
      };
      var _refreshRow = function _refreshRow2(index2) {
        if (index2 !== null && refreshRow && refreshRow[index2])
          refreshRow[index2]();
      };
      _this.connector.hovered = {
        column,
        row
      };
      if (column !== oldHoveredColumn) {
        _refreshColumn(oldHoveredColumn);
        _refreshColumn(column);
      }
      if (row !== oldHoveredRow) {
        _refreshRow(oldHoveredRow);
        _refreshRow(row);
      }
    });
    var tablePortalElCurrent = props.tablePortalElCurrent, _props$tableName = props.tableName, tableName = _props$tableName === void 0 ? "" : _props$tableName, data = props.data, _props$commonForHeade = props.commonForHeader, commonForHeader = _props$commonForHeade === void 0 ? {} : _props$commonForHeade, _props$commonForBody = props.commonForBody, commonForBody = _props$commonForBody === void 0 ? {} : _props$commonForBody, _props$editors = props.editors, editors = _props$editors === void 0 ? {} : _props$editors, _props$options = props.options, options = _props$options === void 0 ? {} : _props$options, _props$onChangeCompon = props.onChangeComponentState, onChangeComponentState = _props$onChangeCompon === void 0 ? {} : _props$onChangeCompon, _props$getComponentCo = props.getComponentControlling, getComponentControlling = _props$getComponentCo === void 0 ? function() {
    } : _props$getComponentCo, refreshTable = props.refreshTable;
    var _options$numberFixedL = options.numberFixedLeftColumns, numberFixedLeftColumns = _options$numberFixedL === void 0 ? 0 : _options$numberFixedL, _options$tableHasRows = options.tableHasRowsTree, tableHasRowsTree = _options$tableHasRows === void 0 ? false : _options$tableHasRows;
    var header = data.header, rowsTree = data.rows, _data$params = data.params, params = _data$params === void 0 ? {} : _data$params;
    this.rowsByOrdinalIndex = {};
    var _this$rowsTreeToRows = this.rowsTreeToRows(rowsTree), rows = _this$rowsTreeToRows.rows, rowsMaxLevel = _this$rowsTreeToRows.rowsMaxLevel, rowsRootNumber = _this$rowsTreeToRows.rowsRootNumber;
    this.tableName = tableName;
    this.header = header;
    this.numberFixedLeftColumns = numberFixedLeftColumns;
    this.setHeaderInfo(header);
    this.numberFixedLeftColumnsEnds = this.getNumberFixedLeftColumns(header, numberFixedLeftColumns);
    if (!params.totalLength && rowsTree.length < params.pageLength)
      params.totalLength = rowsTree.length;
    var initialSizes = options.initialSizes || {};
    this.connector = {
      options,
      params,
      commonForHeader,
      commonForBody,
      editors,
      onChangeComponentState,
      tableHas: {
        paginator: rows.length !== params.totalLength,
        scrollbarHorizontal: false,
        scrollbarVertical: false,
        rowsTree: tableHasRowsTree
      },
      header,
      rows: this.correctionRowsLength(rows, this.headerLength),
      rowsTree,
      rowsRootNumber,
      rowsMaxLevel,
      headerMaxLevel: this.headerMaxLevel,
      headerLength: this.headerLength,
      showPageNum: 0,
      numberFixedLeftColumns: this.numberFixedLeftColumns,
      numberFixedLeftColumnsEnds: this.numberFixedLeftColumnsEnds,
      searchContext: UTILS$2.monoArray(this.headerLength, null),
      format: UTILS$2.monoArray(this.headerLength, null),
      sortCell: null,
      editableCell: null,
      sizes: {
        columnsWidth: this.getColumnsWidth({
          tablePortalElCurrent,
          initialSizes
        }),
        headerHeight: initialSizes.headerHeight ? initialSizes.headerHeight : this.headerMaxLevel * 45,
        rowsHeight: initialSizes.rowsHeight ? initialSizes.rowsHeight : 25,
        paginatorHeight: 40,
        scrollbar: 18
      },
      refs: {
        tablePortalElCurrent,
        unitableBody: null,
        body: null,
        rightParts: [],
        headerRight: null,
        unitable: null,
        scrollbarVertical: null,
        settings: null
      },
      hovered: {
        column: null,
        row: null
      },
      data: {
        headerRoot: [],
        headerRootByEndIndex: {},
        rowsByOrdinalIndex: this.rowsByOrdinalIndex
      },
      refresh: {
        table: refreshTable,
        headerAndBody: function headerAndBody() {
        },
        header: function header2() {
        },
        body: function body() {
        },
        scrollbarHorizontal: function scrollbarHorizontal() {
        },
        scrollbarVertical: function scrollbarVertical() {
        },
        paginator: function paginator() {
        },
        column: [],
        row: []
      },
      showColumns: UTILS$2.monoArray(this.headerLength, true),
      showRows: this.showRows,
      orderTree: this.buildTreeOrder(),
      orderEnds: []
    };
    this.restoreTableSettingsFromLocaleStorage();
    this.orderTreeToOrderEnds();
    setTimeout(function() {
      _this.setControlling(getComponentControlling);
    }, 0);
    console.log("--- Utils --->", this);
  }
  return _createClass$9(Utils2, [{
    key: "getColumnsWidth",
    value: function getColumnsWidth(_ref) {
      var _tablePortalElCurrent;
      var _ref$tablePortalElCur = _ref.tablePortalElCurrent, tablePortalElCurrent = _ref$tablePortalElCur === void 0 ? null : _ref$tablePortalElCur, _ref$initialSizes = _ref.initialSizes, initialSizes = _ref$initialSizes === void 0 ? {} : _ref$initialSizes;
      var defaultWidth = 100;
      console.log("tablePortalElCurrent.current", tablePortalElCurrent.current);
      var portalWidth = (_tablePortalElCurrent = tablePortalElCurrent.current) !== null && _tablePortalElCurrent !== void 0 && _tablePortalElCurrent.getBoundingClientRect ? tablePortalElCurrent.current.getBoundingClientRect().width : null;
      if (portalWidth) {
        var portalStyle = tablePortalElCurrent.current.currentStyle || window.getComputedStyle(tablePortalElCurrent.current);
        var portalPadding = Number(portalStyle.paddingLeft.replace("px", "")) + Number(portalStyle.paddingRight.replace("px", ""));
        portalWidth -= portalPadding;
      }
      if (!portalWidth && !(initialSizes !== null && initialSizes !== void 0 && initialSizes.columnsWidth)) {
        return UTILS$2.monoArray(this.headerLength, defaultWidth);
      }
      if (!initialSizes.columnsWidth) {
        var width = Math.floor(portalWidth / this.headerLength);
        return UTILS$2.monoArray(this.headerLength, width);
      }
      var columnsWidth = initialSizes.columnsWidth;
      var getPX = function getPX2(text) {
        var sizePercent = text.split("%");
        if (sizePercent.length === 2) {
          return portalWidth ? Math.floor(portalWidth / 100 * Number(sizePercent[0])) : defaultWidth;
        }
        var sizePx = text.split("px");
        return Number(sizePx[0]);
      };
      if (Array.isArray(columnsWidth)) {
        var out = [];
        var undefCount = 0;
        var totalWidth = 0;
        for (var i = 0; i < this.headerLength; i++) {
          if (columnsWidth[i]) {
            var _width2 = getPX(String(columnsWidth[i]));
            out[i] = _width2;
            totalWidth += _width2;
          } else {
            out[i] = "*";
            undefCount++;
          }
        }
        if (undefCount) {
          var remainsTotal = portalWidth ? portalWidth - totalWidth : defaultWidth * undefCount;
          var remainsWidth = remainsTotal / undefCount;
          for (var _i in out) {
            if (out[_i] === "*")
              out[_i] = remainsWidth;
          }
        }
        return out;
      } else {
        return UTILS$2.monoArray(this.headerLength, getPX(String(columnsWidth)));
      }
    }
  }, {
    key: "setControlling",
    value: function setControlling(getComponentControlling) {
      var controlling = {
        setTableTotalLength: this.setTableTotalLength.bind(this),
        refreshBodyWithNewRows: this.refreshBodyWithNewRows.bind(this),
        refreshPaginator: this.connector.refresh.paginator.bind(this),
        refreshTable: this.refreshTable.bind(this)
      };
      getComponentControlling(controlling);
    }
  }, {
    key: "refreshTable",
    value: function refreshTable() {
      Store$1.setState("unitable.".concat(this.tableName), {});
      this.connector.refresh.table();
    }
  }, {
    key: "refreshBodyWithNewRows",
    value: function refreshBodyWithNewRows(props) {
      var params = this.connector.params;
      var newRows = props.newRows, newPageLength = props.newPageLength, newPageNum = props.newPageNum, openAllLevels = props.openAllLevels;
      var _this$rowsTreeToRows2 = this.rowsTreeToRows(newRows, openAllLevels), rows = _this$rowsTreeToRows2.rows, rowsMaxLevel = _this$rowsTreeToRows2.rowsMaxLevel, rowsRootNumber = _this$rowsTreeToRows2.rowsRootNumber;
      this.connector.rowsTree = newRows;
      this.connector.rows = this.correctionRowsLength(rows, this.headerLength);
      this.connector.rowsRootNumber = rowsRootNumber;
      this.connector.rowsMaxLevel = rowsMaxLevel;
      if (newPageLength)
        params.pageLength = newPageLength;
      if (!isNaN(newPageNum))
        params.pageNum = newPageNum;
      if (!params.totalLength && newRows.length < params.pageLength) {
        this.setTableTotalLength(params.pageNum * params.pageLength + newRows.length);
      }
      if (!openAllLevels)
        this.setShowToAllRows(false);
      this.connector.refresh.body();
      this.connector.refresh.paginator();
      this.storeRememberPage();
    }
  }, {
    key: "getSliding",
    value: function getSliding() {
      var _this$connector2 = this.connector, _this$connector2$size = _this$connector2.sizes, rowsHeight = _this$connector2$size.rowsHeight, headerHeight = _this$connector2$size.headerHeight, paginatorHeight = _this$connector2$size.paginatorHeight, refs = _this$connector2.refs, showRows = _this$connector2.showRows;
      var inner = refs === null || refs === void 0 ? void 0 : refs.unitableBodyInner;
      var getInnerHeight = function getInnerHeight2() {
        var documentHeight = document.getElementsByTagName("body")[0].getBoundingClientRect().height;
        return documentHeight - headerHeight - paginatorHeight;
      };
      var scrollTop = inner ? inner.scrollTop : 0;
      var innerHeight = inner ? inner.getBoundingClientRect().height : getInnerHeight();
      var from2 = Math.round(scrollTop / rowsHeight);
      var to2 = Math.round((scrollTop + innerHeight) / rowsHeight);
      var sliding = [];
      var visualIndex = 0;
      var _iterator2 = _createForOfIteratorHelper(showRows), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var row = _step2.value;
          if (row.show) {
            sliding.push(visualIndex >= from2 && visualIndex <= to2);
            visualIndex++;
          } else {
            sliding.push(true);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return sliding;
    }
  }, {
    key: "setTableTotalLength",
    value: function setTableTotalLength(length) {
      var _this$connector3 = this.connector, params = _this$connector3.params, refresh = _this$connector3.refresh;
      params.totalLength = length;
      refresh.paginator();
    }
  }, {
    key: "setShowToAllRows",
    value: function setShowToAllRows(value) {
      var _this$connector4 = this.connector, refreshBody = _this$connector4.refresh.body, showRows = _this$connector4.showRows;
      for (var index2 in showRows) {
        var item = showRows[index2];
        item.showChildren = value;
        if (item.level)
          item.show = value;
      }
      refreshBody();
    }
  }, {
    key: "rowsTreeToRows",
    value: function rowsTreeToRows(rowsTree, openAllLevels) {
      var _this2 = this;
      var rows = [];
      var showRows = [];
      var mainRootIndex = 0;
      var rowsMaxLevel = 0;
      var myIndex = 0;
      var ordinalIndex = 0;
      var _nextBranch = function nextBranch(branch, level, parentChildren, parentIndex) {
        var _iterator3 = _createForOfIteratorHelper(branch), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var item = _step3.value;
            var row = item.row, children = item.children, _ = item._;
            var isRoot = !!(children !== null && children !== void 0 && children.length);
            rows.push(row);
            _this2.rowsByOrdinalIndex[ordinalIndex] = item;
            var ch = [];
            var el = {
              show: openAllLevels ? true : !level,
              mainRootIndex,
              level,
              isRoot,
              showChildren: !!openAllLevels,
              children: ch,
              parentChildren,
              parentIndex,
              ordinalIndex
            };
            if (_ !== null && _ !== void 0 && _.isNotFind)
              el.isNotFind = true;
            showRows.push(el);
            ordinalIndex++;
            myIndex++;
            rowsMaxLevel = Math.max(rowsMaxLevel, level);
            if (parentChildren)
              parentChildren.push(showRows.length - 1);
            if (isRoot) {
              _nextBranch(children, level + 1, ch, myIndex);
            }
            if (!level)
              mainRootIndex++;
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      };
      _nextBranch(this.rootsToUp(rowsTree), 0);
      if (this.connector) {
        this.connector.showRows = showRows;
      }
      this.showRows = showRows;
      return {
        rows,
        rowsMaxLevel,
        rowsRootNumber: rowsTree.length
      };
    }
  }, {
    key: "rootsToUp",
    value: function rootsToUp(rowsTree) {
      var _sort = function sort2(rows) {
        rows.sort(function(a, b) {
          var _a$children, _b$children;
          var aChildren = !!((_a$children = a.children) !== null && _a$children !== void 0 && _a$children.length);
          var bChildren = !!((_b$children = b.children) !== null && _b$children !== void 0 && _b$children.length);
          if (aChildren && !bChildren)
            return -1;
          if (!aChildren && bChildren)
            return 1;
          return 0;
        });
        var _iterator4 = _createForOfIteratorHelper(rows), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var _row$children;
            var row = _step4.value;
            if ((_row$children = row.children) !== null && _row$children !== void 0 && _row$children.length) {
              _sort(row.children);
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      };
      _sort(rowsTree);
      return rowsTree;
    }
  }, {
    key: "toggleShowRowTree",
    value: function toggleShowRowTree(rowIndex) {
      var _scrollbarWrapperRef$;
      var _this$connector5 = this.connector, showRows = _this$connector5.showRows, refreshRow = _this$connector5.refresh.row, _this$connector5$refs = _this$connector5.refs, rightPartsRefs = _this$connector5$refs.rightParts, scrollbarWrapperRef = _this$connector5$refs.scrollbarWrapperRef, refresh = _this$connector5.refresh;
      var scrollLeft = ((_scrollbarWrapperRef$ = scrollbarWrapperRef.current) === null || _scrollbarWrapperRef$ === void 0 ? void 0 : _scrollbarWrapperRef$.scrollLeft) || 0;
      var show = !showRows[rowIndex].showChildren;
      var _setChildrenShow = function setChildrenShow(index2) {
        var rowData = showRows[index2];
        rowData.showChildren = show;
        var _iterator5 = _createForOfIteratorHelper(rowData.children), _step5;
        try {
          var _loop = function _loop4() {
            var _childrenData$childre;
            var childIndex = _step5.value;
            var childrenData = showRows[childIndex];
            childrenData.show = show;
            refreshRow[childIndex]();
            setTimeout(function() {
              rightPartsRefs[childIndex + 1].scrollLeft = scrollLeft;
            }, 10);
            if (!show && (_childrenData$childre = childrenData.children) !== null && _childrenData$childre !== void 0 && _childrenData$childre.length) {
              _setChildrenShow(childIndex);
            }
          };
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
            _loop();
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      };
      _setChildrenShow(rowIndex);
      setTimeout(function() {
        refresh.scrollbarVertical();
      }, 0);
    }
  }, {
    key: "toggleCheckedCell",
    value: function toggleCheckedCell(cell) {
      if (cell._.isEndOfLeftPart)
        return;
      var checked = !cell._.checked;
      var _setChecked = function setChecked(cell2) {
        cell2._.checked = checked;
        if (!cell2._.isEnd) {
          var _iterator6 = _createForOfIteratorHelper(cell2.children), _step6;
          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
              var child = _step6.value;
              _setChecked(child);
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
        }
      };
      _setChecked(cell);
      this.checkParentCheckedInHeader();
    }
  }, {
    key: "checkParentCheckedInHeader",
    value: function checkParentCheckedInHeader() {
      var _testChecked = function testChecked(cell) {
        if (cell._.isEnd) {
          return cell._.checked;
        }
        var checked = false;
        var _iterator7 = _createForOfIteratorHelper(cell.children), _step7;
        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
            var child = _step7.value;
            checked = _testChecked(child) || checked;
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
        cell._.checked = checked;
        return checked;
      };
      var _iterator8 = _createForOfIteratorHelper(this.connector.header), _step8;
      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
          var root2 = _step8.value;
          if (!root2._.isEndOfLeftPart)
            _testChecked(root2);
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
    }
  }, {
    key: "distributeShowColumnsToHeader",
    value: function distributeShowColumnsToHeader() {
      var _this$connector6 = this.connector, showColumns = _this$connector6.showColumns, header = _this$connector6.header;
      var _testChecked2 = function testChecked(cell) {
        if (cell._.isEnd) {
          cell._.checked = showColumns[cell._.endIndex];
          return;
        }
        var _iterator9 = _createForOfIteratorHelper(cell.children), _step9;
        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done; ) {
            var child = _step9.value;
            _testChecked2(child);
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }
      };
      var _iterator10 = _createForOfIteratorHelper(header), _step10;
      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {
          var root2 = _step10.value;
          if (!root2._.isEndOfLeftPart)
            _testChecked2(root2);
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }
      this.checkParentCheckedInHeader();
    }
  }, {
    key: "distributeHeaderToShowColumns",
    value: function distributeHeaderToShowColumns() {
      var _this3 = this;
      var _this$connector7 = this.connector, showColumns = _this$connector7.showColumns, header = _this$connector7.header, headerRoot = _this$connector7.data.headerRoot;
      var _testChecked3 = function testChecked(cell) {
        var _cell$_ = cell._, checkedInHeader = _cell$_.checked, isEnd = _cell$_.isEnd, endIndex = _cell$_.endIndex;
        if (isEnd) {
          var checkedInShowColumns = showColumns[endIndex];
          if (checkedInHeader === checkedInShowColumns)
            return;
          showColumns[endIndex] = checkedInHeader;
          _this3.refreshColumn(endIndex);
          return;
        }
        var _iterator11 = _createForOfIteratorHelper(cell.children), _step11;
        try {
          for (_iterator11.s(); !(_step11 = _iterator11.n()).done; ) {
            var child = _step11.value;
            _testChecked3(child);
          }
        } catch (err) {
          _iterator11.e(err);
        } finally {
          _iterator11.f();
        }
      };
      var _iterator12 = _createForOfIteratorHelper(header), _step12;
      try {
        for (_iterator12.s(); !(_step12 = _iterator12.n()).done; ) {
          var root2 = _step12.value;
          if (!root2._.isEndOfLeftPart)
            _testChecked3(root2);
        }
      } catch (err) {
        _iterator12.e(err);
      } finally {
        _iterator12.f();
      }
      setTimeout(function() {
        var _iterator13 = _createForOfIteratorHelper(headerRoot), _step13;
        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done; ) {
            var root3 = _step13.value;
            root3.refresh();
          }
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }
      }, 0);
    }
  }, {
    key: "buildTreeOrder",
    value: function buildTreeOrder() {
      var originalEndsIndex = 0;
      var _getChildren = function getChildren(children) {
        var out = [];
        for (var i in children) {
          var _cell$children;
          var cell = children[i];
          var item = {
            i: Number(i)
          };
          if ((_cell$children = cell.children) !== null && _cell$children !== void 0 && _cell$children.length) {
            item.ch = _getChildren(cell.children);
          } else {
            item.orig = originalEndsIndex;
            originalEndsIndex++;
          }
          out.push(item);
        }
        return out;
      };
      return _getChildren(this.header);
    }
  }, {
    key: "getNumberFixedLeftColumns",
    value: function getNumberFixedLeftColumns(header, num) {
      var out = 0;
      for (var i = 0; i < num; i++)
        out += header[i]._.length;
      return out;
    }
  }, {
    key: "setHeaderInfo",
    value: function setHeaderInfo(header) {
      var _this4 = this;
      var headerLength = 0;
      var maxLevel = 1;
      var endIndex = 0;
      var ordinalIndex = 0;
      this.headerCellsByCellIndex = {};
      var _getItemLength = function getItemLength(_ref2) {
        var _item$children;
        var item2 = _ref2.item, rootIndex2 = _ref2.rootIndex, level = _ref2.level, parent = _ref2.parent, isLeft = _ref2.isLeft, isEditable = _ref2.isEditable, css = _ref2.css, view = _ref2.view, customizer = _ref2.customizer;
        var out = 0;
        if (level > maxLevel)
          maxLevel = level;
        if ((_item$children = item2.children) !== null && _item$children !== void 0 && _item$children.length) {
          for (var i in item2.children) {
            var child = item2.children[i];
            var childIsEditable = isEditable;
            var childCss = css;
            var childView = view;
            var childCustomizer = customizer;
            if (child.columns) {
              childIsEditable = child.columns.isEditable === void 0 ? isEditable : child.columns.isEditable;
              childCss = child.columns.css === void 0 ? css : _objectSpread2(_objectSpread2({}, css), child.columns.css);
              childView = child.columns.view === void 0 ? view : child.columns.view;
              childCustomizer = child.columns.customizer === void 0 ? customizer : child.columns.customizer;
            }
            out += _getItemLength({
              item: child,
              rootIndex: rootIndex2,
              level: level + 1,
              parent: item2,
              isLeft,
              isEditable: childIsEditable,
              css: childCss,
              view: childView,
              customizer: childCustomizer
            });
          }
          item2._ = {
            level,
            length: out,
            isEnd: false,
            parent,
            checked: true,
            isLeft,
            ordinalIndex,
            isEditable,
            css,
            view,
            customizer
          };
          ordinalIndex++;
          return out;
        }
        headerLength++;
        item2._ = {
          level,
          length: 1,
          isEnd: true,
          rootIndex: rootIndex2,
          endIndex,
          checked: true,
          parent,
          isLeft,
          ordinalIndex,
          isEditable,
          css,
          view,
          customizer
        };
        _this4.headerCellsByCellIndex[endIndex] = item2;
        ordinalIndex++;
        endIndex++;
        return 1;
      };
      for (var rootIndex in header) {
        var _header$rootIndex$col, _header$rootIndex$col2, _header$rootIndex$col3, _header$rootIndex$col4;
        _getItemLength({
          item: header[rootIndex],
          rootIndex: Number(rootIndex),
          level: 0,
          parent: null,
          isLeft: rootIndex < this.numberFixedLeftColumns,
          isEditable: (_header$rootIndex$col = header[rootIndex].columns) === null || _header$rootIndex$col === void 0 ? void 0 : _header$rootIndex$col.isEditable,
          css: ((_header$rootIndex$col2 = header[rootIndex].columns) === null || _header$rootIndex$col2 === void 0 ? void 0 : _header$rootIndex$col2.css) || {},
          view: ((_header$rootIndex$col3 = header[rootIndex].columns) === null || _header$rootIndex$col3 === void 0 ? void 0 : _header$rootIndex$col3.view) || null,
          customizer: ((_header$rootIndex$col4 = header[rootIndex].columns) === null || _header$rootIndex$col4 === void 0 ? void 0 : _header$rootIndex$col4.customizer) || null
        });
      }
      if (this.numberFixedLeftColumns) {
        var setEndOfLeft = function setEndOfLeft2(item2) {
          var _item$children2;
          item2._.isEndOfLeftPart = true;
          if ((_item$children2 = item2.children) !== null && _item$children2 !== void 0 && _item$children2.length)
            return item2.children[item2.children.length - 1];
          return null;
        };
        var item = header[this.numberFixedLeftColumns - 1];
        while (item) {
          item = setEndOfLeft(item);
        }
      }
      this.headerLength = headerLength;
      this.headerMaxLevel = maxLevel + 1;
    }
  }, {
    key: "orderTreeToOrderEnds",
    value: function orderTreeToOrderEnds() {
      var orderTree = this.connector.orderTree;
      var out = [];
      var _checkChildren = function checkChildren(tree) {
        var _iterator14 = _createForOfIteratorHelper(tree), _step14;
        try {
          for (_iterator14.s(); !(_step14 = _iterator14.n()).done; ) {
            var item = _step14.value;
            if (item.ch) {
              _checkChildren(item.ch);
            } else {
              out.push(item.orig);
            }
          }
        } catch (err) {
          _iterator14.e(err);
        } finally {
          _iterator14.f();
        }
      };
      _checkChildren(orderTree);
      this.connector.orderEnds = out;
    }
  }, {
    key: "recalcHeaderRootsPadding",
    value: function recalcHeaderRootsPadding() {
      var _this$connector8 = this.connector, headerRoot = _this$connector8.data.headerRoot, headerRight = _this$connector8.refs.headerRight;
      var _headerRight$getBound = headerRight.getBoundingClientRect(), startView = _headerRight$getBound.left, endView = _headerRight$getBound.right;
      var _iterator15 = _createForOfIteratorHelper(headerRoot), _step15;
      try {
        for (_iterator15.s(); !(_step15 = _iterator15.n()).done; ) {
          var root2 = _step15.value;
          var ref = root2.ref, refresh = root2.refresh;
          var _ref$getBoundingClien = ref.getBoundingClientRect(), left = _ref$getBoundingClien.left, right = _ref$getBoundingClien.right;
          if (left < startView && right > startView || left < endView || right > endView)
            refresh();
        }
      } catch (err) {
        _iterator15.e(err);
      } finally {
        _iterator15.f();
      }
    }
  }, {
    key: "getHeaderRootsPadding",
    value: function getHeaderRootsPadding(ref) {
      var paddingLeft = 0;
      var paddingRight = 0;
      var minWidth = 200;
      if (!ref)
        return {
          paddingLeft,
          paddingRight
        };
      var headerRight = this.connector.refs.headerRight;
      var _ref$getBoundingClien2 = ref.getBoundingClientRect(), left = _ref$getBoundingClien2.left, right = _ref$getBoundingClien2.right;
      var _headerRight$getBound2 = headerRight.getBoundingClientRect(), startView = _headerRight$getBound2.left, endView = _headerRight$getBound2.right;
      var windowWidth = right - left;
      var maxPadding = windowWidth - minWidth;
      if (left < startView && right > startView)
        paddingLeft = Math.min(maxPadding, startView - left);
      if (left < endView && right > endView)
        paddingRight = Math.min(maxPadding, right - endView);
      return {
        paddingLeft,
        paddingRight
      };
    }
  }, {
    key: "getEndsByHeaderCell",
    value: function getEndsByHeaderCell(cell) {
      var out = [];
      var _getEnds = function getEnds(cell2) {
        var _cell$children2;
        if (cell2._.isEnd) {
          out.push(cell2);
          return;
        }
        if (!((_cell$children2 = cell2.children) !== null && _cell$children2 !== void 0 && _cell$children2.length))
          return;
        var _iterator16 = _createForOfIteratorHelper(cell2.children), _step16;
        try {
          for (_iterator16.s(); !(_step16 = _iterator16.n()).done; ) {
            var _cell = _step16.value;
            _getEnds(_cell);
          }
        } catch (err) {
          _iterator16.e(err);
        } finally {
          _iterator16.f();
        }
      };
      _getEnds(cell);
      return out;
    }
  }, {
    key: "refreshHeaderRoots",
    value: function refreshHeaderRoots() {
      var headerRoot = this.connector.data.headerRoot;
      var _iterator17 = _createForOfIteratorHelper(headerRoot), _step17;
      try {
        for (_iterator17.s(); !(_step17 = _iterator17.n()).done; ) {
          var root2 = _step17.value;
          root2.refresh();
        }
      } catch (err) {
        _iterator17.e(err);
      } finally {
        _iterator17.f();
      }
    }
  }, {
    key: "refreshTableWidth",
    value: function refreshTableWidth() {
      var _this5 = this;
      setTimeout(function() {
        _this5.connector.refresh.scrollbarHorizontal();
        _this5.connector.refresh.scrollbarVertical();
        _this5.recalcHeaderRootsPadding();
        _this5.connector.refs.unitable.style["maxWidth"] = "".concat(_this5.getTotalRowWidth(), "px");
      }, 0);
    }
  }, {
    key: "saveTableSettingsToLocaleStorage",
    value: function saveTableSettingsToLocaleStorage() {
      var _this$connector9 = this.connector, _sizes = _this$connector9.sizes, showColumns = _this$connector9.showColumns, orderTree = _this$connector9.orderTree, orderEnds = _this$connector9.orderEnds, header = _this$connector9.header, options = _this$connector9.options;
      var saveSettingsInLocaleStorage = options.saveSettingsInLocaleStorage, background = options.background, resize = options.resize, initialSizes = options.initialSizes, columns = options.columns, editableSettings = options.editableSettings, other = options.other;
      if (!saveSettingsInLocaleStorage)
        return;
      var sizes = JSON.parse(JSON.stringify(_sizes));
      if (initialSizes !== null && initialSizes !== void 0 && initialSizes.columnsWidth && !(resize !== null && resize !== void 0 && resize.columnsWidth) && !(editableSettings !== null && editableSettings !== void 0 && editableSettings.resizeColumnsWidth)) {
        delete sizes.columnsWidth;
      }
      var getTableFormat = function getTableFormat2() {
        var out = [];
        var _next = function next(children) {
          var _iterator18 = _createForOfIteratorHelper(children), _step18;
          try {
            for (_iterator18.s(); !(_step18 = _iterator18.n()).done; ) {
              var _cell$children3;
              var cell = _step18.value;
              if ((_cell$children3 = cell.children) !== null && _cell$children3 !== void 0 && _cell$children3.length) {
                _next(cell.children);
              }
              out.push(cell._.format || null);
            }
          } catch (err) {
            _iterator18.e(err);
          } finally {
            _iterator18.f();
          }
        };
        _next(header);
        return out;
      };
      var oldData = JSON.parse(localStorage.getItem("unitables_data") || "{}");
      var savedData = _objectSpread2(_objectSpread2({}, oldData), {}, _defineProperty$7({}, this.tableName, {
        sizes,
        showColumns,
        orderTree,
        orderEnds,
        format: getTableFormat(),
        options: {
          background,
          resize,
          columns,
          other
        }
      }));
      localStorage.setItem("unitables_data", JSON.stringify(savedData));
    }
  }, {
    key: "restoreTableSettingsFromLocaleStorage",
    value: function restoreTableSettingsFromLocaleStorage() {
      var _this6 = this;
      var _this$connector10 = this.connector, header = _this$connector10.header, saveSettingsInLocaleStorage = _this$connector10.options.saveSettingsInLocaleStorage;
      if (!saveSettingsInLocaleStorage)
        return;
      var totalData = JSON.parse(localStorage.getItem("unitables_data") || "{}");
      var data = totalData[this.tableName];
      if (!data)
        return;
      var setTableFormat = function setTableFormat2(format2) {
        var ordinalIndex = 0;
        var _next2 = function next(children) {
          var _iterator19 = _createForOfIteratorHelper(children), _step19;
          try {
            var _loop22 = function _loop23() {
              var _cell$children4;
              var cell = _step19.value;
              if ((_cell$children4 = cell.children) !== null && _cell$children4 !== void 0 && _cell$children4.length) {
                _next2(cell.children);
              }
              if (format2[ordinalIndex]) {
                cell._.format = format2[ordinalIndex];
                setTimeout(function() {
                  _this6.refreshColumnsTree({
                    data: cell._.format,
                    cell,
                    connectorIndex: "format",
                    isObject: true
                  });
                }, 0);
              }
              ordinalIndex++;
            };
            for (_iterator19.s(); !(_step19 = _iterator19.n()).done; ) {
              _loop22();
            }
          } catch (err) {
            _iterator19.e(err);
          } finally {
            _iterator19.f();
          }
        };
        _next2(header);
      };
      for (var key in data) {
        if (key === "format") {
          setTableFormat(data[key]);
        } else {
          if (key === "options") {
            for (var optionKey in data.options) {
              this.connector.options[optionKey] = data.options[optionKey];
            }
          } else {
            this.connector[key] = data[key];
          }
        }
      }
      this.orderTreeToOrderEnds();
    }
  }, {
    key: "refreshColumn",
    value: function refreshColumn(num) {
      var _iterator20 = _createForOfIteratorHelper(this.connector.refresh.column[num]), _step20;
      try {
        for (_iterator20.s(); !(_step20 = _iterator20.n()).done; ) {
          var func = _step20.value;
          func();
        }
      } catch (err) {
        _iterator20.e(err);
      } finally {
        _iterator20.f();
      }
    }
  }, {
    key: "refreshAllColumns",
    value: function refreshAllColumns() {
      var _iterator21 = _createForOfIteratorHelper(this.connector.refresh.column), _step21;
      try {
        for (_iterator21.s(); !(_step21 = _iterator21.n()).done; ) {
          var column = _step21.value;
          var _iterator22 = _createForOfIteratorHelper(column), _step22;
          try {
            for (_iterator22.s(); !(_step22 = _iterator22.n()).done; ) {
              var func = _step22.value;
              func();
            }
          } catch (err) {
            _iterator22.e(err);
          } finally {
            _iterator22.f();
          }
        }
      } catch (err) {
        _iterator21.e(err);
      } finally {
        _iterator21.f();
      }
    }
  }, {
    key: "correctionRowsLength",
    value: function correctionRowsLength(rows, length) {
      var out = [];
      var text = "\u041F\u0440\u0430\u0432\u0438\u0442\u0435\u043B\u044C\u0441\u0442\u0432\u043E \u0412\u0435\u043D\u0435\u0441\u0443\u044D\u043B\u044B \u0440\u0435\u0448\u0438\u043B\u043E \u043E\u0442\u043E\u0437\u0432\u0430\u0442\u044C \u0432\u0435\u0441\u044C \u0434\u0438\u043F\u043B\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438\u0439 \u043F\u0435\u0440\u0441\u043E\u043D\u0430\u043B \u0438\u0437 \u0410\u0440\u0433\u0435\u043D\u0442\u0438\u043D\u044B, \u0414\u043E\u043C\u0438\u043D\u0438\u043A\u0430\u043D\u0441\u043A\u043E\u0439 \u0420\u0435\u0441\u043F\u0443\u0431\u043B\u0438\u043A\u0438, \u041A\u043E\u0441\u0442\u0430-\u0420\u0438\u043A\u0438, \u041F\u0430\u043D\u0430\u043C\u044B, \u041F\u0435\u0440\u0443, \u0423\u0440\u0443\u0433\u0432\u0430\u044F \u0438 \u0427\u0438\u043B\u0438, \u0432\u043B\u0430\u0441\u0442\u0438 \u043A\u043E\u0442\u043E\u0440\u044B\u0445 \u0440\u0430\u0441\u043A\u0440\u0438\u0442\u0438\u043A\u043E\u0432\u0430\u043B\u0438 \u0440\u0435\u0437\u0443\u043B\u044C\u0442\u0430\u0442\u044B \u043F\u0440\u043E\u0448\u0435\u0434\u0448\u0438\u0445 \u043F\u0440\u0435\u0437\u0438\u0434\u0435\u043D\u0442\u0441\u043A\u0438\u0445 \u0432\u044B\u0431\u043E\u0440\u043E\u0432. \u0421\u043E\u0433\u043B\u0430\u0441\u043D\u043E \u0431\u044E\u043B\u043B\u0435\u0442\u0435\u043D\u044E \u041D\u0430\u0446\u0438\u043E\u043D\u0430\u043B\u044C\u043D\u043E\u0433\u043E \u0438\u0437\u0431\u0438\u0440\u0430\u0442\u0435\u043B\u044C\u043D\u043E\u0433\u043E \u0441\u043E\u0432\u0435\u0442\u0430, \u043E\u043F\u0443\u0431\u043B\u0438\u043A\u043E\u0432\u0430\u043D\u043D\u043E\u043C\u0443 \u043F\u043E\u0441\u043B\u0435 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0438 80% \u043F\u0440\u043E\u0442\u043E\u043A\u043E\u043B\u043E\u0432, \u0434\u0435\u0439\u0441\u0442\u0432\u0443\u044E\u0449\u0435\u0433\u043E \u043B\u0438\u0434\u0435\u0440\u0430 \u041D\u0438\u043A\u043E\u043B\u0430\u0441\u0430 \u041C\u0430\u0434\u0443\u0440\u043E \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0430\u043B\u0438 5 150 092 \u0438\u0437\u0431\u0438\u0440\u0430\u0442\u0435\u043B\u044F (51,2% \u043F\u0440\u043E\u0433\u043E\u043B\u043E\u0441\u043E\u0432\u0430\u0432\u0448\u0438\u0445). \u0413\u043B\u0430\u0432\u0430 \u0410\u0440\u0433\u0435\u043D\u0442\u0438\u043D\u044B \u0425\u0430\u0432\u044C\u0435\u0440 \u041C\u0438\u043B\u0435\u0439 \u043D\u0435 \u043F\u0440\u0438\u0437\u043D\u0430\u043B \u043F\u043E\u0431\u0435\u0434\u0443 \u041C\u0430\u0434\u0443\u0440\u043E \u043D\u0430 \u0432\u044B\u0431\u043E\u0440\u0430\u0445 \u0432 \u0412\u0435\u043D\u0435\u0441\u0443\u044D\u043B\u0435.";
      var getRandomInt = function getRandomInt2(min2, max2) {
        min2 = Math.ceil(min2);
        max2 = Math.floor(max2);
        return Math.floor(Math.random() * (max2 - min2 + 1)) + min2;
      };
      if (!(rows !== null && rows !== void 0 && rows.length))
        return out;
      var rowCorrection = function rowCorrection2(row2) {
        var addCount = length - row2.length;
        for (var i = 0; i < addCount; i++) {
          var from2 = getRandomInt(0, 400);
          var _length = getRandomInt(3, 90);
          row2.push({
            value: text.slice(from2, from2 + _length)
          });
        }
        return row2.slice(0, length);
      };
      var _iterator23 = _createForOfIteratorHelper(rows), _step23;
      try {
        for (_iterator23.s(); !(_step23 = _iterator23.n()).done; ) {
          var row = _step23.value;
          out.push(_objectSpread2({}, rowCorrection(row)));
        }
      } catch (err) {
        _iterator23.e(err);
      } finally {
        _iterator23.f();
      }
      return out;
    }
  }, {
    key: "splitRowByLeftAndRight",
    value: function splitRowByLeftAndRight(row, num) {
      return [row.slice(0, num), row.slice(num)];
    }
  }, {
    key: "getBodyHeight",
    value: function getBodyHeight() {
      var _this$connector11 = this.connector, _this$connector11$siz = _this$connector11.sizes, headerHeight = _this$connector11$siz.headerHeight, paginatorHeight = _this$connector11$siz.paginatorHeight, hasPaginator = _this$connector11.tableHas.paginator;
      var additionalHeight = headerHeight + (hasPaginator ? paginatorHeight : 0);
      return "calc(100% - ".concat(additionalHeight, "px)");
    }
  }, {
    key: "getLeftPartRowWidth",
    value: function getLeftPartRowWidth() {
      var _this$connector12 = this.connector, numberFixedLeftColumnsEnds = _this$connector12.numberFixedLeftColumnsEnds, columnsWidth = _this$connector12.sizes.columnsWidth, showColumns = _this$connector12.showColumns;
      var out = 0;
      for (var i = 0; i < numberFixedLeftColumnsEnds; i++) {
        if (showColumns[i]) {
          out += columnsWidth[i];
        }
      }
      return out;
    }
  }, {
    key: "getRightPartRowWidth",
    value: function getRightPartRowWidth() {
      var _this$connector13 = this.connector, numberFixedLeftColumnsEnds = _this$connector13.numberFixedLeftColumnsEnds, columnsWidth = _this$connector13.sizes.columnsWidth, showColumns = _this$connector13.showColumns;
      var out = 0;
      for (var i = numberFixedLeftColumnsEnds; i < columnsWidth.length; i++) {
        if (showColumns[i]) {
          out += columnsWidth[i];
        }
      }
      return out;
    }
  }, {
    key: "getTotalRowWidth",
    value: function getTotalRowWidth() {
      var _this$connector14 = this.connector, columnsWidth = _this$connector14.sizes.columnsWidth, showColumns = _this$connector14.showColumns;
      var out = 0;
      for (var i in columnsWidth) {
        if (showColumns[i]) {
          out += columnsWidth[i];
        }
      }
      return out;
    }
  }, {
    key: "refreshColumnsTree",
    value: function refreshColumnsTree(_ref3) {
      var data = _ref3.data, cell = _ref3.cell, connectorIndex = _ref3.connectorIndex, isObject2 = _ref3.isObject;
      var arr = this.connector[connectorIndex];
      var refreshList = [];
      var _getChildren2 = function getChildren(children) {
        var _iterator24 = _createForOfIteratorHelper(children), _step24;
        try {
          for (_iterator24.s(); !(_step24 = _iterator24.n()).done; ) {
            var _item$children3;
            var item = _step24.value;
            if ((_item$children3 = item.children) !== null && _item$children3 !== void 0 && _item$children3.length) {
              _getChildren2(item.children);
            } else {
              refreshList.push(item._.endIndex);
            }
          }
        } catch (err) {
          _iterator24.e(err);
        } finally {
          _iterator24.f();
        }
      };
      if (isNaN(cell._.endIndex))
        _getChildren2(cell.children);
      else
        refreshList[0] = cell._.endIndex;
      cell._[connectorIndex] = data;
      for (var _i2 = 0, _refreshList = refreshList; _i2 < _refreshList.length; _i2++) {
        var cellIndex = _refreshList[_i2];
        arr[cellIndex] = this.recalcDataByCellIndex(cellIndex, connectorIndex, isObject2);
        this.refreshColumn(cellIndex);
      }
    }
  }, {
    key: "recalcDataByCellIndex",
    value: function recalcDataByCellIndex(cellIndex, connectorIndex, isObject2) {
      var cell = this.headerCellsByCellIndex[cellIndex];
      var data = cell._[connectorIndex] || null;
      var concat = function concat2(_old, _new) {
        var out = _objectSpread2({}, _old);
        for (var index2 in _new) {
          if (!out[index2])
            out[index2] = _new[index2];
        }
        return out;
      };
      while ((_cell2 = cell) !== null && _cell2 !== void 0 && _cell2._.parent && (!data || isObject2)) {
        var _cell2;
        cell = cell._.parent;
        if (cell._[connectorIndex]) {
          data = isObject2 ? concat(data, cell._[connectorIndex]) : cell._[connectorIndex];
        }
      }
      return data;
    }
  }, {
    key: "getSearchContextByCellIndex",
    value: function getSearchContextByCellIndex(cellIndex) {
      return this.connector.searchContext[cellIndex];
    }
  }, {
    key: "getFormatByCellIndex",
    value: function getFormatByCellIndex(cellIndex) {
      return this.connector.format[cellIndex];
    }
  }, {
    key: "storeGetPagesId",
    value: function storeGetPagesId() {
      var pageLength = this.connector.params.pageLength;
      return "unitable.".concat(this.tableName, ".pages.length ").concat(pageLength);
    }
  }, {
    key: "storeGetPageId",
    value: function storeGetPageId(pNum) {
      var _this$connector15 = this.connector, pageNum = _this$connector15.params.pageNum, sortCell = _this$connector15.sortCell, searchContext = _this$connector15.searchContext;
      var _iterator25 = _createForOfIteratorHelper(searchContext), _step25;
      try {
        for (_iterator25.s(); !(_step25 = _iterator25.n()).done; ) {
          var search = _step25.value;
          if (search)
            return null;
        }
      } catch (err) {
        _iterator25.e(err);
      } finally {
        _iterator25.f();
      }
      if (sortCell)
        return null;
      return "".concat(this.storeGetPagesId(), ".").concat(!isNaN(pNum) ? pNum : pageNum);
    }
  }, {
    key: "storeGetAnyPageId",
    value: function storeGetAnyPageId(pNum) {
      var _this$connector16 = this.connector, _this$connector16$par = _this$connector16.params, pageNum = _this$connector16$par.pageNum, pageLength = _this$connector16$par.pageLength, sortCell = _this$connector16.sortCell, searchContext = _this$connector16.searchContext, searchLogicAND = _this$connector16.options.other.searchLogicAND;
      var out = "unitable.".concat(this.tableName, ".anyPages.length=").concat(pageLength);
      var searchType = "";
      for (var i in searchContext) {
        if (searchContext[i]) {
          out += "&search".concat(i, "=").concat(searchContext[i]);
          searchType = "&searchType=".concat(searchLogicAND ? "AND" : "OR");
        }
      }
      out += searchType;
      if (sortCell) {
        var _sortCell$_ = sortCell._, ordinalIndex = _sortCell$_.ordinalIndex, sort2 = _sortCell$_.sort;
        out += "&sort".concat(ordinalIndex, "=").concat(sort2);
      }
      return out + ".".concat(!isNaN(pNum) ? pNum : pageNum);
    }
  }, {
    key: "storeGetAnyRowsId",
    value: function storeGetAnyRowsId(props) {
      var _ref4 = props || {}, withoutSort = _ref4.withoutSort;
      var _this$connector17 = this.connector, sortCell = _this$connector17.sortCell, searchContext = _this$connector17.searchContext, searchLogicAND = _this$connector17.options.other.searchLogicAND;
      var out = "";
      var searchType = "";
      for (var i in searchContext) {
        if (searchContext[i]) {
          if (out)
            out += "&";
          out += "search".concat(i, "=").concat(searchContext[i]);
          searchType = "&searchType=".concat(searchLogicAND ? "AND" : "OR");
        }
      }
      out += searchType;
      if (sortCell && !withoutSort) {
        var _sortCell$_2 = sortCell._, ordinalIndex = _sortCell$_2.ordinalIndex, sort2 = _sortCell$_2.sort;
        if (out)
          out += "&";
        out += "sort".concat(ordinalIndex, "=").concat(sort2);
      }
      return out ? "unitable.".concat(this.tableName, ".anyRows.").concat(out) : this.storeGetRowsId();
    }
  }, {
    key: "storeGetRowsId",
    value: function storeGetRowsId() {
      return "unitable.".concat(this.tableName, ".rows");
    }
  }, {
    key: "storeGetPages",
    value: function storeGetPages() {
      return this.storeGet(this.storeGetPagesId());
    }
  }, {
    key: "storeRowsIsLoaded",
    value: function storeRowsIsLoaded() {
      return !!this.storeGetRows();
    }
  }, {
    key: "storeGetRows",
    value: function storeGetRows() {
      return this.storeGet(this.storeGetRowsId());
    }
  }, {
    key: "storeSetRows",
    value: function storeSetRows(rows) {
      Store$1.setState(this.storeGetRowsId(), _toConsumableArray(rows));
    }
  }, {
    key: "storeGet",
    value: function storeGet(id) {
      var data = toJS(Store$1.getState(id));
      if (Array.isArray(data))
        return _toConsumableArray(data);
      if (!!data && _typeof$1(data) === "object")
        return _objectSpread2({}, data);
      return data;
    }
  }, {
    key: "storeGetTotalRowsByDownloadedPages",
    value: function storeGetTotalRowsByDownloadedPages() {
      var count2 = 0;
      var pages = this.storeGet(this.storeGetPagesId());
      for (var index2 in pages)
        count2 += pages[index2].length;
      return count2;
    }
  }, {
    key: "storeRememberPage",
    value: function storeRememberPage() {
      var _ref5;
      var totalLength = this.connector.params.totalLength;
      if (this.storeRowsIsLoaded())
        return;
      var pageId = this.storeGetPageId();
      if (!pageId) {
        var anyPageId = this.storeGetAnyPageId();
        if (!this.storeGet(anyPageId)) {
          Store$1.setState(anyPageId, _toConsumableArray(this.connector.rowsTree));
        }
        return;
      }
      if (this.storeGetPage())
        return;
      Store$1.setState(pageId, _toConsumableArray(this.connector.rowsTree));
      if (!totalLength)
        return;
      if (this.storeGetTotalRowsByDownloadedPages() !== totalLength)
        return;
      var pages = this.storeGetPages();
      this.storeSetRows((_ref5 = []).concat.apply(_ref5, _toConsumableArray(Object.values(pages))));
    }
  }, {
    key: "storeGetPage",
    value: function storeGetPage(props) {
      console.log("store", toJS(Store$1.getStore()));
      console.log("connector", this.connector);
      var _ref6 = props || {}, _pageNum = _ref6.pageNum;
      var params = this.connector.params;
      var pageId = null;
      var rows = null;
      var pageNum = !isNaN(_pageNum) ? _pageNum : params.pageNum;
      if (this.storeRowsIsLoaded()) {
        return this.storeGetPageFromRows(props);
      }
      pageId = this.storeGetPageId(pageNum);
      if (!pageId)
        pageId = this.storeGetAnyPageId(pageNum);
      rows = this.storeGet(pageId);
      return rows;
    }
  }, {
    key: "storeGetPageFromRows",
    value: function storeGetPageFromRows(props) {
      var _ref7 = props || {}, _pageLength = _ref7.pageLength, _pageNum = _ref7.pageNum;
      var params = this.connector.params;
      var pageLength = _pageLength || params.pageLength;
      var pageNum = !isNaN(_pageNum) ? _pageNum : params.pageNum;
      var rowsOrAnyRowsId = this.storeGetAnyRowsId();
      var rows = this.storeGet(rowsOrAnyRowsId);
      if (!rows) {
        rows = this.storeCreateAndRememberAnyRows(rowsOrAnyRowsId);
      }
      this.connector.params.totalLength = rows.length;
      this.connector.refresh.paginator();
      return rows.slice(pageLength * pageNum, pageLength * (pageNum + 1));
    }
  }, {
    key: "storeCreateAndRememberAnyRows",
    value: function storeCreateAndRememberAnyRows(id) {
      var _this$connector18 = this.connector, sortCell = _this$connector18.sortCell, searchContext = _this$connector18.searchContext;
      var rows = [];
      var idWithoutSort = this.storeGetAnyRowsId({
        withoutSort: true
      });
      rows = this.storeGet(idWithoutSort);
      if (!rows) {
        rows = this.storeGetRows();
        rows = this.storeRowsToFilteredRows(rows, searchContext);
        Store$1.setState(idWithoutSort, _toConsumableArray(rows));
      }
      rows = this.storeRowsToSortedRows(rows, sortCell);
      Store$1.setState(id, _toConsumableArray(rows));
      return rows;
    }
  }, {
    key: "storeRowsToFilteredRows",
    value: function storeRowsToFilteredRows(rows, searchContext) {
      var _this$connector$optio;
      var searchLogicAND = (_this$connector$optio = this.connector.options) === null || _this$connector$optio === void 0 || (_this$connector$optio = _this$connector$optio.other) === null || _this$connector$optio === void 0 ? void 0 : _this$connector$optio.searchLogicAND;
      var out = [];
      var search = [];
      for (var index2 in searchContext) {
        if (searchContext[index2]) {
          search.push({
            index: Number(index2),
            text: searchContext[index2].toLowerCase()
          });
        }
      }
      if (!search.length)
        return rows;
      var compare = function compare2(row2) {
        for (var _i3 = 0, _search = search; _i3 < _search.length; _i3++) {
          var s = _search[_i3];
          var find = ~String(row2[s.index].value).toLowerCase().indexOf(s.text);
          if (searchLogicAND && !find)
            return false;
          if (!searchLogicAND && find)
            return true;
        }
        return searchLogicAND ? true : false;
      };
      var _checkRow = function checkRow(_ref8) {
        var _row$children2;
        var row2 = _ref8.row, to2 = _ref8.to, level = _ref8.level;
        var root2 = {
          children: [],
          row: row2.row
        };
        if ((_row$children2 = row2.children) !== null && _row$children2 !== void 0 && _row$children2.length) {
          var _iterator26 = _createForOfIteratorHelper(row2.children), _step26;
          try {
            for (_iterator26.s(); !(_step26 = _iterator26.n()).done; ) {
              var child = _step26.value;
              _checkRow({
                row: child,
                to: root2.children,
                level: level + 1
              });
            }
          } catch (err) {
            _iterator26.e(err);
          } finally {
            _iterator26.f();
          }
        }
        var find = compare(root2.row);
        if (root2.children.length || find) {
          to2.push(root2);
          if (!find)
            root2._ = {
              isNotFind: true
            };
        }
      };
      var _iterator27 = _createForOfIteratorHelper(rows), _step27;
      try {
        for (_iterator27.s(); !(_step27 = _iterator27.n()).done; ) {
          var row = _step27.value;
          _checkRow({
            row,
            to: out,
            level: 0
          });
        }
      } catch (err) {
        _iterator27.e(err);
      } finally {
        _iterator27.f();
      }
      return out;
    }
  }, {
    key: "storeRowsToSortedRows",
    value: function storeRowsToSortedRows(rows, sortCell) {
      var _sortCell$_3;
      if (!(sortCell !== null && sortCell !== void 0 && (_sortCell$_3 = sortCell._) !== null && _sortCell$_3 !== void 0 && _sortCell$_3.sort))
        return rows;
      var _ref9 = sortCell || {}, _ref9$_ = _ref9._, ordinalIndex = _ref9$_.ordinalIndex, _direction = _ref9$_.sort;
      var direction = _direction === "up" ? -1 : 1;
      var runCollator = new Intl.Collator("ru");
      var convert = function convert2(cell) {
        return String(cell.row[ordinalIndex].value).toLowerCase().replace(/^\s+/, "");
      };
      var sortFunc = function sortFunc2(a, b) {
        return runCollator.compare(convert(a), convert(b)) * direction;
      };
      var _sort2 = function sort2(arr) {
        arr.sort(sortFunc);
        var _iterator28 = _createForOfIteratorHelper(arr), _step28;
        try {
          for (_iterator28.s(); !(_step28 = _iterator28.n()).done; ) {
            var _item$children4;
            var item = _step28.value;
            if ((_item$children4 = item.children) !== null && _item$children4 !== void 0 && _item$children4.length) {
              _sort2(item.children);
            }
          }
        } catch (err) {
          _iterator28.e(err);
        } finally {
          _iterator28.f();
        }
      };
      _sort2(rows);
      return rows;
    }
  }, {
    key: "setEditableCell",
    value: function setEditableCell(props) {
      if (this.connector.editableCell) {
        this.connector.editableCell.stopEditor();
      }
      this.connector.editableCell = props;
    }
  }, {
    key: "getCustomizer",
    value: function getCustomizer(_ref10) {
      var rules = _ref10.customizer, cell = _ref10.cell;
      var out = {
        css: {},
        "class": ""
      };
      var _iterator29 = _createForOfIteratorHelper(rules), _step29;
      try {
        for (_iterator29.s(); !(_step29 = _iterator29.n()).done; ) {
          var rule = _step29.value;
          var css = rule.css, _class = rule["class"], condition = rule.condition;
          var _iterator30 = _createForOfIteratorHelper(condition), _step30;
          try {
            for (_iterator30.s(); !(_step30 = _iterator30.n()).done; ) {
              var OR = _step30.value;
              var isSuccess = true;
              var _iterator31 = _createForOfIteratorHelper(OR), _step31;
              try {
                for (_iterator31.s(); !(_step31 = _iterator31.n()).done; ) {
                  var AND = _step31.value;
                  var match5 = AND.match(/(\S+)\s+(\S+)\s+(.*)/);
                  if (match5) {
                    var _match$slice = match5.slice(1), _match$slice2 = _slicedToArray(_match$slice, 3), field = _match$slice2[0], operand = _match$slice2[1], _text = _match$slice2[2];
                    var text = _text.replace(/^\s+/, "");
                    isSuccess = isSuccess && this.checkCondition({
                      field,
                      operand,
                      text,
                      cell
                    });
                  } else {
                    var _match = AND.match(/(\S+)\s+(.*)/);
                    if (_match) {
                      var _match$slice3 = _match.slice(1), _match$slice4 = _slicedToArray(_match$slice3, 2), _field = _match$slice4[0], _operand2 = _match$slice4[1];
                      isSuccess = isSuccess && this.checkCondition({
                        field: _field,
                        operand: _operand2,
                        text: null,
                        cell
                      });
                    } else {
                      this.customizerError('\u043D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0444\u043E\u0440\u043C\u0430\u0442 "'.concat(AND, '"'));
                      return out;
                    }
                  }
                }
              } catch (err) {
                _iterator31.e(err);
              } finally {
                _iterator31.f();
              }
              if (isSuccess) {
                out.css = _objectSpread2(_objectSpread2({}, out.css), css);
                out["class"] += (out["class"] ? " " : "") + _class;
              }
            }
          } catch (err) {
            _iterator30.e(err);
          } finally {
            _iterator30.f();
          }
        }
      } catch (err) {
        _iterator29.e(err);
      } finally {
        _iterator29.f();
      }
      return out;
    }
  }, {
    key: "checkCondition",
    value: function checkCondition(_ref11) {
      var field = _ref11.field, _operand = _ref11.operand, text = _ref11.text, cell = _ref11.cell;
      var value = cell[field];
      var matchNOT = _operand.match(/not\((\S+)\)/);
      var operand = matchNOT ? matchNOT[1] : _operand;
      var NOT = !!matchNOT;
      var result;
      switch (operand) {
        case "match":
          result = value !== null && value !== void 0 && value.match ? !!value.match(RegExp(text)) : false;
          break;
        case "contains":
          result = value !== null && value !== void 0 && value.indexOf ? !!~value.indexOf(text) : false;
          break;
        case "isNumber":
          result = !isNaN(value);
          break;
        case "isUndefined":
          result = value === void 0;
          break;
        case "isTrue":
          result = !!value;
          break;
        case "isFalse":
          result = !value;
          break;
        case "==":
          result = value == text;
          break;
        case "!=":
          result = value != text;
          break;
        case ">":
          result = value > text;
          break;
        case "<":
          result = value < text;
          break;
        case ">=":
          result = value >= text;
          break;
        case "<=":
          result = value <= text;
          break;
        default: {
          this.customizerError('\u043D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u044B\u0439 \u043E\u043F\u0435\u0440\u0430\u043D\u0434 "'.concat(operand, '"'));
          return false;
        }
      }
      return NOT ? !result : result;
    }
  }, {
    key: "customizerError",
    value: function customizerError(text) {
      var _this7 = this;
      if (!this.errorTexts) {
        this.errorTexts = {};
      }
      if (!this.errorTexts[text]) {
        console.error("\u041E\u0428\u0418\u0411\u041A\u0410 \u0412 \u041E\u041F\u0418\u0421\u0410\u041D\u0418\u0418 \u0423\u0421\u041B\u041E\u0412\u041D\u041E\u0413\u041E \u0424\u041E\u0420\u041C\u0410\u0422\u0418\u0420\u041E\u0412\u0410\u041D\u0418\u042F -- ".concat(text));
        this.errorTexts[text] = true;
        setTimeout(function() {
          _this7.errorTexts = {};
        }, 1e3);
      }
    }
  }]);
}();
var app = "";
export { Table, callTable };
